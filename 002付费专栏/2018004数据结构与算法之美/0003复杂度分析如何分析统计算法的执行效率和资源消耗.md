# 0003复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？
> 2018-09-26 王争

我们都知道，数据结构和算法本身解决的是「快」和「省」的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，执行效率是算法一个非常重要的考量指标。那如何来衡量你编写的算法代码的执行效率呢？这里就要用到我们今天要讲的内容：时间、空间复杂度分析。

其实，只要讲到数据结构与算法，就一定离不开时间、空间复杂度分析。而且，我个人认为，复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。

复杂度分析实在太重要了，因此我准备用两节内容来讲。希望你学完这个内容之后，无论在任何场景下，面对任何代码的复杂度分析，你都能做到「庖丁解牛」般游刃有余。

## 为什么需要复杂度分析？
你可能会有些疑惑，我把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小。为什么还要做时间、空间复杂度分析呢？这种分析方法能比我实实在在跑一遍得到的数据更准确吗？

首先，我可以肯定地说，你这种评估算法执行效率的方法是正确的。很多数据结构和算法书籍还给这种方法起了一个名字，叫事后统计法。但是，这种统计方法有非常大的局限性。

### 1. 测试结果非常依赖测试环境

测试环境中硬件的不同会对测试结果有很大的影响。比如，我们拿同样一段代码，分别用 Intel Core i9 处理器和 Intel Core i3 处理器来运行，不用说，i9 处理器要比 i3 处理器执行的速度快很多。还有，比如原本在这台机器上 a 代码执行的速度比 b 代码要快，等我们换到另一台机器上时，可能会有截然相反的结果。

### 2. 测试结果受数据规模的影响很大

后面我们会讲排序算法，我们先拿它举个例子。对同一个排序算法，待排序数据的有序度不一样，排序的执行时间就会有很大的差别。极端情况下，如果数据已经是有序的，那排序算法不需要做任何操作，执行时间就会非常短。除此之外，如果测试数据规模太小，测试结果可能无法真实地反应算法的性能。比如，对于小规模的数据排序，插入排序可能反倒会比快速排序要快！

所以，我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法。这就是我们今天要讲的时间、空间复杂度分析方法。

## 大 O 复杂度表示法
算法的执行效率，粗略地讲，就是算法代码执行的时间。但是，如何在不运行代码的情况下，用「肉眼」得到一段代码的执行时间呢？

这里有段非常简单的代码，求 1,2,3…n 的累加和。现在，我就带你一块来估算一下这段代码的执行时间。

```
1 int cal(int n) {
2   int sum = 0;
3   int i = 1;
4   for (; i <= n; ++i) {
5     sum = sum + i;
6   }
7   return sum;
8 }
```

从 CPU 的角度来看，这段代码的每一行都执行着类似的操作：读数据-运算-写数据。尽管每行代码对应的 CPU 执行的个数、执行的时间都不一样，但是，我们这里只是粗略估计，所以可以假设每行代码执行的时间都一样，为 unit_time。在这个假设的基础之上，这段代码的总执行时间是多少呢？

第 2、3 行代码分别需要 1 个 unit_time 的执行时间，第 4、5 行都运行了 n 遍，所以需要 2n * unit_time 的执行时间，所以这段代码总的执行时间就是 (2n+2)*unit_time。可以看出来，所有代码的执行时间 T(n) 与每行代码的执行次数成正比。

按照这个分析思路，我们再来看这段代码。

```
1 int cal(int n) {
2   int sum = 0;
3   int i = 1;
4   int j = 1;
5   for (; i <= n; ++i) {
6     j = 1;
7     for (; j <= n; ++j) {
8       sum = sum +  i * j;
9     }
10   }
11 }
```

我们依旧假设每个语句的执行时间是 unit_time。那这段代码的总执行时间 T(n) 是多少呢？

第 2、3、4 行代码，每行都需要 1 个 unit_time 的执行时间，第 5、6 行代码循环执行了 n 遍，需要 2n * unit_time 的执行时间，第 7、8 行代码循环执行了 n2 遍，所以需要 2n2 * unit_time 的执行时间。所以，整段代码总的执行时间 T(n) = (2n2+2n+3)*unit_time。

尽管我们不知道 unit_time 的具体值，但是通过这两段代码执行时间的推导过程，我们可以得到一个非常重要的规律，那就是，所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。

我们可以把这个规律总结成一个公式。注意，大 O 就要登场了！

	T(n)=O(f(n))

我来具体解释一下这个公式。其中，T(n) 我们已经讲过了，它表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。

所以，第一个例子中的 T(n) = O(2n+2)，第二个例子中的 T(n) = O(2n2+2n+3)。这就是大 O 时间复杂度表示法。大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度「asymptotic time complexity」，简称时间复杂度。

当 n 很大时，你可以把它想象成 10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了，如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以记为：T(n) = O(n)； T(n) = O(n2)。

## 时间复杂度分析
前面介绍了大 O 时间复杂度的由来和表示方法。现在我们来看下，如何分析一段代码的时间复杂度？我这儿有三个比较实用的方法可以分享给你。

1. 只关注循环执行次数最多的一段代码

我刚才说了，大 O 这种复杂度表示方法只是表示一种变化趋势。我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。所以，我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了。这段核心代码执行次数的 n 的量级，就是整段要分析代码的时间复杂度。

为了便于你理解，我还拿前面的例子来说明。

```
1 int cal(int n) {
2   int sum = 0;
3   int i = 1;
4   for (; i <= n; ++i) {
5     sum = sum + i;
6   }
7   return sum;
8 }
```

其中第 2、3 行代码都是常量级的执行时间，与 n 的大小无关，所以对于复杂度并没有影响。循环执行次数最多的是第 4、5 行代码，所以这块代码要重点分析。前面我们也讲过，这两行代码被执行了 n 次，所以总的时间复杂度就是 O(n)。

2. 加法法则：总复杂度等于量级最大的那段代码的复杂度

我这里还有一段代码。你可以先试着分析一下，然后再往下看跟我的分析思路是否一样。

int cal(int n) {
   int sum_1 = 0;
   int p = 1;
   for (; p < 100; ++p) {
     sum_1 = sum_1 + p;
   }

   int sum_2 = 0;
   int q = 1;
   for (; q < n; ++q) {
     sum_2 = sum_2 + q;
   }
 
   int sum_3 = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1; 
     for (; j <= n; ++j) {
       sum_3 = sum_3 +  i * j;
     }
   }
 
   return sum_1 + sum_2 + sum_3;
 }
这个代码分为三部分，分别是求 sum_1、sum_2、sum_3。我们可以分别分析每一部分的时间复杂度，然后把它们放到一块儿，再取一个量级最大的作为整段代码的复杂度。

第一段的时间复杂度是多少呢？这段代码循环执行了 100 次，所以是一个常量的执行时间，跟 n 的规模无关。

这里我要再强调一下，即便这段代码循环 10000 次、100000 次，只要是一个已知的数，跟 n 无关，照样也是常量级的执行时间。当 n 无限大的时候，就可以忽略。尽管对代码的执行时间会有很大影响，但是回到时间复杂度的概念来说，它表示的是一个算法执行效率与数据规模增长的变化趋势，所以不管常量的执行时间多大，我们都可以忽略掉。因为它本身对增长趋势并没有影响。

那第二段代码和第三段代码的时间复杂度是多少呢？答案是 O(n) 和 O(n2)，你应该能容易就分析出来，我就不啰嗦了。

综合这三段代码的时间复杂度，我们取其中最大的量级。所以，整段代码的时间复杂度就为 O(n2)。也就是说：总的时间复杂度就等于量级最大的那段代码的时间复杂度。那我们将这个规律抽象成公式就是：

如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n))).

3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

我刚讲了一个复杂度分析中的加法法则，这儿还有一个乘法法则。类比一下，你应该能“猜到”公式是什么样子的吧？

如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n)).

也就是说，假设 T1(n) = O(n)，T2(n) = O(n2)，则 T1(n) * T2(n) = O(n3)。落实到具体的代码上，我们可以把乘法法则看成是嵌套循环，我举个例子给你解释一下。

1int cal(int n) {
2   int ret = 0; 
3   int i = 1;
4   for (; i < n; ++i) {
5     ret = ret + f(i);
6   } 
7 } 
8 
9 int f(int n) {
10  int sum = 0;
11  int i = 1;
12  for (; i < n; ++i) {
13    sum = sum + i;
14  } 
15  return sum;
16 }
我们单独看 cal() 函数。假设 f() 只是一个普通的操作，那第 4～6 行的时间复杂度就是，T1(n) = O(n)。但 f() 函数本身不是一个简单的操作，它的时间复杂度是 T2(n) = O(n)，所以，整个 cal() 函数的时间复杂度就是，T(n) = T1(n) * T2(n) = O(n*n) = O(n2)。

我刚刚讲了三种复杂度的分析技巧。不过，你并不用刻意去记忆。实际上，复杂度分析这个东西关键在于“熟练”。你只要多看案例，多分析，就能做到“无招胜有招”。

几种常见时间复杂度实例分析
虽然代码千差万别，但是常见的复杂度量级并不多。我稍微总结了一下，这些复杂度量级几乎涵盖了你今后可以接触的所有代码的复杂度量级。



对于刚罗列的复杂度量级，我们可以粗略地分为两类，多项式量级和非多项式量级。其中，非多项式量级只有两个：O(2n) 和 O(n!)。

我们把时间复杂度为非多项式量级的算法问题叫作NP（Non-Deterministic Polynomial，非确定多项式）问题。

当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。因此，关于 NP 时间复杂度我就不展开讲了。我们主要来看几种常见的多项式时间复杂度。

1. O(1)

首先你必须明确一个概念，O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有 3 行，它的时间复杂度也是 O(1），而不是 O(3)。

1 int i = 8;
2 int j = 6;
3 int sum = i + j;
我稍微总结一下，只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。或者说，一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。

2. O(logn)、O(nlogn)

对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。我通过一个例子来说明一下。

1 i=1;
2 while (i <= n)  {
3   i = i * 2;
4 }
根据我们前面讲的复杂度分析方法，第三行代码是循环执行次数最多的。所以，我们只要能计算出这行代码被执行了多少次，就能知道整段代码的时间复杂度。

从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束。还记得我们高中学过的等比数列吗？实际上，变量 i 的取值就是一个等比数列。如果我把它一个一个列出来，就应该是这个样子的：



所以，我们只要知道 x 值是多少，就知道这行代码执行的次数了。通过 2x=n 求解 x 这个问题我们想高中应该就学过了，我就不多说了。x=log2n，所以，这段代码的时间复杂度就是 O(log2n)。

现在，我把代码稍微改下，你再看看，这段代码的时间复杂度是多少？

1 i=1;
2 while (i <= n)  {
3   i = i * 3;
4 }
根据我刚刚讲的思路，很简单就能看出来，这段代码的时间复杂度为 O(log3n)。

实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。为什么呢？

我们知道，对数之间是可以互相转换的，log3n 就等于 log32 * log2n，所以 O(log3n) = O(C * log2n)，其中 C=log32 是一个常量。基于我们前面的一个理论：在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))。所以，O(log2n) 就等于 O(log3n)。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。

如果你理解了我前面讲的 O(logn)，那 O(nlogn) 就很容易理解了。还记得我们刚讲的乘法法则吗？如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。而且，O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。

3. O(m+n)、O(m*n)

我们再来讲一种跟前面都不一样的时间复杂度，代码的复杂度由两个数据的规模来决定。老规矩，先看代码！

int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
从代码中可以看出，m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。

针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m)*T2(n) = O(f(m) * f(n))。

空间复杂度分析
前面，咱们花了很长时间讲大 O 表示法和时间复杂度分析，理解了前面讲的内容，空间复杂度分析方法学起来就非常简单了。

前面我讲过，时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。

我还是拿具体的例子来给你说明。（这段代码有点“傻”，一般没人会这么写，我这么写只是为了方便给你解释。）

1void print(int n) {
2  int i = 0;
3  int[] a = new int[n];
4  for (i; i <n; ++i) {
5    a[i] = i * i;
6  }

7  for (i = n-1; i >= 0; --i) {
8    print out a[i]
9  }
10}
跟时间复杂度分析一样，我们可以看到，第 2 行代码中，我们申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。

我们常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。所以，对于空间复杂度，掌握刚我说的这些内容已经足够了。

内容小结
基础复杂度分析的知识到此就讲完了，我们来总结一下。

复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )。等你学完整个专栏之后，你就会发现几乎所有的数据结构和算法的复杂度都跑不出这几个。



复杂度分析并不难，关键在于多练。 之后讲后面的内容时，我还会带你详细地分析每一种数据结构和算法的时间、空间复杂度。只要跟着我的思路学习、练习，你很快就能和我一样，每次看到代码的时候，简单的一眼就能看出其复杂度，难的稍微分析一下就能得出答案。

课后思考
有人说，我们项目之前都会进行性能测试，再做代码的时间复杂度、空间复杂度分析，是不是多此一举呢？而且，每段代码都分析一下时间复杂度、空间复杂度，是不是很浪费时间呢？你怎么看待这个问题呢？

欢迎留言和我分享，我会第一时间给你反馈。



版权归极客邦科技所有，未经许可不得转载

写留言
精选留言

xr

263
我不认为是多此一举，渐进时间，空间复杂度分析为我们提供了一个很好的理论分析的方向，并且它是宿主平台无关的，能够让我们对我们的程序或算法有一个大致的认识，让我们知道，比如在最坏的情况下程序的执行效率如何，同时也为我们交流提供了一个不错的桥梁，我们可以说，算法1的时间复杂度是O(n)，算法2的时间复杂度是O(logN)，这样我们立刻就对不同的算法有了一个“效率”上的感性认识。

当然，渐进式时间，空间复杂度分析只是一个理论模型，只能提供给粗略的估计分析，我们不能直接断定就觉得O(logN)的算法一定优于O(n), 针对不同的宿主环境，不同的数据集，不同的数据量的大小，在实际应用上面可能真正的性能会不同，个人觉得，针对不同的实际情况，进而进行一定的性能基准测试是很有必要的，比如在统一一批手机上(同样的硬件，系统等等)进行横向基准测试，进而选择适合特定应用场景下的最有算法。

综上所述，渐进式时间，空间复杂度分析与性能基准测试并不冲突，而是相辅相成的，但是一个低阶的时间复杂度程序有极大的可能性会优于一个高阶的时间复杂度程序，所以在实际编程中，时刻关心理论时间，空间度模型是有助于产出效率高的程序的，同时，因为渐进式时间，空间复杂度分析只是提供一个粗略的分析模型，因此也不会浪费太多时间，重点在于在编程时，要具有这种复杂度分析的思维。
2018-09-26
 作者回复
写得很好。理解的到位

2018-09-26


姜威

178
总结
一、什么是复杂度分析？
1.数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。
2.因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。
3.分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。
4.复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。
二、为什么要进行复杂度分析？
1.和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。
2.掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。
三、如何进行复杂度分析？
1.大O表示法
1）来源
算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。
2）特点
以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。
2.复杂度分析法则
1）单段代码看高频：比如循环。
2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。
3）嵌套代码求乘积：比如递归、多重循环等
4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。
四、常用的复杂度级别？
多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，
O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）
非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，
O(2^n)（指数阶）、O(n!)（阶乘阶）
五、如何掌握好复杂度分析方法？
复杂度分析关键在于多练，所谓孰能生巧。
2018-09-26
 作者回复
总结的很棒

2018-09-26


芳芳

55
糟糕，是看不懂的感觉
2018-09-26

Orcsir

44
老师，代码片段把行号也写上吧。
2018-09-26
 作者回复
嗯嗯 我联系运营加上

2018-09-26


w

26
第二个例子中，第6.7行为什么是2n平方遍而不是n平方遍呢？
2018-09-26
 作者回复
因为两层循环 一层是n 两层是n*n。不信你自己令n=5 自己算算

2018-09-26


有一天

17
一直有一个很纠结的问题，烦请解答一下：O具体是哪一个英文字母的缩写？
2018-09-26
 作者回复
不是英文缩写 就是一个数学符号而已

2018-09-26


吕宁

16
老师好，我们上算法课，老师讲到存储一个二进制数，输入规模（空间复杂度）是O(logn) bit。请问如何理解？
2018-09-26
 作者回复
比如8用二进制表示就是3个bit。16用二进制表示就是4个bit。以此类推 n用二进制表示就是logn个bit

2018-09-26


起名好难

15
文章里也说了，性能测试这种是受环境所影响的。作为程序员，我们能做的就是尽可能的降低复杂度，才能让代码在不同的环境下以最快的效率执行。至于是不是浪费时间，我觉得其实是个伪命题。首先按刚刚分析过程来看，通过熟悉练习，简单的代码是可以直接看出来复杂度的也就是不费时间；而比较复杂的代码就容易“一不小心”太“复杂”了，这个时候，为了代码质量考虑分析复杂度的时间也并不浪费。再有甚者，我们学习这个分析法，我觉得更多的是要明白这个理念，在写代码的时候就能关注一下这方面的问题，毕竟复杂的代码在写的过程往往是先分析整体逻辑结构的，并且写的过程也需要不断思考，了解这个理念后才能在写的过程中也思考关注这个点。不然，复杂的一段代码一旦写成，日后因为性能问题重构，更费时间。

以上是对课后题的思考，欢迎批评指正☺。
另: 感觉加法法则那个图，maxf(n)+g(n) 换成max(f(n)+g(n))会不会更好些？
2018-09-26
 作者回复
理解的非常透彻 非常有逻辑性 很赞。ps 图画错了 我联系运营改下

2018-09-26


dickwxyz@126.com

11
没有看懂，所以，我们只要知道 x 值是多少，就知道这行代码执行的次数了。通过 2x=n 求解 x 这个问题我们想高中应该就学过了，我就不多说了。 这里的x不就是代码里的n吗，时间复杂度不是O(n)吗？
2018-09-26
 作者回复
i 第一次等于1
第2次等于2
第3次等于2*2
第4次等于2*2*2
.....
第x次等于2的x-1次方
……
那第几次之后等于n呢

也就是2的x-1次方等于n求解x

x粗略点讲就近似于logn

也就是代码执行了logn遍就退出循环了

所以根据大o标记法 为logn




2018-09-26


最爱小黑黑

11
睡前刷一遍 明早起来再细看一遍 加油各位！
2018-09-26

陈华应

8
有必要，基准测试是事后，也是理论验证，有时候O(n)未必一定比O(1)效率低。
复杂度分析是理论，整体趋势上反应了一个算法的时间或者空间利用率与数据规模的渐进关系，并且像程序员之间使用设计模式来讨论代码设计一样，说出名字就大致知道代码是如何组织的，大O也是一样。
随着自己使用大O分析代码复杂度的熟练程度增加，判断一段代码的复杂度可能分分钟的事情，甚至更快。
2018-09-26
 作者回复
理解的很透彻！

2018-09-26


wistbean

6
--------总结一下--------

事后统计的局限性：

1.不同的环境测试结果差异大
2.数据本身规模会影响结果（如数据规模小，结果无法真实反应出算法的性能问题）

所以：需要复杂度分析


时间复杂度：

表示法：T(n) = O(n)； T(n) = O(n2)。 
T(n) 代表代码执行时间
(n)代表每行代码的执行次数总和

也就是每行代码的执行次数总和越大，那么代码执行就需要更多的时间。


时间复杂度分析方法：
1.只关注执行次数最多的那段代码。
2.加法法则：总复杂度取量级最大的那段代码。
3.乘法法则：代码之间复杂度有嵌套情况，将各个复杂度相乘得到总复杂度。

复杂度常见案例：

非多项式量级：
O（2^n）
O(n!)
n越大，算法执行时间急剧增加，相对低效

多项式量级：
O(1) : 不存在n的影响因素
O（logn）、O（nlogn）：对阶时间复杂度，最难分析之一。
O（m+n）、O（m*n） ：当数据规模无法评估哪个较大时，加法法则失效，可以使用 O（m+n）的方式。

空间复杂度分析
类比于时间复杂度就是：存储空间与数据规模的增长关系。


-----------课后思考--------------

不认为是浪费时间，性能的基准测试可能会受到环境，数据规模本身的影响，对时间复杂度、空间复杂度进行分析至少对一些复杂度能够做出判断，写出相对效率高的代码，此外，还能提升自己分析复杂度的思维和效率的认知。
2018-09-26
 作者回复
写得很好👍

2018-09-26


Dwyane

6
03 
大家好，这是我的总结：

公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略
1. 只关注循环执行次数最多的一段代码
2.加法法则：总复杂度等于量级最大的那段代码的复杂度
3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积


只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们集作O(1)
不同数据规模，无法评估 m 和 n 的量级大，所以不能利用加法法则，去掉某一个，而是 O(m+n)

空间复杂度：表示算法的存储空间与数据规模之间的增加关系

额外说一下：log3n 就等于 log32 * log2n 其实是利用换底公示推导，有疑问的搜一下。
2018-09-26
 作者回复
是换底公式 👍

2018-09-26


ChaoYrAx

6
老师 空间复杂度 和时间复杂度的 具体区别是什么，我怎么看上去像一样的
2018-09-26
 作者回复
一个表示内存的消耗 一个表示执行的快慢

2018-09-26


realEago

6
看不懂别慌，也别忙着总结，先读五遍文章先，无他，唯手熟尔~
2018-09-26
 作者回复
说的太好了 我这里也没葵花宝典 学还是得靠自己

2018-09-26


冯剑

6
在分析多项式复杂度的时候，有根据输入规模确定复杂度O(m+n),我的理解是 假设n是相对比较大的值，那么这个复杂度O(m+n)<=O(2n)，2是常量，这样的话复杂度不就是O(n),请问下，O(n)和O(m+n)的区别在什么地方？有什么应用场景能体现出二者不同
2018-09-26



6
考研数据结构会考到🤓🤓
2018-09-26

短迪大魔王

5
很有必要，现在是大数据时代，如果是矩阵计算，那就是on，如果是传统双for遍历那就是on²，做lr不依托矩阵都要天荒地老，那神经网络尤其是rnn就不用做了，即使是84万文本数据，长度为20个词，用单机gpu加速要跑七天。双for是几天那？经典例子是马踏棋盘，没优化代码跑几天，优化了又看不懂，问问老师如何对代码做优化，因为优化了就读不懂了有没有？
空间复杂度也有必要，还是nlp的例子，如果是embending的话，内存开销和磁盘开销都小的多，虽然现在分布式允许无限大，但是生产环境要把数据传到hdfs，再传到训练集群上，这都有网络传输开销啊，其二是可能没有这个权限，不安全。其三，生成npy文件不能shuffle，很不便利，也不允许分割，所以事先要想好空间要怎么来。当然时间更重要，敏捷迭代。
2018-09-26

scarlett

5
回答 thinkings 的问题
i=1; 
while (i <= n) {
i = i * 2
}
假设n= 20，i每次的取值是2 4 8 16 执行4次，时间复杂度是O(log2n)
i=1; 
while (i <= n) {
i = i + 2
}
假设 n=20 i每次取值：3，5，7，9，11，13，15，17，19 ，执行9次，时间复杂度是O(n/2),根据老师讲的 公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略，所以是O（n）
2018-09-26
 作者回复
👍 分析的通俗易懂 棒棒哒

2018-09-26


五岳寻仙

5
老师讲得太好了！记得上学时，刚接触大O，直接懵，并且丝毫没意识到复杂度分析的重要性，还觉得为什么不直接讲干货呢。现在想想真愚蠢！
今天课程的感悟：
第一，复杂度分析的重要性。我觉得再怎么强调其重要性也不为过，不具备这种意识，就很难摆脱底层码农的处境。
第二，理解“大”和“小”。科普书《从1到无穷大》中举到一个例子：比较自然数和奇数的个数，答案是一样多。当数据规模大到一定程度时，靠感觉是不够的，必须借助理论工具，大O表示法就是一个强有力的工具。
第三，抓主要矛盾。刚开始分析算法复杂度的时候，系数常数都考虑得很细致，这只是方便理解。真正在实际运用中，系数和常数都可以忽略，我们真正关心的是 算法是常数复杂度，对数复杂度还是线性复杂度等，它们之间有天壤之别，决定了计算量是几亿次还是几万亿次。

课后思考我觉得 xr 同学回答得非常好！我自己从中学到了很多。我举一个自己的例子：
我曾经需要对3G条数据排序，使用了内省排序，时间复杂度是nlogn，花了半个小时左右。假如我用选择排序，时间复杂度是n方，计算量是前者的几千万倍，在我有生之年也等不到排序结束。
2018-09-26

huangjh

4
有必要，性能测试更多的是一种实验结果。而复杂度分析，可以帮助我们分析内因。
2018-09-27
 作者回复
简洁到位！

2018-09-27


秋凯

4
看了下上面的总结，我想补充一下

学习复杂度的主要目的就一个：方便后续定性比较算法性能，比如归并是nlogn，插入是n²，所以归并快，而且快不少。

下一期是不是讲最坏情况和最好情况？
2018-09-26
 作者回复
是的。还有平均 均摊

2018-09-26


小疯子

4
思考题没有经历过，工作环境中没有出现过这个场景，算法学习只是自己一人在默默的修炼内功，从榜首那位的分析中涨了见识，也很在理~
今日学习感想：久违的数学学习之感~没有看过专门的算法书籍，没有对比感，真心感觉老师讲的很清晰！
今日笔记：
一、复杂度分析
1、为什么进行复杂度分析？研究算法与数据结构，目的在于“快执行+省存储空间”，故对代码的复杂度进行分析是极有必要的；
2、对比事后统计法（应该就是评论区里说的性能测试）的优点在于：后者依赖测试环境，且受数据规模的影响大，标准难把控；
3、概念：不利用测试数据，粗略估算代码的执行效率。
二、大O复杂度表示方法
1、T(n)=O(F(n)) ：T(n)代表代码执行时间，F(n)代表代码总执行次数，O表示代码执行时间与代码总执行次数成正比。
2、大O时间复杂度代表代码执行时间随数据规模增长的变化趋势，数据规模超大时，低阶、常量、系数并不能左右增长趋势，所以只需记录最大量级即可。
三、常见的时间复杂度的分析方法：
1、只关心循环执行次数最多的代码；
2、加法法则，取量级更大的那个:T(n)=O(max(f(n),g(n)));
3、乘法法则，嵌套代码复杂度=嵌套内外复杂度的乘积:T(n)=O(f(n)*g(n));

四、常见时间复杂度
第一种：多项式时间复杂度(按数量级递增)
1、O(1) 常量阶，代码执行时间不随n增大而增大，见于无循环无递归代码，不论多少行~O(1)是一种表示方式（不论多少行）；
2、O(logN)对数阶，因为对数可以互相转换，且常量系数可忽略，所以忽略对数的底；
3、O(n)线性阶；
4、O(nlogN)对数线性阶；
5、各种次方阶。
第二种：非多项式时间复杂度：O(2的n次方) 和 O(n!) 属于非常低效的算法
第三种：O（m+n）与O(m*n)，代码复杂度由两个数据规模决定，由于无法得知m、n哪个量级更大，故不能直接取其一。
五、空间复杂度分析
1、定义：算法存储空间与数据规模增长的关系，主要看声明的空间存储变量所需要的控件存储量
2、O(1)、O(n)、O(n平方)，个人认为可参考基本数据类型、一维数组、二维数组，希望老师可以加上代码举例。






2018-09-26

jackeymm

4
先进行性能测试，可以帮助我们找到瓶颈点，也就是时间复杂度最高的点，按照时间复杂度渐进的过程，复杂度最高的点，几乎可以等同于整个程序的复杂度，所以性能测试可以帮助我们减少分析类似o(1)这类复杂度低的程序的时间;
如果是作为练习，分析每段代码的复杂度，并不算浪费时间，如果是为了优化程序，我们就应该找到复杂度最高的部分进行分析，然后优化，但是这有一个前提是你能一眼分辨出绝大多数复杂度地的程序
2018-09-26
 作者回复
嗯嗯 说的不错

2018-09-26


Monday

4
本节通读两遍，通俗易懂，对复杂度的概念有了新的认识。
复杂度就是用来分析算法执行效率与数据规模之间增长关系。
思考题，性能测试与复杂度分析不冲突，原因如下：
1、性能测试是依附于具体的环境，如SIT、UAT机器配置及实例数量不一致结果也有差别。
2、复杂度分析是独立于环境的，可以大致估算出程序所执行的效率。
3、将复杂度熟记于心，能够写出更高效率、更好性能的代码。若某接口通过性能测试，达不到预期，还可以用复杂度分析接口代码，找出最影响性能的代码，进行优化。

每段代码都分析一下时间复杂度、空间复杂度，是不是很浪费时间呢？
这个问题分两种情况讨论
1、开发过程中，码代码的过程中就能得出其复杂度，这并不会太多的浪费时间，同时只有分析了每段代码的复杂度，才能估算出它们的执行效率。
2、优化代码时，只有在分析每段代码的复杂度后，才能定位问题代码，才能做相应优化

另外提出两个问题：
1、评论太多，也无法进行关键字搜索，一般没有时间爬楼全部看完，导致不同学友提出一样的问题
2、评论太多，可能有些评论不正确，需要官方确认正确与否，以免误导学友。


2018-09-26
 作者回复
理解的很透彻！

2018-09-26


A_foreign 이호연 wuli 혜리

3
老师 我不太明白为什么++i在这里而不是i++
您的书写习惯还是？
2018-09-27
 作者回复
书写习惯 没太大区别

2018-09-27


米斯特粥

3
大型的软件，最好是借助代码分析工具，并且适用28定律，尽量把时间花在那20%复杂度最高最影响性能的问题上，另外，工程上还有另外一种复杂度即圈复杂度也很重要。
2018-09-27

玉皇大亮

3
老师提出的问题，文章中已经回答了，通过打印代码执行时间进行性能测试统计属于事后统计方法，这种方法很直观，但是有局限性。1.测试结果依赖于测试环境，不同的机器由于配置不同可能会有不同的测试结果。2.测试的结果受数据规模的影响，同样一套算法，n和n^3数量级规模的直观结果肯定是不一样的，但是当数据的规模小时，算法的效率又不容易得到提现。通过提前分析代码的时间复杂度和空间复杂度，不仅做到对自己的代码心中有数，而且如果出了性能瓶颈，也比较好想到解决问题的方向。但是我觉得不是每部分代码都需要分析时间和空间复杂度的，只有核心算法部分需要重点关注，像一些业务调用接口，只需要注意下就可以了
2018-09-26
 作者回复
理解的到位！👍

2018-09-26


牵手约定

3
看着姜威大佬的总结，加上自己的总结，在小本本上记下来了。
2018-09-26

张远

3
难道没有O(n*3)这种复杂度吗
2018-09-26
 作者回复
你是说n的立方对吧 也有啊 不常见而已

2018-09-26


Andy

3
分析复杂度，倒是可以掌握一个分析算法大致流程，不至于无从下手，或者学完就忘。从软件开发角度来讲，提供了吐槽别人代码性能差的有效量化工具
2018-09-26
 作者回复
哈哈 也没错

2018-09-26


Shira

2
【所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比】
这句高亮的话不对吧。根据后文的意思，似乎应该是：T(n) 与每行代码的执行时间 unit_time 成正比。
两个例子的时间复杂度分别是： T(n) = (2n+2)* unit_time; T(n) = (2n^2+2n+3)*unit_time
我是数学系学渣初学数据结构与算法，感觉如果T(n)与n成正比，岂不是一定有形如 T(n)=a*n, a为某常量，这种关系了。
2018-09-28
 作者回复
正比不确切 谢谢指正。应该是跟f（n）成正比。f（n）就是你后面说的关于n的公式

2018-09-28


大坏蛋

2
影响程序运行时间的因素主要有：
（1）程序所依赖的算法
（2）问题规模和输入数据
（3）计算机系统性能
渐进复杂度分析，可以培养写出性能良好的代码习惯，尽量保证程序实现算法较优。但是复杂度分析只是粗略的理论分析，且算法只是影响程序性能的因素之一；纸上得来终觉浅，绝知此事要躬行；应用程序需要进行性能测试，压力测试，模拟实际应用场景检验 程序健壮性。
2018-09-27

赵虎

2
数据结构解决的问题：“快” + “省”，即为时间，空间复杂度分析
1：为什么需要复杂度分析？
因为通过统计手段分析的结果受到两个因素的影响，一：测试结果非常依赖测试环境，二：测试结果受数据规模的影响很大
2：大O复杂度表示法
所有代码的执行时间T(n)与每行代码的执行次数n成正比。
T(n) = O(f(n))
3:时间复杂度分析
1：只关注循环执行次数最多的一段代码
2：加法法则：总复杂度等于量级最大的那段代码的复杂度
3：乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
4：几种常见时间复杂度量级：
多项式量级：
	常数阶O(1)
	对数阶O(logn)
	线性阶O(n)
	线性对数阶O(nlogn)
	平方阶O(n*n),立方阶O(n*n*n)… k方阶O(n*……*n)
非多项式量级：
	指数阶O(2*……*2)
	阶乘阶O(n!)
5：空间复杂度分析:
常见的空间复杂度：O(1) O(n) O(n*n)
2018-09-26

Hubery_Jun

2
这是Java？
2018-09-26
 作者回复
哈哈 能看懂就行

2018-09-26


by

2
实际工作中有种情况就是集合里面装对象，这个对象里面有一个字段是集合，我要拿这个对象里的集合里的值判断做处理，那不用2层for，怎么做，明知道时间复杂度是n的2次方，这不是很纠结了
2018-09-26
 作者回复
两层循环没问题呀 并没有说n的平方阶不好 要具体看情况分析

2018-09-26


姜威

2
为什么要做复杂度分析？我认为有3个关键点
1.掌握复杂度分析方法后，便能在编程中习惯性的考虑代码性能问题，提高编程质量，从而整体提升系统性能，降低系统的开发和维护成本。
2.和性能测试相比，复杂度分析有成本低，效率高，易操作，指导性强的优势。
3.复杂度分析是数据结构和算法之核心，不掌握这个，就没必要研究数据结构和算法啦！😄
2018-09-26

symbol _woo

1
当年数据结构老师要是这么讲，我怎么会听不懂呢？！
2018-09-28

blue

1
性能测试与复杂度分析是相辅相成的，在编码时，复杂度可以对算法的执行与空间的效率有一个基础的概念，而性能测试则是对我们的猜想进行验证，知其然，知其所以然，才能帮助我们更好的写出最适合当前业务场景下的代码。

-------------------------------------------------------------------------------
笔记
-------------------------------------------------------------------------------

## 为什么需要复杂度分析
- 能够对算法执行的效率有一个概念

## 如何估算算法执行效率
- 大O复杂度表示法：T(n) = O(f(n))
- T(n)：代码执行时间
- n：数据规模的大小
- f(n)：每行代码执行的次数总和
- O：渐进复杂度：用来分析算法执行效率与数据规模之间的增长关系

- 时间复杂度：代码的执行效率
- 空间复杂度：代码申请的空间

## 如何分析复杂度
- 只记录最大量级，公式中的低阶、常数、系数三部分不会左右增长趋势，可以选择忽略
- 比如
- O(2n+2) => O(n)
- O(2n^2 + 2n + 3) => O(n^2)

- 加法法则：总的时间复杂度就等于量级最大的那段代码的时间复杂度
- 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

## 复杂度量级
- 多项式量级
- 常量阶 O(1)
- 对数阶 O(logn)
- 线性阶 O(n)
- 线性对数阶 O(nlogn)
- 平方阶 O(n^2)
- 立方阶 O(n^3)
- K次方阶 O(n^k)

- 非多项式量级，也称为NP(Non-Deterministic Polynomial，非确定多项式)
- 指数阶 O(2^n)
- 阶乘阶 O(n!)

2018-09-27
 作者回复
总结的很好👍

2018-09-27


陆上行舟

1
说一下个人的一点理解:

事后统计法: 定量分析

1. 需要具体的执行代码，需要具体的软硬件运行环境；
2. 需要具体的测试数据，数据规模大小会影响测试结果；

3. 得到的是这一次在具体的运行环境，具体的测试数据运行所需的时间，得到的是一个具体的时间。(点)


时间复杂度分析: 定性分析

1. 不需要具体执行代码，与运行环境无关；
2. 不需要具体测试数据；
3. 得到的不是程序具体运行时间，而是反映时间随数据规模增加变化的趋势。(线)

从评估结果来看，事后统计法得到的是一个具体的点，而时间复杂度分析得到的是一条线。

两种评估方法是相辅相成的，不是冲突的。

假如，假如说解决某一个具体的问题有两种算法 A 和 B，相应的代码是【代码A】和【代码B】，假如我们对两种算法代码进行时间复杂度分析得到结果:

代码A: O(8n+100)，那就可以说代码A的时间复杂度为 O(n) 

代码B: O(n2+n+5)，那么可以说代码B的时间复杂度为 O(n2)


从时间复杂度角度分析，我们可以定性的得出结论说算法 A 优于算法 B。

但是如果使用事后统计法，假设在同样的运行环境，执行两段代码，由于需要具体的测试数据，相当于知道了具体 n 的值，假如是 n 的值是2，则算法A粗略估算需要 116 个单位时间，算法B需要 11 个单位时间(当然单位时间可能都是不同的)。

我们很有可能得出这一次测试结果是算法B所用时间是少于算法A，只是这一次，只是得出了一个定量的结果。

所以事后统计法有时候我们并不能知道算法 A 和 算法 B 那个性能更优，而通过时间复杂度分析我们可以得出定性结论算法A优于算法B。(当随着数据规模增大的时候算法A运行增加的时间要比算法B少的多。)

如果数据规模是确定的那使用算法A和算法B，随便那个选择熟悉的就行，如果数据规模不确定那在写程序的时候就需要尽可能的考虑时间复杂度选择更优的算法来解决。






2018-09-27
 作者回复
👍 理解的很透彻

2018-09-27


Eric

1
总结：
事后统计法：
1. 测试结果非常依赖测试环境；
2. 测试结果受数据规模的影响很大；

一、时间复杂度：
1. 表示算法的执行时间与数据规模之间的增长关系；
2. 只关注循环执行次数最多的代码；
3. 加法法则：总时间复杂度等于量级最大的那段代码的复杂度；
4. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积；

几种常见的时间复杂度：
1. O(1)：一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万的代码，其时间复杂度也是O(1)；
2. O(logn)、O(nlogn)：在采用大O标记复杂度的时候，可以忽略系数，即O(Cf(n)) = O(f(n));
3. O(m+n)、O(m*n)：在无法事先评估m和n谁的量极大时，原来的加法法则就不正确了，需要将加法法则改为：T1(m) + T2(n) = O(f(m) + f(n))，但是乘法法则继续有效：T1(m) * T2(n) = O(f(m) * f(n))；

二、空间复杂度
1. 表示算法的存储空间与数据规模之间的增长关系；
2. 常见的空间复杂度：O(1)、O(n)、O(logn)；

越高阶复杂度的算法，执行效率越低。常见复杂度从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n²)；
2018-09-27
 作者回复
总结的不错

2018-09-27


THREE

1
1 int cal(int n) {
2 int sum = 0;
3 int i = 1;
4 for (; i <= n; ++i) {
5 sum = sum + i;
6 }
7 return sum;
8 }
弱弱的请问一下，第一行和第七行需不需要各自占用CPU的一个unit_time，对于底层的东西不太懂，还是还是好奇的问一下
2018-09-27
 作者回复
占不占都无所谓 毕竟是常量 对复杂度没影响

2018-09-27


karenaaa

1
最后一个图，O(nlogn)的变化曲线，n小于1时，对应的T(n)应该是小于0的
2018-09-27
 作者回复
同学很认真啊 你说的对 不过我画这张图主要是体现每个量级的增长趋势的不同。不用太在意起点的地方

2018-09-27


爱喝酒的瓶盖

1
重发总结, 欢迎指正交流

事后统计法
1. 测试结果非常依赖测试环境
2. 测试结果受数据规模和有序度的影响较大

时间复杂度
算法的时间复杂度(时间量度) 记作 T(n)=O(f(n)), 它表示随问题规模n的增长, 算法执行时间至多以正比于f(n)的趋势增长, 称作算法的渐进时间复杂度, 简称时间复杂度; 
比如 f(n) = 2n^2+1 表示代码的执行次数, 则时间复杂度 T(n) = O(2n^2+1), 通常我们会忽略低阶、常量、系数, 因为当n很大时, 并不影响增长趋势, 最终写成 T(n) = O(n^2)

时间复杂度分析技巧
* 只关注循环执行次数最多的一段代码
* 加法法则, 总复杂度等于量级最大的那段代码的复杂度
* 乘法法则, 嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
空间复杂度
与时间复杂度类似的分析方法
2018-09-27
 作者回复
总结的正确

2018-09-27


祸祸和懒懒

1
感觉自己看一遍之后虽然差不多理解了，但还是不够透彻，明天早上再看一遍争取吃透 👀。看了一圈评论，感觉大神很多，现在我是发表不出那样的感想啦😔，我的 收货很多啦。 老师讲的也很棒👏 ，坚持下去，希望有一天我也会变成像老师那样厉害的人！
2018-09-26

小锅

1
有必要，测试过程也要讲究粗调和精调。
1、粗调：可以根据运用场景，利用时间、空间复杂度分析来筛选使用的主要方法
2、精调：利用性能测试给出较准确的事后分析数据以确认最终的方案
结合起来可以有清晰的优化路径，也能提高很多效率。
2018-09-26

sarahsnow

1
清晰易懂
看完脑海里冒出的第一个问号是:时间复杂度和空间复杂度如何平衡？
不过对于目前近乎无限的云存储空间，也许空间复杂度都不是个事
2018-09-26

路人乙

1
我也立个Flag
1.弄明白:是什么？为什么？怎么做？ 
优点？ 缺点？ 有没有更好？
2.练习，实践，总结
3.坚持，坚持，再坚持!
2018-09-26
 作者回复
👍

2018-09-26


molybdenum

1
分析这些很有必要，作为学生党从多个方面可以深刻感受到
1.在实习面试的时候这些都是作为基础知识被问到的
2.自己刷算法题的时候超时，超限这也很常见，如果不会分析，很难优化代码
3.考研数据结构如果接触过的同学会发现，它会考你运用，设计一些数据问你运算后的结果，分布，另一种就是考复杂度分析，其实会分析了，这个算法自然就会了
那为什么这种东西总是被忽略呢，我想可能有这样一些原因
1.大家都是调包师有现成的，基本不自己写，完成业务第一
2.多用框架开发，小优化对整个系统的运行效果没有明显改善，所以一般不考虑，而且业务多为增删改查，提交数据库还会自动优化一层，所以考虑很少。
总的来说，这还是很有必要的首先注重分析能让代码更加优雅，其次我们说，人要向前看，浅层的业务搬砖也要有梦想，要成为架构师这个坎一定要跨
2018-09-26
 作者回复
说的很好👍

2018-09-26


炫焰苍龙

1
int cal(int n){
}这里看不懂?这是一个什么语句，正则表达式吗？还是说是while语句?unit_time 是每行普通代码所执行的时间吗？T(n)=O(f(n)) f(n)代表每次执行代码次数的总和。然后第一例f(n)等于2n+2..
说实话看着有点吃力，这里要用到的学习技巧是多问多思考，多互动。还有沉淀，，因为感觉自己看了一遍，有点看不懂。。至于边学边练的话，我看不懂代码属于那种类型，因为我还只是刚学Java的萌新。。。这里还需要定义个打怪升级的目标，要坚持下去啊。。我以后吃饭就靠这个了。。目标，每次作者发文章，我一定要带着脑子看一遍或者两遍然后将自己内心想说的东西吐槽出来。。
2018-09-26
 作者回复
哈哈 那不是一个函数吗？怎么会是正则表达式呢 把java搞熟练点 看看是不是更容易看懂些吧

2018-09-26


双木公子

1
复杂度的讲法很接地气，但算法导论上讲的更全更严谨(从数学的角度)，希望老师能讲得更深入一些
2018-09-26

觅食

1
果然浅显易懂，读两遍已烂熟于心。美滋滋。
2018-09-26

大顺子

1
关于第二个 for 循环嵌套例子，我是这样理解的，首先 i <= n 和 j =1,其时间复杂度是2n,里面的 for 循环是 n + n，即2n ,乘以外面的循环就是 2 *n^2, 即最后加起来 T(n) = (2n^2+2n+3)*unit_time
2018-09-26
 作者回复
理解的没问题

2018-09-26


杯中酒醉人心

1
概述：
数据结构和算法解决代码的“快”“省”，而时间、空间复杂度做为数据结构和算法的精髓，很直观说明了代码”多快“”多省“。
因为测试环境的不稳定因素（如同样的代码，i7比i3快得多），测试规模对测试结果影响很大（有些算法更适用于大规模数据），所以需要复杂度分析。
所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比 T(n) = O(f（n）)
大 O 时间复杂度并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，也叫作渐进时间复杂度，简称时间复杂度
时间复杂度分析
1.只看执行次数最多的一段代码 2.加法法则：总复杂度等于量级最大的那段代码的复杂度 3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
常见的时间复杂度：O(1)、O(logn)、O(nlogn)、O(m+n)、O(m*n)
空间复杂度分析
空间复杂度的全称是渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系
常见的时间复杂度：O(1)、O(n)、O(n2 )
越高阶复杂度的算法，执行效率越低

思考：性能测试时环境不稳定，规模易变，而分析时间复杂度，空间复杂度，效率快，高效、易操作、还能降低开发、维护成本，从根源上解决效率问题；
2018-09-26

aes alienum

1
1、「其中，非多项式量级只有两个：O(2n) 和 O(n!)。」 对数也算多项式量级吗？

2、「我们把时间复杂度为非多项式量级的算法问题叫作NP（Non-Deterministic Polynomial，非确定多项式）问题。」 为什么把非多项式量级的问题称为 非确定-的-多项式问题呢，这样不是变成多项式了吗？
2018-09-26

屈超

1
重点知识提炼
事后统计法的缺点：
1.测试结果非常依赖测试环境
2.测试结果受数据规模的影响很大

大O复杂度表示法（渐进时间复杂度）：T(n) = O(f(n))
代码的执行时间与代码每行的总的执行次数成正比，表示代码执行时间随数据规模增长的变化趋势

方法：
1.只关注循环执行次数最多的一段代码
2.总的时间复杂度就等于量级最大的那段代码的时间复杂度
3.嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

复杂度量级分为：
1.多项式量级：
O(1)、O(logn)、O(n)、O(nlogn)、O(n^2)/O(n^k)
2.非多项式量级(非确定多项式NP，表示非常低效的算法)：O(2^n)、O(n!) 

空间复杂度（渐进空间复杂度）：
表示存储空间随数据规模增长的变化趋势
2018-09-26
 作者回复
总结的不错👍

2018-09-26


م و

1
看完之后发现还没有把大学学的知识全部交给老师，哈哈。讲的很棒！期待下一篇
2018-09-26

SSS

1
老师，第二个例子中2n的平方不是很理解，按理说应该是n的平方，也就是n*n，如果n =5那么n 的平方是25，2n的平方不就50了？
2018-09-26
 作者回复
第二个例子中有两行代码被执行了n的平方次。所以乘以了2

2018-09-26


挨踢菜鸟

1
老师，第二个例子中，第6.7行为什么是2n平方遍而不是n平方遍呢？
2018-09-26

3.27。

1
性能测试应该是测试总体性能，但是当要去优化时应该分析下每段代码的时间和空间复杂度，才知道哪些代码需要优化
2018-09-26

晨间新闻

1
大学只学过时间复杂度分析，看之前对O（1）和O（n）之间的区别还有些迷惑，现在懂了。第一节还是比较基础，暂时能够理解，也可能是大学学过的缘故。
2018-09-26

小博

1
深夜刷题突然发现更新了，心中窃喜，留言于此，开始算法之旅
2018-09-26

王滨

1
沙发？干货满满啊
2018-09-26

王三三

0
就C语言来说，单行多个三目运算，是否优于多个if判断？
2018-10-03

Air

0
只会js的前端小菜一枚，这些代码勉强能看懂，老师讲的很明白，就是觉得音频语速略快，特别是用代码讲复杂度的时候，老是跟不上音频的速度来看代码和理解，希望老师这些部分稍慢些~
2018-10-03

雨中漫步

0
时间复杂度，是代码执行效率随着数据增加的变化趋势，感觉理解这一点特别重要
2018-10-02

~记得微笑∩﹏∩

0
不是浪费时间，做完项目后进行性能测试，如果没有达到预期的要求，需要重新返工，而时间复杂度和空间复杂度的分析可以帮我们减少这种情况
2018-10-02

caohuan

0
应该有必要，如果 资源无限 不考虑成本，是不用 考虑 复杂度分析的，但是现实项目中 往往是 用最低的成本做好更多的事情，虽然 我很少会 评估 时间、空间 复杂度，看过 吴军老师的专栏 说 做工程项目 需要考虑 现实成本的 ，期待 老师和 同学们不同的解释。
2018-10-02

Kds908

0
大学时头疼的课程，现在竟然能慢慢看懂了。我觉得分析复杂度很有必要，这一点和常见的数据库查询几乎差不多，数据库查询，我们除了考虑实现，更重要的是考虑它的执行效率。不同的执行计划很可能是成千上万倍的消耗甚至更多。代码考虑时间空间复杂度也是如此
2018-10-02

　　　　　　　　

0
那些符号表示有点懵啊 怎么才可以加深理解呀
2018-10-02

liangjf

0
时间复杂度的分析是不可缺少的。在码字前对选型技术或实现方法的大概对比，对比的就是效率，实现难度，可维护性。效率问题是针对该业务的数据规模来考虑的，复杂度分析可以先定性的分析哪些数据结构和算法更适用，缩小考虑范围后才代码实现需求和定量分析。
同时，掌握好时间复杂度分析和运用自然，会帮助我们在写代码的时候时刻考虑写的是不是垃圾代码。
综上，时间、空间复杂度分析是不可缺少的
2018-10-02

heliang

0
老师，时间复杂度计算公式中的g(n)应该怎么理解？谢谢
2018-10-02

健卜

0
尝试从QA的角度来分析课后的思考题：
1. 一般来说由QA负责的性能测试，其执行的过程会包括“建模->指标设定->数据准备->测试执行->回收数据->校验数据->计算结果”这一套完整流程，其投入成本，要远大于研发人员直接在代码中展开的性能分析和走查
2. 如果代码中的一个性能缺陷，可以通过代码审查的方式发现并修复。那么相比QA在性能测试中“发现->研发修复->再次重复验证”的过程，能非常有效地节省双方的工作量投入

虽然一些重要模块的性能测试，现在已经能通过“持续集成+自动化”的方式来完成，人工投入比重越来越小，但对于QA而言，我们仍然是非常建议研发人员在编码过程中能更多关注代码性能的。

本节课程对测试工作也有更多启发：
1. 可以从代码审计的角度触发，结合成熟框架，对研发代码的复杂度展开分析，从而更早的发现性能隐患
2. 可以考虑将一系列常用的性能测试方案服务化，当开发完成一个代码块的编码之后，就能方便的调用服务完成性能测试，让研发能够更加全面的展开性能评估。

2018-10-01

张文俊

0
所谓磨刀不误砍柴工，如果说我们本身在写代码的时候，具有良好的算法思维，或者算法意识，那么我们的代码是经得起测试的，所以说，我们在对代码进行复杂度分析的时候，是一种事半功倍的做法，不能把所有的宝都压到性能测试上。
2018-10-01

Mr.Robot

0
总结
一.复杂度分析：脱离现实的限制，通过计算输入规模n与执行的语句数量T的关系来推断算法的执行效率，也就是所谓的函数T(n)！例如，T(n)=3n+3，同时也可以表示成T(n)=O(n)，其中O(n)表示数量级为n的多项式族。易知，n+1,2n+3等这些多项式也可以表示成O(n)，因为它们的图形具有相似的特征！
二.性能分析：通过一定手段统计程序(算法的实现)的执行时间，这个时间受到很多因素影响，例如计算机的硬件，输入规模和系统环境等因素！
三.两者的比较：
1.在分析算法好坏方面，复杂度分析更加客观地衡量了一个算法的效率，忽略掉其他因素的影响；性能分析需要考虑很多客观因素的影响，如果需要得到不同算法很明显的性能差别则需要模拟足够大的输入规模，而且得到的结果不一定准确。
2.在时间管理方面，复杂度分析发生在编码前，能够分析出采用的最优算法，从分析到实现一步走完，从而时间成本相对较低；性能分析发生在编码后，如果一开始的算法就不是最优，最后可能需要反复重新编码从而选出最优实现，浪费了很多时间。所以，性能分析通常用在算法实现后统计执行时间，用来印证一开始的复杂度分析！
2018-10-01

曾经瘦过

0
还是需要的，复杂度分析是不依托于平台的。对自己的代码进行复杂度分析可以使自己写出更好的代码，同时对自己的代码质量心里有数 顺便想要问下，我也自学过算法，那些思想也都懂，但是明白思想却写不出书本中的代码 应该怎样吧思想转化为代码呢
2018-10-01

目人可分😁

0
时间和空间复杂度，我可以类比为古代的各派武功，怎么样评判它们的优劣呢，必须要有事实上的标准，那么在时间来看，就是天下武功为快不破，直白说就是速度快效率高的范畴了，空间复杂度犹如武功的阵法，并不是人多或者少就能简单判定好坏，其中还是要结合问题规模去审视， 

课后问题，我看同志们答的都非常好，不外乎是一种悲观的的决策，凡事都要有一种整体的把握感。谁都不敢空口说好与坏，其实从另外一个角度讲，我认为高级人员写的代码有着一定的普适性了，在代码逻辑的实现上，都会考虑并且实现了在复杂度上有很大效率的代码，当然这是建立在团队的高度配合度和负责的态度，总体讲为了项目的稳定性，健壮性都会进行复杂度的再分析，毕竟谁都不希望项目失败
2018-10-01
 作者回复
👍

2018-10-01


清风慕白云

0
关于常量阶O(1)和线性阶O(n)的本质差别，看文中的定义，n是数据的规模，是否可以直观地理解为关于代码运行次数的变量？
O(1)表示只要语句块的代码执行次数是一个已知的常量，无论语句块的构成，复杂度应该都是常量阶
；而如果代码的执行次数是一个一元一次的表达式，那代码的复杂度就是O(n)线性阶
2018-10-01
 作者回复
可以这么理解

2018-10-01


🐱您的好友William🐱

0
最后肯定是要跑一下来看看和估算的有多少差距。。。我自己写的代码matlab和python跑出来速度都不咋一样呢。。。还有可能调用的包合不合适的问题，嘿嘿
2018-10-01
 作者回复
嗯嗯 性能测试还是有必要的

2018-10-01


devilyaos

0
其实复杂度是评价代码性能和质量的一个标准，比如俩程序员的同一段逻辑怎么相互比较性能优劣？总不能都写好上服务器跑一下吧？
2018-10-01
 作者回复
哈哈 这个也是可以的

2018-10-01


Shanksiscool

0
Q1：“从 CPU 的角度来看，每一行都执行着类似的操作：读数据－运算－写数据。”，问“运算”是指I/O运算吗，还是包括它及其它的运算？
Q2：标红的这段话“所有代码的执行时间T(n)与每行代码的执行次数n成正比”的理解是？
大伙和老师帮忙看下对不对：
每行代码可以执行1次，也可以嵌入一个循环，这行代码就执行n次了，也可以多次嵌入循环，这行代码执行n^2 次了。所以T(n)与可以与n成正比，n^2 、n^3 、... 、n^20等成正比。有点类似n可以是n^2 or n^m or n!

Tips：各位伙伴们，Big O的书写，最好还是用大写的O来表示，输入的时候，要留意哦！
2018-10-01
 作者回复
1. 不包括，IO很耗时，要单独来看了
2. 我表述都有点不准确，应该是正相关，不是正比，你理解没错！

2018-10-01


龙恨

0
课后笔记：
1、影响程序执行效率的两个指标：渐进时间复杂度和渐进空间复杂度
2、事后统计法的缺陷：依赖执行环境、受数据规模的影响。
3、分析时间复杂度的方法：关注循环次数最多的指令、加法法则、乘法法则、多个规模求加法
4、非多项式量级的算法问题NP是非常低效的算法，有O(2n) 和 O(n!)。
5、渐进空间复杂度：表示算法存储空间与数据规模之间的增长关系。
6、时间复杂度排序：O(1)<O(logn)<O(n)<O(nlogn)<O(n2 )
2018-10-01
 作者回复
👍

2018-10-01


Mr.钧👻

0
渐进式时间复杂度，空间复杂度分析，和性能测试并不冲突，而是相辅相成的。
复杂度分析，更多的是一种思路，能提高代码质量，提高性能的思路。
2018-10-01
 作者回复
嗯嗯 赞

2018-10-01


最摇摆的鱼

0
能解释一下为什么分成多项式量级和非多项式量级吗？这两个词更具体的隐含特征是什么？查了一下没找到比较清楚的解释。
2018-10-01

小老鼠

0
判断一个代码好坏，从时间复杂度来说是不是仅考虑均滩复杂度即可
2018-10-01
 作者回复
当然不是，这几个复杂度是从不同面来评价的。

2018-10-01


Ceoi Wingsam

0
我觉得是做分析是有必要的 我认为身为程序员最大的成就感在于 能以少的语句描写出更为复杂的情形 在这一点上 我觉得能写出JDK的人真的很了不起 每个语句都如此精简 希望跟着老师学之后 能向他们靠近
2018-10-01

Snail

0
文章中间那段代码:
for (; i < n; ++i) {
ret = ret + f(i);
}
的时间复杂度不是n^2吧？因为随着i的不断增大，f(i)这个函数中的循环并不是每次都是执行n次。求解答
2018-10-01

米粒 曹世丽

0
【极客时间：数据结构与算法之美】
【20180930】
同意老师观点——复杂度分析是整个算法学习的精髓。

【是什么】
$时间复杂度：判断代码执行效率
$空间复杂度：判断代码占用空间

【为什么】
复杂度分析思维的养成更像是珠算里的“心脑算”，这种内化能力的培养是有必要的。熟练掌握后会下意识去判断代码的复杂度，避免写出效率和空间占用不佳的代码，会逐渐的变成一种本能。因为不懂代码，此刻脑中也无法体会代码之美、之优雅如何震撼，想必懂的人感觉是不一样。

【怎么做】学习收获
1⃣️如何估算算法执行效率
大O时间复杂度表示法：T(n) = O(f(n))
T(n)：代码执行时间
n：数据规模大小
f(n)：每行代码执行的次数总和

大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。

2⃣️如何分析时间复杂度
1. 只关注循环执行次数最多的一段代码

我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。

2. 加法法则：总复杂度等于量级最大的那段代码的复杂度

如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n))). 

3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n)).

也就是说，
假设 T1(n) = O(n)，T2(n) = O(n2)，
则 T1(n) * T2(n) = O(n3)。
落实到具体的代码上，我们可以把乘法法则看成是嵌套循环。

3⃣️复杂度量级——多项式量级
常量阶 O(1)
对数阶 O(logn)
线性阶 O(n)
线性对数阶 O(nlogn)
平方阶 O(n^2)
立方阶 O(n^3)
K次方阶 O(n^k)

4⃣️复杂度量级——非多项式量级
也称为NP(Non-Deterministic Polynomial，非确定多项式)
指数阶 O(2^n)
阶乘阶 O(n!)

5⃣️空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。

6⃣️复杂度分析与事后统计法对比：后者非常依赖测试环境、且受数据影响很大（如：数据规模、有序度等）、标准难把控；而复杂度分析可以不利用测试数据，粗略估算代码的执行效率。

7⃣️从没有看过关于算法的书籍，工作中也鲜有涉及，真诚感谢王争老师的授课逻辑，以及留言区同学们的精彩分析。

8⃣️自己还要去回捡一下“换底公式”。
2018-10-01

冯朋举

0
我的总结分析，写在jupyter notebook上，太长了，留言上无法全部写上。

因此，我把它们整理一下，放在我刚建没多久的个人网站上了。
请查看，有任何意见，欢迎批评指教！

1、数据结构与算法学习_01.数据结构与算法_基本概念+学习重点
http://fengpj.top/2018/09/30/01/
2、数据结构与算法学习_02.复杂度分析-上篇
http://fengpj.top/2018/09/30/02/
2018-09-30

冯朋举

0
4. 时间复杂度分析

如何分析一段代码的时间复杂度？

方法1. 只关注循环执行次数最多的一段代码。

大O这种复杂度表示方法只是表示一种变化趋势，通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可；

在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可；

这段核心代码执行次数的 n 的量级，就是整段要分析代码的时间复杂度。

举例说明

1 int cal(int n) {
2 int sum = 0;
3 int i = 1;
4 for (; i <= n; ++i) {
5 sum = sum + i;
6 }
7 return sum;
8 }

其中第 2、3 行代码都是常量级的执行时间，与 n 的大小无关，所以，对于复杂度并没有影响。
循环执行次数最多的是第 4、5 行代码，所以，这块代码要重点分析。
这两行代码被执行了 n 次，所以总的时间复杂度就是 O(n) 。


方法2. 加法法则：总复杂度等于量级最大的那段代码的复杂度。


这个代码分为三部分，分别是求 sum_1、sum_2、sum_3.
分别分析每一部分的时间复杂度，然后把它们放到一块儿，再取一个量级最大的作为整段代码的复杂度。
sum_1 循环了 100 次，这段代码循环执行了 100 次，一个常量的执行时间，跟 n 的规模无关。
注：即便这段代码循环 10000 次、100000 次，只要是一个已知的数，跟 n 无关，照样也是常量级的执行时间。

sum_2 循环了 n 次，记为 O(n) 。
sum_3 循环了 n2 次，记为 O(n2) 。

综合这三段代码的时间复杂度，取其中最大的量级，整段代码的时间复杂度就为 O(n2)。
总的时间复杂度 等于 量级最大的那段代码的时间复杂度。

如果 T1(n) = O(f(n))，T2(n) = O(g(n))，那么 T(n) = T1(n)+T2(n) = max(O(f(n)), O(g(n))) = O(max(f(n), g(n))).



方法3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。


如果 T1(n) = O(f(n))，T2(n) = O(g(n))，那么 T(n) = T1(n)*T2(n) = O(f(n))*O(g(n)) = O(f(n)*g(n)).
假设 T1(n) = O(n)，T2(n) = O(n2)，则 T1(n) * T2(n) = O(n3)。
落实到具体的代码上，把乘法法则看成是嵌套循环。

代码分析：单独看 cal() 函数。假设 f() 只是一个普通的操作，那第 4～6 行的时间复杂度就是，T1(n) = O(n)；
但 f() 函数本身不是一个简单的操作，它的时间复杂度是 T2(n) = O(n)；
所以，整个 cal() 函数的时间复杂度就是，T(n) = T1(n) * T2(n) = O(n*n) = O(n2)。


复杂度分析，关键在于“熟练”。你只要多看案例，多分析，就能做到“无招胜有招”。

2018-09-30

陈志豪

0
课程里面老师举的一个 “一般人” 不用这么做的例子，恰恰是我们大学一开始学编程写的最多的😂
2018-09-30

Marco

0
终于明白怎么算O了！！！
2018-09-30

陈利津

0
讲的很透彻，系统。终于搞明白了时间复杂度，谢谢老师。继续加油。
2018-09-30

Andy_gqjiang

0
关于 O(m+n)与O(m*n)有点不理解，请老师释义：
代码：
int cal(int m,int n) {
int sum1 = 0;
int i = 1;
for (; i<m, ++i) {
sum1 = sum1 + i;
}
int sum2 = 0;
int j = 1;
for (; j<n; ++j) {
for (; j < m; ++j) {
sum2 = sum2 + j;
}
}
return sum1 + sum2;
}

对于上面代码的时间复杂度是 O(m*n) 还是 O(m*n) 还是 O(m+m*n) ？
2018-09-30

韩蓄 Josh

0
我们之所以进行复杂度分析的练习，不是对每个代码都进行分析，而是在大量练习实践之后，在设计代码结构的时候就把复杂度考虑上，实现算法思想的内化
2018-09-30

youngyang

0
代码时间复杂度，空间复杂度是在写代码阶段的一种分析，在写代码阶段就避免一部分在测试时性能不足的问题，也为后来提升性能提前做一个铺垫。我要从现在开始培养这种习惯，深入到编程中，为写出更优秀的代码努力，加油！
2018-09-30

Madfrog

0
我想弱弱问个问题，第一个例子，return那段代码不也是要执行的啊？为什么第一个是2n+2而不是2n+3？
2018-09-30

fine

0
第二个例题起初我也没搞明白为什么是2n^2+2n+3，不是n^2+2n+3？
后来想明白了，原来一直没get到for循环中的自增运算也算在执行次数中，把自增式稍微换下位置可能更容易理解啦。
--------------------------------------
1 int cat(int n) {
2 int sum = 0;
3 int i = 1;
4 int j = 1;
5 for(;i <= n;) {
6 j = 1;
7 i += 1;
8 for(;j <= n;) {
9 sum = sum + i * j;
10 j += 1;
11 }
12 }
13 }
--------------------------------------
2~4行：执行 3 次
5~12行：执行次数为 n 乘以 (6~11)行执行次数，
即执行 n * (1 + 1 + n * 2) 次

所以，总的执行次数应为 2n^2+2n+3 次。
2018-09-30

noob

0
打卡！
2018-09-30

AsuraL

0
课后思考：
性能测试在我理解是建立在实际运行环境上的测试，更多的是为了测试出来当前系统的瓶颈在哪里，从全局考虑，更多的性能优化优先是从项目结构和硬件配合来解决的。作为coder，空间复杂度，时间复杂度检查是为了检查自己所编写的代码在性能上瓶颈范围在哪里？是否可优化，是从代码层次或者说从内部一点点来解决，是个漫长的过程，其次与其他模块或者业务关联后会产生怎样的复杂度提升？是否会产生1+1>2的性能损耗？这也许才是为什么作为开发者者需要自测自检的原因。
2018-09-30

MJ

0
前两天笔试的时候考到这样一种题，写出了以下这种代码，如何去分析它的复杂度呢？从数据结构与算法解决程序执行效率的角度，想问一下有没有别的更好更快的方法来实现？
int num = 1; 
boolean flag = true; 
while(flag){ 
int num2 = 7 * num; 
if(num2 % 2 == 1 && num2 % 3 == 2 && num2 % 4 == 3 && num2 % 5 == 4 
&& num2 % 6 == 5){ 
System.out.println(num2); 
flag = false; 
} 
num++; 
}
2018-09-30

春水碧于天

0
"这里我要再强调一下，即便这段代码循环 10000 次、100000 次，只要是一个已知的数，跟 n 无关，照样也是常量级的执行时间。当 n 无限大的时候，就可以忽略。"

“当n无限大的时候就可以忽略”。老师，我对这段话不是太理解，是不是在表述，尽管n是一个无限大的数，但只要是一个具体的数时，就可以将其忽略？
2018-09-30

大鹏

0
疑问：在编程的时候，根据复杂度分析的思维，考虑进行编程，在实际运行过程中，可能效率没有那么快，此时是不是需要进行程序逻辑上的变动？
2018-09-30

心灵捕手

0
先看上十遍再去总结，这次必须啃下去，加油小伙伴!
2018-09-30

1‰

0
时间复杂度。空间复杂度，都是为了查看代码的性能，代码执行时间久，画面出来缓慢，给用户的体验感就越不好
2018-09-30

探索无止境

0
老师写的真好，每个细节都交代清楚，不会出现中间环节模糊跳过的情况，期待后续文章
2018-09-30

yandex.s

0
我觉得渐进式 时间空间复杂度分析是有必要的，在一个项目上线之前 分析完时间空间复杂度之后 我们可以很清晰的知道 在什么的硬件环境下 和数据量达到什么的水平时候 我们的软件 就达到了瓶颈，能给我们一个参考性的理论基础，只有对你的软件了解的很透彻 那么它的运行状态才能被我们掌控，那么复杂度分析便是我们一个把控对系统要求的基础
2018-09-30

Bolin

0
老师假设一段代码的时间复杂度>空间复杂度，优化后，空间复杂度上升>时间复杂度。这个时候通过是否就应该提升硬件，比如加内存这样。想问下老师，实际情况下时间复杂度和空间复杂度是对于效率是否有一个比例关系。例如效率=时间复杂度*2+空间复杂度*1。还请老师帮忙解答下
2018-09-30
 作者回复
时间 空间复杂度 一个评价的是执行时间 一个评价的空间占用 没有直接的关系的 也不存在比较

2018-09-30


Nirvanaliu

0
文章结构:
1．复杂度：时间+空间复杂度分析，复杂度分析是整个算法的精髓，千万不要忽视
2．为什么需要复杂度分析
1）测试结果依赖测试环境
2）测试结果受数据规模影响较大
3．大O复杂度表示法
引入求1.2.3.4…n的累加和。估算代码的执行时间：（2n+2）* unit_time
引入嵌套循环代码: 估算代码的执行时间: (3+2n+2n^2) * unit_time
得出:所有代码的执行时间T（n）与每行代码的执行次数n成正比
T(n) = O(f(n))
大O时间复杂度表示法，表示的是代码执行时间随数据规模增长的变化趋势，所以也叫做渐进时间复杂度。
4．时间复杂度分析三种方法
1）只管柱循环执行次数最多的一段代码
2）加法法则:总复杂度等于量级最大的那段代码复杂度
I．代码中只要涉及循环，虽然次数是10000次、100000次，只要是一个已知数，就与n无关，因为时间复杂度表示法，是代码执行时间随数据规模增长的变化趋势。
II．T1(n) =O(f(n)) T2(n) = O(g(n)) 那么 T(n) = T1(n)+T2(n) = max(O(f(n))，O(g(n))) = O(max(f(n),g(n)))
3) 乘法法则:嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
5. 几种常见时间复杂度分析实例
1）O(1) → O(logn) → O(n) → O(nlogn) → O(n^k) → O(2^n) → O(n^k) →O(n!)
复杂度量级：多项式阶 和 非多项式阶 O(2^n) O(n！) 非多项式阶，不展开讲
2）O(1) 常量级复杂度，只要代码的执行时间不随n的增大而增大，就是常量级复杂度
3）O(logn) O(nlogn)
通过介绍 2^x = n 介绍 得到x = log2 N 所以复杂度为O(log2n)，实际上可以忽略底数，直接记为 O(logn)
原因：对数公式 log3 n = log3 2 * log2 n → O(log3 n) = O(C*log2 n) 所以在对数时间复杂度表示方法里，我们忽略底，统一表示为O（logn）。同理可理解O(nlogn)。
4) O(m+n)、O(m*n)
引入代码中 有两个 m级 n级 的代码进行介绍
6. 空间复杂度
对比时间复杂度。时间复杂度：算法的执行时间与数据规模之间的增长关系。
空间复杂度：算法的存储空间与数据规模之间的增长关系。
2018-09-30

ybw

0
O m+n 那里为什么说m.n的量级不确定？有点理解不了，望举具体事例
2018-09-30
 作者回复
如果理解不了 也不着急 等到讲到字符串匹配那一节我们会讲到

2018-09-30


Mickey

0
所以递归n个i<=n的循环时间复杂度是O(n的n次幂)?
2018-09-29
 作者回复
这个要具体分析啊 没法很笼统的讲哦

2018-09-30


攻城狮

0
我是初学者，上面的代码都能用Python跑吗？
2018-09-29

灰机。

0
争哥，您好，我是个小菜，我有个问题是这样的，快速排序的时间复杂度是O（nlogn），这种如果使用递归，也适用您说的乘法法则么
2018-09-29
 作者回复
不适合 如果非得要套用公式的话 快排的时间复杂度是通过加法法则计算来的。我们在排序那节会讲到。如何计算快排的时间复杂度。到时候你不理解再留言吧

2018-09-30


攻城狮

0
1.数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。
2.因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。
3.分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。
4.复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。
二、为什么要进行复杂度分析？
1.和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。
2.掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。
三、如何进行复杂度分析？
1.大O表示法
1）来源
算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。
2）特点
以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。
2.复杂度分析法则
1）单段代码看高频：比如循环。
2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。
3）嵌套代码求乘积：比如递归、多重循环等
4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。
四、常用的复杂度级别？
多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，
O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）
非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，
O(2^n)（指数阶）、O(n!)（阶乘阶）
五、如何掌握好复杂度分析方法？
复杂度分析关键在于多练，所谓孰能生巧。
2018-09-29

Action

0
第三章
当 n 很大时，你可以把它想象成 10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了，如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以记为：T(n) = O(n)； T(n) = O(n2)。

问题：为什么说2n不影响增长趋势啊，n越大 5、6行的代码不就是执行得越多此次吗？为什么可以忽略
2018-09-29

苏上

0
总结：
一、时间复杂度（又称渐进时间复杂度）
1、 定义：算法的执行时间与数据规模之间的增长关系
2、表示：大 O 表示法 
T(n) = O(f(n)）
所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比
3、三个分析方法：
（1）只关注循环执行次数最多的一段代码
(2) 加法法则：总复杂度等于量级最大的那段代码的复杂度
如果 T1(n)=O(f(n))，T2(n)=O(g(n))
那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n)))
(3) 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
如果 T1(n)=O(f(n))，T2(n)=O(g(n))
那么 T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))
4、常见时间复杂度量级（按数量级递增）
（1） 多项式时间复杂度量级：
常量阶 O(1)
线性阶 O(n)
对数阶 O(logn)
线性对数阶 O(nlogn)
平方阶 O(n2 )、立方阶O(n3 )......K次方阶O(nK )
（2）非多项式时间复杂度量级：
O(2n) 
O(n!)
（3）几种常见多项式时间复杂度：
O(1)
O(logn)、O(nlogn)
O(m+n)、O(m*n)（m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n谁的量级大）
二、空间复杂度（又称渐进空间复杂度）
1、 定义：表示算法的存储空间与数据规模之间的增长关系。
2、常见的空间复杂度就是 O(1)、O(n)、O(n2 )

PS:在实际项目开发时，常会忽略算法复杂度分析，或许因为电脑配置高，又或许因为性能要求不高，或许因为开发时间赶。如果要成为合格程序员，就必须要求自己，扎实基本功。不积跬步,无以至千里。



2018-09-29

小老鼠

0
1, 则 T1(n) * T2(n) = O(n3)。应该为则 T1(n) * T2(n) = O(n2）吧？
2，如何理解时间换空间，空间换时间？
3，如果循环的是一个非结构化数据，如何计算O呢？比如：
i = getTheFirstBlock(v);
while(i ){
play(i);
i = getTheNextBlock(v);
}
v ：视频文件对象
getTheFirstBlock：获得v中的第一个文件块
getTheNextBlock：获得v中的下一个文件块
while(i ):判断i不是结尾文件块
2018-09-29
 作者回复
1.为啥啊
2. 这个后面会讲到 先别急
3.这个硬要分析的话 就是O（n）n表示块的个数

2018-09-30


小老鼠

0
1，则 T1(n) * T2(n) = O(n3)。应该是：则 T1(n) * T2(n) = O(n2)吧？
2，如何理解时间换空间，空间换时间？
3，对于递归算法，如何计算时间复杂度？比如：
f(x){
If (x<=100){
f(x+1)
}
2018-09-29

shibor_

0
多项式和非多项式的概念都忘了...果然毕业太久了，都还给老师了
2018-09-29

代言

0
我去~竟然能看懂，之前担心看不懂的，哈哈，看来是我多虑了，希望后面也能依旧如此！
来个总结：
1、什么是复杂度分析？
复杂度分析分为时间复杂度分析和空间复杂度分析，都用于分析所编写算法代码的执行效率。

2、为什么要进行复杂度分析？
尽管有事后统计法，但是该方法具有很大的局限性，即：测试结果非常依赖测试环境；测试结果受数据规模的影响很大。因此，需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法，该方法就是复杂度分析方法。

3、怎么用复杂度方法进行分析？
（1）大 O 复杂度表示法
T(n) = O( f(n) )
T(n) 表示代码执行的时间，f(n) 表示每行代码执行的次数总和。
大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势。
（2）时间复杂度分析
1) 只关注循环执行次数最多的一段代码
忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级。
2) 加法法则：总复杂度等于量级最大的那段代码的复杂度
总的时间复杂度就等于量级最大的那段代码的时间复杂度。
3) 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
可以把乘法法则看成是嵌套循环。
4) 几种常见时间复杂度
多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。如：O(1)（常量级）、O(logn)、O(nlogn)（对数阶）、O(n)（线性阶）、O(n^k)（k次方阶）
非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。如：O(2^n)（指数阶）、O(n ! )（阶乘阶）
（3）空间复杂度分析
算法的存储空间与数据规模之间的增长关系。
2018-09-29
 作者回复
总结的很用心 赞

2018-09-29


真宰

0
老师，您好，循环的复杂度比价好计算，但是很多算法有迭代实现，同时也有递归实现，递归实现怎么评估算法复杂度呢？~~
2018-09-29
 作者回复
我可以单独再写篇文章讲递归复杂度分析。稍等一段时间

2018-09-29


Quan

0
前面老师讲了，做了性能测试也不一定准确，会有局限性。
至于需不需要每段代码都分析其时间、空间复杂度，我觉得需要。可能前期因为不熟练需要花费的时间多一点，但是熟练后用不了多长时间了，花这点时间上线一段靠谱的代码，值得～
2018-09-29

霸王龙

0
并不是多此一举的，事前分析一下复杂度不光能锻炼我自己的代码水平，对于事后返工的影响也会减少
2018-09-29

小小

0
为啥我公司项目开发结束后，只对性能进行测试，从来没有对时间复杂度和空间复杂度进行分析。另外，老师讲的真的太好了，我竟然都看懂了。
2018-09-29
 作者回复
复杂度分析都是写代码的时候顺便做了 很多时候都是无意识的 就像打字一样 你也不会感觉到a键在哪里 b键在哪里

2018-09-29


Yuki

0
2n2+2n+3正解。因为每次循环都要执行++i和++j,每次循环执行的语句个数×循环次数＝执行时间
2018-09-29

阳仔

0
学习反馈：
# 为什么需要复杂度分析
数据结构与算法解决的问题是**如何让代码执行得更快和更省空间**。
事后统计法可以描述一个算法的效率，但非常有局限性。测试结果受当时的测试环境以及数据规模影响较大。而复杂度分析可以可以对一个算法的执行效率有一个粗略的认识。对自己的编码有指导作用。
# 怎么分析复杂度
大O表示法
大O复杂度是指代码执行的时间或者空间随着数据规模增长的变化趋势。因此它有两个重要的点：
1、数据规模
2、变化趋势
大O复杂度跟这两个因素有关，因为数据规模的增长引起执行时间或者空间的变化趋势。
## 时间复杂度分析方法
1、关注循环次数最多的代码
2、加法法则。有多个循环，则把各个循环的复杂度相加，取复杂度最大的量级
3、乘法法则。嵌套循环、递归等用乘法把各个复杂度相乘。
### 常见的时间复杂度
常量阶O(1)
对数阶O(logn)
线性阶O(n)
线性对数阶(nlogn)
平方阶(logn^2)
立方阶(logn^3)
k次方阶(logn^k)
指数阶(2^n)
阶乘阶(n!)
### 空间复杂度
空间复杂度分析比较简单，表示算法的存储空间随数据规模增长的变化趋势。常见的空间复杂度有：
O(1)、O(n)、O(n^2)
# 平时要注重多训练，才能掌握算法复杂度的分析

2018-09-29
 作者回复
👍

2018-09-29


翰蓝云天

0
常见复杂度量级
多项式量级：O(1)<O(logn)<O(n)<O(nlogn)<O(n^k) 
非多项式量级：O(2^n)<O(n!) ,效率低、不常用

时间复杂度：执行时间与数据规模的增长关系
空间复杂度：占用存储空间与数据规模的增长关系，常见的就是（O(1)/O(n)/O(n^2)）
O(logn):i的取值为等比数列时
O(m+n):有2个数据规模，不能省略其中一个 

请问老师 O(m+n)>O(m) 一定成立吗
如果确定 n>m， 多项式 2n+3m 的复杂度 O(m+n) 可否转换为 O(n)
2018-09-29
 作者回复
1. 这个成立的前提是针对同一个问题，不同的算法，一个是O(m+n)，一个是O(m)，这个时候成立。否则就么有比较的意义。
2. 可以的

2018-09-29


🌟 我係冬阳 🐑

0
这个思考题，答案肯定是要进行分析啦，肯定有必要啦。就好像造一个房子，地基都不打好就往上盖，盖完之后再分析。如果房子不会倒还好，如果分析后发现很快就倒，或者几年就倒，那难道要重新炸了房子，再建吗。类比过来代码就是，你要解决一个问题的时候，想到办法就去实现代码了，且不说能不能实现吧，实现出来就未必是最好的方案。等你实现了，再去分析复杂度或者直接运行来测试，发现问题再改成本就好大了。事先分析，可以帮助我们快速判断这个算法的性能，以及可以做估算，根据实际业务来判断这个算法的数据规模会达到何种量级，再结合时间空间复杂度就能大致判断出这个算法的性能优劣了。判断完后再去实现，性能差就再去思考能否优化。
2018-09-29

🌟 我係冬阳 🐑

0
你好，因为这个课程是听，看结合的课。跟传统的视频教程不太一样。能否在每段文字阅读的段落前，加上录音的时间戳。这样方便读者定位语音和阅读内容，也方便事后复习再听的时候，能快速精准定位
2018-09-29
 作者回复
哈哈 我们记下来了 建议很好

2018-09-29


星辰

0
分析时间空间复杂度有助于自己写出优质代码，而不是渣渣
2018-09-29

Yezhiwei

0
看来是时候补补数学，好尴尬😳
2018-09-29

Geek_f98956

0
测试的时候的数据 不一定 是合适的数据 导致结果不够客观 而我们做开发 必须考虑到最坏的情况 否则用户出问题了 就麻烦了
2018-09-29

三个石头

0
我认为复杂度分析，往往是做在写代码自己调试阶段的工作，而项目测试之类的主要是指代码通过公司测试人员测试之后才会去做的工作，就是二者阶段不一样
2018-09-29

Terence

0
第一个代码片段，文中的结论是“第4、5行运行了n次”。

但实际应该是，第4行运行了n+1次，第5行运行了n次。

当初看《算法导论》，这个细节印象特别深刻。
2018-09-29

付剑津

0
不是多此一举。性能测试和所使用的机器，原始数据的有序程度都有很大的关系。
将复杂度分析联系熟练后，并不会花多少时间，而且这种内化的能力能够直接体现在我们的代码里
2018-09-29

victor

0
用代入法和归纳法求一波
T(n)=if(n>1,(8T(n/2)+cn),1)
复杂度的感觉就来了
2018-09-29

A_阿海

0
理论提前知道代码效率。不用等实际跑起来 测试的时候才发现性能问题，再去优化代码。
2018-09-29

args

0
作为一个工科生为自己丢了好多年的数学汗颜，查多项式概念，换底公式，回想等差等比数列，微分积分还没敢查…
2018-09-29
 作者回复
这个丢的有点多了 不过很快就能补上

2018-09-29


sea

0
复杂度分析更像是提供了一种代码效率的“心算”，如果熟练掌握了对写代码的帮助是巨大的，自己写的时候就能大概知道代码的复杂度，从而避免写出效率和内存占用不佳的代码。
2018-09-28

徐

0
老师， 最后一张图里， O(nlogn)在n等于1的时候应该等于0吧， nlogn跟n的线应该有个交叉点。 

PS：最后的问题，我认为，复杂度分析其实就是定性分析， 性能测试是定量分析。 这两种方式在各行各业各种问题上都有各自的价值和意义。
2018-09-28
 作者回复
大o标记法省略了系数 常数 低阶。所以这张图 你要关注的是增长趋势的不同。至于起点是几不好说 关注也没意义

2018-09-29


王阳

0
我认为两者是相辅相成的，比如针对某个项目要做算法或者数据结构的选型，前期可能是通过时间或空间复杂度的分析，可以从理论上就排除了一些选型，但是最终的确定可能确实需要编写对应的demo,通过实际的测试结果来确定最终的方案
2018-09-28
 作者回复
说的没错

2018-09-29


天方夜谭

0
我怎么没听明白😂😂
2018-09-28
 作者回复
那就多看几遍吧 自己动脑子多思考一下。再结合其他书籍资料 看看。还有可以网上多搜搜。既然基础比比人差 就要多下点功夫了 同学。毕竟这门课确实不简单。我这里也没葵花宝典 还是要自己下苦工夫的呢

2018-09-29


绪扬IS未知数

0
我遇到一个百思不得姐的问题：将n个不定长度的数组转换成一个有序的数组，使用两种方式，分别实现空间复杂度和时间复杂度最低。
在回答这个问题的时候，我无论怎么试时间复杂度都是O(n∧2)，空间复杂度都是O(n)。请老师讲解一下这道题，具体如何分析。谢谢！
2018-09-28
 作者回复
后面讲完排序你再看看能不能回答上来吧

2018-09-29


SHANE

0
其实关于理解这个每行代码都要去斟酌其性能这种问题，大家可能觉得似乎特别耗时间。但我理解是这样的。这就像写字一样，若开始小的时候，我们把字都写工整了，好好的花了大力气大时间把它练好了，那我们未来在写字的时候就是写的又快又好。真正的顶尖的优秀的程序员，他们其实写代码的时候，就是写得又快又好。他们的直觉已经考虑到了一些性能的问题。他们的习惯不允许他们写出劣质的代码。所以我们还是好好的打好基础，好好的把字练好。有句俗话说，从一个人写字就能看出一个人的为人，我现在来思考还是有几分道理的，如果这个人很踏实很用心，沉得住心，那么他的字应该是练得好的。同样的，我们也可以用一个人的代码的质量来判断一个程序员的品质。如果是一个有耐心，有责任心，有沉得住心的程序员，他肯定是能把他的代码写好。
2018-09-28

SHANE

0
我在面试程序员的时候，我会进行深度和广度的挖掘，我会引导面试者一层一层的往深度的回答问题。他回答到哪个层次，我就认为这个程序员的基础在什么层次。一般来说，如果一个程序员的深度比较深，那广度应该一般不会太差。很多东西都是触类旁通的。
2018-09-28

SHANE

0
据说微软，谷歌等顶级公司对程序员的基本功的要求是最顶级的要求。只有基本功越扎实的程序员，才能写出世界上最优秀的产品，我觉得我们需要对我们的软件知识进入更深度的挖掘是有必要的。
2018-09-28

SHANE

0
我认为是有必要的，因为软件代码这些东西很奇妙。性能越高的软件，也许用的人会更多。比如操作系统或是搜索服务。你的用户可能是上千万，上亿几十亿人。所以你的代码每一部分如果都能优化出那么一点点时间，这个加起来这么多人会节省多少时间？所以我们对代码都要无止境的去打磨。他会带给你应有的回报的。
2018-09-28

PerWchs

0
在计算时间复杂度时，忽略公式中的常量和低阶尚可理解，把系数也忽略掉不是太能理解。举个例子，O(2n)，若n=10亿，那么系数对最后结果影响还是很大的。
2018-09-28

上发条

0
++i好评⊙▽⊙
2018-09-28

勤劳的小胖子-libo

0
立个FLAG,每周完成更新的内容。加油~
2018-09-28

pc

0
大O表示法实际上是表示随着数据规模扩大所耗费时间的增长率，因此和性能测试的时间应该是两回事。通过时间复杂度分析，可以在一定程度上了解到代码的“好坏”，因为在实际环境中往往数据的规模是未知的，因此时间复杂度低的算法，大概率是在各种数据规模中表现的更好的算法；性能测试则可以让我们了解到代码在实际环境的具体时长，从而可以进行进一步优化。
2018-09-28

王虹凯

0
我经历的开发过程，真的没有专门分析复杂度。压测，一般也是针对qps高的功能会做，一般会做些代码review和缓存策略，很少深入到复杂度分析的细节上，我想这也是大部分业务为重头的团队的通病吧，如果是技术出身或者中间件团队，我认为可以好好玩一玩，只有好处不会有坏处。较真的时候，确实有用。
2018-09-28

朱月俊

0
性能也和机器本身的性能有关，做完性能测试，再做时间复杂度和空间复杂度分析，能够从理论到实践对一个模块有一个认识，这个是必须的。
2018-09-28

油条

0
性能的影响是多方面因素的。进行复杂度分析能在一定程度上优化代码的执行效率，从而在一定程度上有意识的写出更加优化的代码，也会让自己在写代码的时候养成一种注重代码执行效率的好习惯。
2018-09-28

Mr.Lee

0
1.复杂度是用来分析算法的执行效率与数据规模之间的关系。
数据结构和算法解决的是让代码执行的更快，更节省内存
2.复杂度分为时间复杂度和空间复杂度
时间复杂度指的是算法的运行时间随着代码的规模增长的变化趋势
空间复杂度指的是算法所占用的内存随着代码规模增长的变化趋势
大O表示法；
表示的是代码执行的时间随着代码规模增长的变化趋势
3.公式中的低阶，常量，系数不影响增长趋势，可以忽略。
分析时间复杂度的方法：
_1.只关注循环执行次数最多的一段代码
_2.加法法则:总的复杂度就等于量级最大的那段代码的复杂度
_3.乘法法则：嵌套代码的复杂度就等于嵌套内外代码复杂度的乘积
4.几种常见复杂度分析的量级：
多项式量级 非多项式量级
常量阶 O（1） 指数阶 O（2n）
线性阶 O（n） 阶乘阶 O（N！）
对数阶 O（logN） 
线性对数阶 O（NlogN）
平方阶 O（N2）
立方阶 O（N3）
K方阶 O（Nk）
5.非多项式量级代码执行的时间会随着代码的规模增长急剧增长，是非常低效的算法，在此不讨论。
6.只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂都记作O（1）
还有一种情况是无法看出来两段代码的谁的量级比较大时，就不能采用加法法则，省略其中一个。此时使用0（m+n）来表示此段代码的时间复杂度，而乘法法则依然有效。
7.常用的算法复杂度有O（1），O（n），O（N2），
越高阶的复杂度其效率越低，常见的算法复杂度从低阶到高阶，O（1），O（logN）， O（n），O（NlogN），O（N2）
8.作业：正如作者所说的那样，对代码做的性能测试会受到本地环境的影响，其测出来的结果并不准确。做时间，空间复杂度分析并不会依赖于测试环境，
相反，得到的结果会更精确一些。另外，做复杂度的分析固然消耗时间，可也是我们对复杂度的一个练习的过程，所谓孰能生巧，巧能生精。
久而久之，也能提高我们对复杂度分析的效率。同时也能让我们在平时敲代码时潜意识的考虑到复杂度。更能提升自己。
9.课后疑虑:n表示的是代码的规模，这里有个疑问就是当n为10000,100000，无限大时为啥就忽略了？
按照我的理解就是代码执行的时间随着规模增长而增长，难道我的理解是错误的吗？
关于O我可以把它理解为数学中方程上的一个系数吗？希望老师看到后解答一下，谢谢。





2018-09-28

等风来

0
老师,复杂度O(2n) 和 O(n!)的算法有哪些?
2018-09-28

Terry

0
理论指导实践，实践验证真理。不能说是多此一举。
2018-09-28

coulson

0
先把高中时候学的对数和阶乘相关知识温习一遍，都快忘记完了！头疼
2018-09-28

可可西里王炸

0
一、时间复杂度
1.时间复杂度：指的是代码执行时间随数据规模增长的变化趋势
2.大O复杂度表示法：T(n) = O(f(n)) 其实T(n)代码执行的时间，n表示数据规模大小，f(n)表示每行代码执行的次数总和
3.时间复杂度分析：
(1)只关注循环执行次数最多的一段代码
(2)加法法则：总负责度等于 量级最大 的那段代码的复杂度，常量级的执行时间当n无限大的时候就可以忽略 但如果无法估计谁的量级大，则都需要加起来
(3)乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的 乘积
4.复杂度量级： 常量级O(1) 指数阶O(2的n次方) 阶成阶O(n!) 对数阶O(logn) 线性阶O(n) 线性对数阶O(nlogn) 平方阶O(n*n) 立方阶O(n*n*n) k次方阶O(n)
二、空间复杂度
1. 概念：算法的存储空间与数据规模之间的增长关系
2. 常见的空间复杂度：O(1) O(n) O(n的平方) 像O(logn) O(nlogn)这样的对数阶复杂度平时都用不到
2018-09-28

日月星

0
老师，那递归死循环是时间复杂度太大导致cpu爆了而不是空间复杂度导致内存炸了么？还是两者复杂度引起的？
2018-09-28
 作者回复
堆栈爆掉了 递归那节会讲的

2018-09-28


细水长流

0
课后思考：这个问题应该根据项目目标区别对待。如果是商业级项目，提供稳定高性能的服务，那么这些测试都是必须的；但如果是一个Demo项目，必须快速实现用来验证设想的，就可以考虑放宽性能要求了
2018-09-28

syzhou

0
老师你好，有一个疑问，你文章里说O(nlogn)是基于乘法法则循环执行O(logn)的代码n次得来的，但是归并排序从形式上来说更像用加法法则的示例，如果用加法法则就是:
O(logn)+O(logn)+O(n)=2O(logn)+O(n)=O(n)
//两个2分的递归加一个合并
但是归并排序的时间复杂度确实O(nlogn),不细究这个算法的原理，单从代码上来分析，我用的加法法则为什么是错的？
2018-09-28

张辽

0
性能测试有局限，尤其是数据规模，很难说明复杂度，而且一定规模下的测试数据样本量有限，比较个例，不能说明普遍性能指标。
2018-09-28

学无止境

0
老师讲的系统性好，结构清楚，分类真是个好方法。
2018-09-28

New Yorker

0
总结一下
1.复杂度表示一种渐趋势，所以可以做以下分析方法
寻找循环最里层的循环
针对加法，可使用最大的复杂度
针对乘法，使用嵌套相乘
2.复杂度量级多项式量级，非多项式量级
3.最好的练习方法是不断分析，最终达到五招胜有招
2018-09-28

我想静静

0
对于复杂度分析：在写代码的时候分析一下时间空间复杂度，总好过出现问题再去修改代码甚至重构来的爽。君不见，多少公司的程序猿都是被前人乱七八糟的代码逼走的；或者直接重构，浪费大量的人力物力财力。
对于性能测试：不管怎样，分析只是一种理论上的操作，是一种理想情况的推论。像物理实验一样，很多物理定律的前提都是理想情况下，并不会实际发生的（可能这个例子不是很恰当）。还是要落实到自己的机器上进行性能测试，毕竟环境不一样，不同的硬件配置，也许出现的结果就不太一样，需要优化的点也不一样。
2018-09-28

周游

0
公式中的O，表示代码的执行时间T(n)与f(n)表达式成正比。这个说法略不严格。 Algorithm（4th Edition）课程中认为把大O作为approximate model是common mistake。 （他认为大theta才是asymptotic growth rate，而在课程中更多使用波浪记号：~）

继续看留言中！耶。
2018-09-28

尘墨

0
问题1：
python实现,没有i=1的赋值是不是会少一个unit_time啊：
def cal(n):
_sum = 0 # 1个unit_time
for i in range(n): # 2n*unit_time,还有加法计算的时间没有算
_sum = _sum + i
return _sum
问题2：
_sum = _sum + i 换成 _sum += i 是不是少了个赋值操作

基础不是很扎实，所以问题比较多
2018-09-28

Ricky

0
我觉得复杂度分析确实能够提供一个理论的潜在的程序运行结果，项目开发前进行性能测试能够帮助分析实际情况下不同数据规模和数据特点在不同平台的性能差异，从而有助于选择比较合适的平台，之后再进行复杂度分析则可以优化程序结构，提供程序运行效率，此外考虑到不同平台对系统输入的情侣，其实也会考虑时间复杂度和空间复杂度二者对系统的影响程度，如果系统的实时性比较高，那么可能会采用牺牲空间复杂度来提升时间复杂度……
2018-09-28

SHANE

0
我觉得复杂度有一个可以量化的标准 就是机器执行了多少代码 当我们遇到 for while等关键字 或者列表 map等 就要思考 机器走的代码不止眼前看到的这些
2018-09-28

快乐E调

0
有个疑问，既然赋值都算单位时间，循环里面的i++，j++为什么都不算单位时间
2018-09-28
 作者回复
也可以算 算不算都不影响复杂度

2018-09-28


Flying

0
个人理解，学习数据结构与算法，就是避免写出“烂代码”，复杂度分析可以让我们在编写程序之前，对整个系统或者函数的效率有一定的了解。最近在学习Python，深有体会。Python估计是一门运用数据结构较完美的语言了（c c++ Python对比），比如它的切片运用，能避免很多不必要的循环操作。还有一个更深刻的了解是:网盘对数据结构要求更高，因为这个决定了你如何能充分利用你的服务器存储。
复杂度分析和性能分析各有优缺点，都只是工具，熟练掌握它们，提升你的代码质量。
如有错误，欢迎指正。
2018-09-28
 作者回复
👍 理解的不错

2018-09-28


段磊

0
事后统计法有非常大的局限性 1.测试结果非常依赖测试环境，2.测试结果受数据规模的影响很大。
所以，我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法，这就是时间、空间复杂度分析方法。
越高阶复杂度的算法，执行效率越低。
2018-09-28

喵大大~

0
这种计算时间复杂度的方法，可以计算java的lambda流处理么，比如说list.stream().filter(s->s>10).collect(Collectors.toList())，list的大小为n。这是不是就是O(n)。
2018-09-28

kevin

0
作者写的好通俗易懂~只是我有个疑问，假设代码里有调用别人的rpc或者http接口，这样算时间的复杂度应该有误差吧？调用接口的复杂度是怎么算呢？
2018-09-28
 作者回复
实际上 复杂度只能用来做相同问题不用解决算法之间的性能对比。注意这里的相同问题 这个背景。如果这个问题的解决不管什么算法都要调rpc。那我们就可以将rpc调用看作一个固定的时间单位。不过你的问题更接近实战。单纯复杂度分析可能并不能评价代码的性能。还有结合具体情况具体分析

2018-09-28


草长莺飞

0
老师，提个建议呗。就是留言的时候不小心退出了，下次在登录的时候接着写，但是全没了。需要重新写，很烦。体验很不好呢！！
2018-09-28

陈蒙

0
空间复杂度的空间是内存空间吗？
2018-09-28
 作者回复
可以粗略的这么认为

2018-09-28


看着时光渐渐苍老

0
希望能有更多拔高的地方，这些感觉都有些太基础了
2018-09-28

yaxin

0
时间复杂度：渐进时间复杂度，表示用时与数量规模增长的渐进关系
空间复杂度：渐进空间复杂度，表示存储空间与数量规模增长的渐进关系
2018-09-28

小白一只

0
总的来说会用时间与空间复杂度来分析问题对我这种渣渣程序员有两种好处，一是写代码的时候就不会写出效率很低的代码，二是分析别人的代码的时候容易找出拖累执行效率的代码。。。
2018-09-28

Slow life

0
通俗易懂，大学的数据结构的基础理论，期待后续精彩的时空复杂度分析
2018-09-28

确认过眼神

0
性能测试会与代码所属环境有关，复杂度分析只与代码本身有关，可否这么理解？
2018-09-28

铭

0
时间复杂度和空间复杂度事一个理论上的推理值，但是对于算法的优劣有一个比较具体的比较。
2018-09-28

Ye

0
O可以理解成同阶无穷大，其实它本意就是这个
2018-09-28
 作者回复
是的 👍

2018-09-28


落叶🍂建良

0
前端页面布局使用的都是标签语言(html+css)是不是可以认为是O(1)的复杂度呢?
2018-09-28

qpm

0
性能测试和大O分析可以类比成：实践和理论的差异。如文章所说，实践基于理论，但是效果也受限于很多其他的实际条件，大O分析得到的公式，会从理论上解释算法的趋势边界，对测试的结果或者日常设计算法都是由指导意义的，两者并不会冲突。
重新推导了一下指数的一些公式和函数图，理解log(n)部分更加有益：）
2018-09-28

Wayne

0
一直对这个O，不是很理解，我尝试理解了一下！理论上，代码执行总时间=总代码行总运行次数*每次运行时间，而每次运行时间由于与CPU架构和负荷有关，该值无法确定，但可以确定的是每个时间点上都是一个正数常量，引入数学上的大O表示法来描述随着时间推移，代码总时间理论上是总代码总运行次数的特定倍数关系，即正比关系！
2018-09-28

Xuewen

0
写的字很漂亮呀…图也画的很好，有心啦。^_^
2018-09-28

SHANE

0
老师请教您一个问题 之前面试一家公司，他问我 微信抢红包的算法是怎么实现的？怎么去规避一些陷阱。 比如总额100块钱，第一个人是不是就可以100块钱的基数来抢 那他获得更多钱的概率就更大。这样是不公平的，在我们的算法设计中，怎么规避这种不公平？这个问题困扰了我好久，烦请老师或在座的各位同学也一起探讨一下。
2018-09-28

崇拜

0
所以最后一段代码的时间复杂度是O(n)，嘻嘻快夸我！
2018-09-27

崇拜

0
所以最后一段代码的时间复杂度是O(n)🤪🤪🤪
2018-09-27

落叶飞逝的恋

0
老师，有这么个题目，若f(n)=O(n^2)且g(n)=O(n)。为什么g(n)不想等O(f(n))。但是O(n^2)却跟O(n^3)相等
2018-09-27

敲键盘的人

0
感觉现在很多算法实现啊都封装成库了 python程序员表示我只是一个代码包调用者
2018-09-27

青柠

0
代码上线之后，做性能测试。我觉得是必须的一个环节，特别是直接面向大量用户的系统。但是在性能不影响使用的环境下，可以不用考虑时间，空间复杂度。除非是在性能测试不合格的情况下，我们再回来做这件事情，如果是代码的问题，再加以改进。每段代码都做时间复杂度分析，很有可能浪费了很多时间在那些不是经常使用的代码上。而且复杂度分析也是我们估算代码执行的时间，真正的执行时间还要考虑很多因素。
2018-09-27
 作者回复
有道理！

2018-09-27


普通的一天

0
写的好好
2018-09-27
 作者回复
多谢认可！

2018-09-27


Kevin

0
以前真没有想过代码时间复杂度
2018-09-27

『LHCY』

0
如果需要对一个长度为n的数组过滤并赋值，第一种方法过滤和赋值一起做，第二种是先过滤出来在遍历一次赋值，分为两个方法来操作数组，时间复杂度二者都一样O(n)，第二种多取一遍值，平均速度肯定会较慢，但是后期改变过滤方法或赋值方法好维护也好复用，这个时候是选择快，还是好维护，还是看这块逻辑是否对性能有够高的要求来决定。
2018-09-27
 作者回复
写的很好👍

2018-09-27


每天学英语的小沈

0
性能测试测出问题来，还是需要时间复杂度、空间复杂度分析来找到问题代码以及问题在哪里，而且，不要把问题留到性能测试，万一性能测试测不出来呢？而且与其写脏代码，等待性能测试有问题再改，为什么不一次性改好呢？查找问题，解决问题更浪费时间，尤其是问题代码不是你写的时候
2018-09-27
 作者回复
👍

2018-09-27


bro.

0
空间复杂度就是给程序分配的空间嘛
2018-09-27

王山而

0
并非多此一举，因为性能测试是很费时间的，有些问题如果通过复杂度分析就能明确的发现有更好的方案，当然会节省很多时间，而且性能测试也未必能够做的足够全面，难免会有遗漏，测试数据也难保证理想。所以估算复杂度是有意义的。
另外代码虽然很多，但是数据增长量级很大的情况其实并不多，是可以抓住重点作分析的，而且加法法则和乘法法则也可在估算的时候使用。
2018-09-27
 作者回复
👍

2018-09-27


feifei

0
老师，关于这个加法法则，我有点不是太理解，以加法法则的示例代码为例，例如当前n为十万，循环2需要执行十万次，循环3则执行十万次的平方次，这样直接以最大的时间复杂度作为整段的时间复杂度，我有点没有太理解，为什么是O(n的平方)，不是O(n的平方+n)?
2018-09-27
 作者回复
你理解的完全没问题啊 唯一有一点要说的就是 在10万的平方面前 10万即便是忽略掉 也没关系 我们复杂度表示法本身就不是精确的执行时间的度量。他只表示一个执行时间随数据规模n变化的趋势。而这个趋势只会被最高阶左右。为了表达上简洁 我们忽略低阶

2018-09-27


insist

0
事后分析法有局限性，不同测试机器的配置以及测试数据规模对测试结果都有很大影响，无法体现算法的普遍规律。渐进式的复杂度分析在熟练之后，也是容易进行操作的，不会占用太多时间就能分析出算法的时间、复杂度。
2018-09-27
 作者回复
是的 熟练之后几乎一眼就能看出来

2018-09-27


Sandy

0
上学时印象最深的就是NP难问题，完全听不懂
2018-09-27

Zherlock

0
刚刚把思考题理解反了，，算时间复杂度肯定好啊，避免一开始就从一个时间消耗角度不可用的算法进行开发
2018-09-27

广进

0
前排总结得都好棒，因为时间关系，看了两天终于看完了，赞。突然有个想法，要是有个群让我们分享各自的理解或者互相答疑会更好。
2018-09-27

Zherlock

0
Emmm,时间复杂度的概念，原本就觉得反常识，为什么常数低阶都可以忽略。后来自己开始编程了才出现一点感觉。
空间复杂度反而看起来更难了。而且这些个数据结构在不同语言里是同一种性质吗？C的列表和python一样吗？
至于用实际程序测时间消耗，我觉得是必不可少的环节，所有实际的系统都要经过这个步骤。
2018-09-27

落叶飞逝的恋

0
老师，文章介绍了算法的上限O，那么需要了解下限吗？
2018-09-27
 作者回复
不需要的 常用的就是大O

2018-09-27


赵阿海

0
讲的很明白，期待下一期。
2018-09-27
 作者回复
多谢认可！

2018-09-27


sunson

0
老师写的很棒！赞
2018-09-27
 作者回复
感谢认可！

2018-09-27


刘浩

0
哈哈，其实这个问题很好回答，性能测试工程师这种职位依旧存在自然说明不可替代。另外理论和实践是两码事，理论是实践的基础，并不能代替实践，退一万步讲，假设性能测试可被复杂度算法代替，但是作为风控的最后一关存在都是意义非凡的。
2018-09-27
 作者回复
理解透彻

2018-09-27


吕宁

0
今天研一开算法课，老师直接讲算法导论，刚讲到复杂度分析就蒙圈了，上出了数学课的感觉。递归式求解复杂度，各种级数求和，证明，主定理等等。看周围同学都很理解的样子，深深怀疑自己的智商。
2018-09-27
 作者回复
算法导论并不适合当教材。建议买本其他书配合着看

2018-09-27


王高兴

0
还要再看几遍
2018-09-27
 作者回复
嗯嗯 网上多搜搜 再看看书

2018-09-27


youngshi

0
大学都学过，一下子全记起来了，自从搞嵌入式就没有涉及这些理论了，全忘了，还好我决定转型，往互联网探索一番。
2018-09-27

Cest la via

0
感觉老师讲的很清晰易懂。对于T(n) = O( f(n) )这个公式我有一些自己的理解，请老师帮我看下我的理解是否有误。谢谢！
1.它的概念是执行时间与每行代码总的执行次数成正比。
2.总的执行次数就相当于执行时间。
3.因为时间复杂度表示执行时间与数据规模之前的关系。所以每个推导出来的大O时间复杂度中都应该包含数据规模n。
2018-09-27
 作者回复
理解的正确👍

2018-09-27


凉爽兄

0
我觉得O(f(n))就是f(n)的同阶无穷大
2018-09-27
 作者回复
哈哈 是的 看来你数学很棒啊

2018-09-27


D

0
log(3,n)=log(2,n)/log(2,3)
2018-09-27
 作者回复
对！

2018-09-27


Reiser

0
即便是测试也会存在测试用例不全的问题，我觉得 TDD 的精髓就在于每次写代码前就考虑到何种意外情况。写出低复杂度的代码应该是一种意识，而不是被动的改变。
想问一下，我总听到：“要不用时间换空间，要不用空间换时间”。时间复杂度和空间复杂度一定是呈反相关的吗？
2018-09-27

凉爽兄

0
想问两个问题
1.对数也不是多项式，为什么被分作多项式量级？
2.做矩阵乘法，不同大小的矩阵运算时间不同，但是反映在代码上都是执行一次(比如用matlab矩阵运算)，能说时间复杂度都是O(1)吗？
2018-09-27

k

0
1 复杂度分析就是衡量数据结构和算法效率的方式之一。
2 分析的效率主要指标就是“多快好省”，多快对应时间复杂度分析，好省对应空间复杂度分析。3 复杂度分析主要反应代码执行时间和占用空间随着数据规模增大的一个趋势。
2018-09-27

落叶飞逝的恋

0
看了资料明白了，O(n^2)=O(n^3)，它们其实不是两边对称，只是O(n^2)属于O(n^3)的子集。所以上面的例子使用加法法则与乘法法则结果都是一样的。
2018-09-27

起而行

0
我感觉性能测试和实际测试是两种标准，两头抓。一种实际一种理论，理论更直接成本低，性能测试更实际但成本高
2018-09-27

弈者

0
性能测试只能反应在一定数据规模下的性能，而且和硬件配置是强相关的，并不能从根本上给出一段代码的执行时间。有些算法在当前数据规模下可以跑得很欢快，一旦当数据规模增长一个数量级后，可能就是cpu满载，内存耗尽等。如果对于数据规模和算法等复杂度有很好的掌握，是可以防患于未然的。
2018-09-27

日月星

0
空间复杂度影响内存是肯定的了，但时间复杂度只是影响cpu么，还是说他们都影响cpu和内存。
2018-09-27
 作者回复
cpu的

2018-09-27


镇嘉

0
老师，我想问一下举例的代码中为什么 for 循环中 i的初始值赋值为什么要放在前面先赋值，而不是放在 for 循环赋值？ 还有就是你举例的那个空间复杂度相关的代码为什么说有点傻，是那个代码可以做改进吗？
2018-09-27
 作者回复
i不放在前面也可以。没区别的
比较傻是因为那段代码纯粹是为了讲复杂度分析编出来的。也没啥好优化的了

2018-09-27


GradleX

0
事后分析法缺点：①依赖测试环境（如不同机器的运行速度不同） ②受数据规模影响（如数据规模小则难以比较） 
大O复杂度表示法：由O()表示算法执行时间/占用空间与数据规模的增长关系（参数忽略低阶/常量/系数的最高阶的执行次数/存储数量）
复杂度分析：低阶/常量/系数不影响增长趋势（增长曲线斜率的变化趋势），都可忽略（以代码中最大复杂度为主）

①时间复杂度
将每行代码的单次执行过程（读数据-运算-写数据）粗略当作时间相同的基本操作则代码执行总时间T(n)与代码执的总次数f(n)成正比（T(n)=Of(n)，O表示T(n)与f(n)成正比）
int cal(int n) {
int sum = 0;
int i = 0;
for (; i <n;i++) {
int j=0;
for(;j<n;j++){
sum = sum + i*j;
}
}
return sum;
}
代码执行总时间：T(n)=(2n^2+2n+2)*unit_time
时间复杂度：O(n^2)

②常见复杂度量级：
多项式量级
常数阶O(1)
线性阶O(n)
对数阶O(logn)
线性对线O(nlogn)
K方阶级O(n^k) :	平方阶O(n^2)/立方阶O(n^3)
非多项式量级
指数阶O(2^n) 
阶乘阶O(n!) 



非多项式量级的复杂度会随数据规模增大而暴增，为低效率算法

O(logn)
int i=1;
while (i<=n){
i=i*2;
}

2^x=n
执行次数：f(n)=x=log2(n)
时间复杂度：O(logn) （对数忽略系数即形式上忽略底数）

O(nlogn)
int j=1;
int i=1;
for(;j<=n;j++){
while (i<=n){
i=i*2;
}
}
时间复杂度：O(nlogn)

int cal(){
int sum=0
for(int i=0;i<m;i++){
sum=sum+i;
}

for(int j=0;j<n;j++){
sum=sum+j;
}
}
时间复杂度：O(n+m) 对于无法确定的数量规模的最大阶复杂度都不可忽略

空间复杂度
void print(int n){

int []a=new int[n];
for(int i=0;i<n;i++){
a[i]=i*i;
}
for(i=0;i<n;i-++){
print out a[i];
}
} 
空间复杂度：O(n)
2018-09-27
 作者回复
👍👍

2018-09-27


韦爷

0
非程序员也看得懂，但还是觉得没有练习检验的话，无法确认是否真的懂了。毕竟工程类的知识和得到那边的通识内容是不一样的
2018-09-27

对呀👾

0
如果就业务而言，可以针对利用率高的功能做复杂度分析优化
2018-09-27

何领

0
感觉都看懂了，但一想不应该这么简单吧，等明天的下篇看看还有啥
2018-09-27

不似旧日

0
老师讲的很棒！么么哒爱你呦
2018-09-27

宋意

0
时间复杂度有高中数学基础就可以学会，关键是看循环执行的次数。空间复杂度就看申请了多少内存，很多情况下会使用空间换时间，比如缓存机制
2018-09-27

爱Python

0
老师，累加求和的代码第四行的执行次数为什么是n?我认为是n+1，还有O(m+n)和O(m*n)这两个我有点迷，m,n量级不确定时应该用O(m+n)?O(m*n)是哪种情况？
2018-09-27
 作者回复
1. 你看的很仔细 不过是n还是n+1都不影响最后的时间复杂度
2. 这个你可以先不去深究 等讲到后面字符串那一节就会详细的讲 也有例子

2018-09-27


Kyle Liu

0
仔细研读了，有喝多模糊的地方都清晰明了。有很大提升，非常感谢大佬
2018-09-27

Geek_c42505

0
在开发之前，技术选型之前，考虑时间空间的复杂度，选择复杂度低的技术实现，要比时候测试然后修改的效率高很多。还有在codeing的时候养成关注时间空间复杂度的习惯，非常有利于写出高效的代码。
2018-09-27

tedyhy

0
不太理解多项式和非多项式的概念，比如为什么叫多项式？
2018-09-27

Leo Wang

0
只学过C++的我看这些竟然不会很吃力ψ(｀∇´)ψ不过n！复杂度的会是什么样的代码啊
2018-09-27

驴晓晚

0
先听一遍，再看一遍，再练一遍，再留言，再看留言，我就不信了别人都能学好算法数据结构，我就不行吗✋

有个问题，压力测试可以作为复杂度分析的有力佐证吗？还是他们二者的目的本质上就是不同的？
2018-09-27
 作者回复
可以作为有力的证据。都是考量程序的性能 只是方法不一样 一个是理论上 一个是真实情况下

2018-09-27


小陌

0
更新速度要能再快一些就好了
2018-09-27

Damon

0
整了5年都没整明白，今天终于明白了
2018-09-27

REAL_MADIRD

0
我竟然都看懂了，我只能想到一个原因就是老师的功力太深厚了
2018-09-27

andi轩

0
老师，下面这段代码
int i=2;
while(i <=n) {
i=i*i;
}
我理解，时间复杂度是O(根号n)，对吗？
2018-09-27

醉比

0
先跟着语音听一遍，再自己回顾一遍。讲真可能现在的工作用到的复杂度分析很少，但学习作为自己的知识储备是很好的。关于作者讲的分析方法，无论哪一种方法，我们需要找到执行次数最多的那段代码，判断次数，使用该代码执行的量级，便是这一段代码的时间复杂度。
2018-09-27

1.

0
前面说n表示每行代码的执行次数，后面说n表示代码的体量，小白一个，求老师解惑！
2018-09-27

James Scott

0
您好，王老师。我想问您一个问题，就是您上面提到的时间复杂度分析的第一种和第二种方法好像都是只关注代码执行次数最多的一段代码的执行效率，请问这两种有什么区别吗？
2018-09-27
 作者回复
哈哈 没太大区别 理解就好 不要可以区别

2018-09-27


零维

0
我也不认为多此一举。计算机的进化速度远远超出人的进化速度，我们无法想象在短短的几年后我们的应用会变成多少量级的，所以写出复杂度低的代码就尤为关键。
再者，事后测试的方式受不确定性影响太多了，所以分析复杂度的意义就更大了。
2018-09-27

Anson

0
理论联系实际 事半功倍
2018-09-27

ftutor

0
性能测试覆盖大部分case，保险程序在大部分场景不出问题，不一定能覆盖最坏的情况，而复杂度分析可以极端情况考虑在内，对程序执行速度有个预期
2018-09-27

yasin

0
关于代码的复杂度分析，应该是在编写代码的过程中，程序员自身去分析优化。
性能测试是帮助排解一些在开发过程中被忽略掉的性能问题。
这就像功能测试的道理一样，反正都要功能测试，难道就不需要认真开发功能了吗😅
2018-09-27

CH.en

0
首先对于老师的更正错误的速度点赞。昨天看到的错误，没来的及留言指出。结果今天一看的时候还以为昨天我看错了。已经全部更正了点赞。

对于算法复杂度分析和性能测试，一楼说的很到位，我认为算法复杂度分析和性能测试都是非常有必要的，前者对让我们自己对代码的运行时间效率提前有一个自己的预期，而性能测试是代码的实际运行情况，如果性能测试与之前我们算法分析的预期有较大差异，我们也能快速的定位到问题所在。
2018-09-27
 作者回复
哈哈 多谢理解

2018-09-27


止

0
时刻对时间复杂度和空间复杂度的关心可以写出质量更好的算法
2018-09-27

一颗菜

0
1int cal(int n) {
2 int ret = 0; 
3 int i = 1;
4 for (; i < n; ++i) {
5 ret = ret + f(i);
6 } 
7 } 
8 
9 int f(int n) {
10 int sum = 0;
11 int i = 1;
12 for (; i < n; ++i) {
13 sum = sum + i;
14 } 
15 return sum;
16 }
这不是两个独立的方法吗，f()不归属上面一个方法，怎么会是乘法法则？
2018-09-27
 作者回复
cal函数调用了f函数的

2018-09-27


Allen

0
有个小问题，就是乘方和相乘的符号，看上去是一样的？
2018-09-27

龙腾18

0
老师，nlogn在坐标系第一象限的图不对的吧在n=1的时候为0的
2018-09-27
 作者回复
嗯嗯 看的好仔细啊 严格从数学公式上讲 确实是的。不过我们这是只是表示一个增长趋势的差别。实际上起点并不重要

2018-09-27


YYT

0
代码的时间复杂度空间复杂度是我们在运行程序前的对代码的直观理解，有助于我们预判程序和改进程序，所以这不是一个多余的步骤，同时由于预判，之前便能很好的了解程序，选择更优化的程序，对后面的工作可以节省不少的时间，所以这也并不浪费时间。但是最好是在编程的时候就具有这种复杂度的大榄，进而编写出复杂度比较小的，运行比较高效的程序。
同时不同的测试环境对同一个算法，执行效果也不近相同，这就需要我们先做性能测试，再做代码复杂度分析。
2018-09-27

木子风吹

0
3.O(m+n)，O(m*n)这节有点明白，那段代码的时间复杂度因为m 和n不确定，所以是O(m)+O(n)，这个理解，但后面又说O(M*N)不太懂什么意思，请老师和各位大佬解答解答
2018-09-27
 作者回复
for i =0；i《 m；++i
for j = 0；j 《 n；++j
......


这个样子就是O（m*n）

2018-09-27


windliang

0
老师，麻烦您下节课可以讲几个递归的时间复杂的分析。
2018-09-27
 作者回复
下节课已经定稿了 改不了了 我后面抽时间再讲吧

2018-09-27


zero_

0
时间复杂度，空间复杂度
2018-09-27

学渣！！！

0
性能测试是建立在开发基本完成的，我们可以在开发过程中先确定好时间，空间复杂度岂不是更好。并且性能测试可能根据我们机器不同，数据量不同可能得出的结果也不一样，虽然时间，空间复杂度的分析会浪费点时间，可熟悉了也还好😀
2018-09-27

🙃

0
对两种复杂度的分析是很有必要的，我们的存储空间都是有限的如果做一个项目用去了很多的空间，那么这个利用率就不高，而对于时间复杂度，如果时间复杂度过高，我们在完成某一项大型任务时就会用去很多时间，这不仅会浪费了电脑资源，还会浪费了人的时间，另外如果某个软件程序时间复杂度过高，那么用户体验就会很差，这样就会失去很多忠实用户，不利于公司的发展
2018-09-27

虚拟边缘

0
王老师讲的太好了，我要重新拾起信心，在算法学习的道路上越走越远。
2018-09-27

Feng

0
复杂度分析【很重要】

事后统计法的局限性
- 测试结果依赖测试环境；
不同的处理器，不同的代码不同机器的不同结果。
- 结果受数据规模影响大；
待处理的数据有序度，影响不同排序方式的效率。

所以需要无需具体数据测试即可粗略估算执行效率的方法，即时间，空间复杂度分析方法。
-------
大O复杂度表示法
执行时间与每行代码执行次数成正比，公式。
表示代码执行时间随数据规模增长的变化趋势。
全称渐进时间复杂度，简称时间复杂度。
如何分析:
- 只关注执行次数最多的一段代码。记录复杂度取最大阶的量级，
- 加法法则:总复杂度等于量级最大的那段代码的复杂度，【ps:常量级执行，只要是已知数就和n无关，常量本身对增长趋势无影响，不管执行时间多大，暂忽略】
- 乘法法则:嵌套代码复杂度等于内外代码复杂度的乘积，【具体比如，代码中的嵌套循环】

几种常见时间复杂度实例分析:
粗略分为 多项式量级 + 非多项式量级

主要看多项式量级:
- O(1) 常量级 一般不存在循环或递归语句。
- O(logn).O(nlogn) 对数阶时间复杂度 常见也最难分析;另采用大O标记复杂度时，可忽略系数，在此忽略对数的"底"。
- O(m+n).O(m*n) 当代码复杂度由两个数据规模来决定。
-------
空间复杂度
全称渐进空间复杂度，表示算法的存储空间与数据规模之间的关系。
空间复杂度常用仅O(1)、O(n)、O(n²)，分析也较时间复杂度分析简单。
-------
课后思考
关于复杂度的分析，个人并不觉得多此一举，格外重要，反而会有乐趣，目标是写有美感的代码，找到时间和空间上的和谐，不过分追求低阶或高阶，趁手好用就好，有时候看身边伙伴们的代码，会有惊喜的感觉，互相捉虫，互相学习成长。
2018-09-27

一马行千里

0
脑子里有清晰的复杂度概念和分析方法，更能写出高效的代码
2018-09-27

细长大白腿

0
滴~今日打卡，似有所得慢慢消化
2018-09-27

缓哟

0
糟糕 不知道做项目之前的性能测试是什么
2018-09-26
 作者回复
😄 性能测试不是项目之前。是开发完成之后 测一测开发出来的系统的性能。你可以自己搜索一下 了解一下基本概念

2018-09-27


流浪猫

0
讲的很好，看懂了以前没看懂的对数复杂度的解释。
性能测试不能代替时间复杂度分析，性能测试受限于所选测试数据量，例如一万次或十万次，但其实可能十万次的时间是可以接受的，而百万次的时间已慢的绝不可接受。而且有时受限于数据大小，小数据量对于糟糕的算法，运行时间也是可以接受的，但是生产上是大数据量，糟糕的算法性能就急剧下降了。
2018-09-26

Rancood

0
大O复杂度表示法，执行时间随数据规模增长的变化趋势（渐进式时间复杂度），从低阶到高阶：O(1)-O(logn)-O(n)-O(nlogn)-O(n2)。n表示数据规模大小。
时间复杂度分析：1只关注循环执行次数最多的一段代码，2加法法则：选择最大量级的那段代码的复杂度，3乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘机
2018-09-26

Fisher

0
这篇文章最大的收获是：时间复杂度是表示代码执行时间随数据规模增长的变化趋势，这句话从本质上讲清楚了时间复杂度是干什么的，一直以来对时间复杂度感觉畏惧，就是因为没有从原理上弄清楚他到底是干嘛的，所以排序算法的时间复杂度都是死记硬背，时间一久就忘记，对于时间复杂度的分析为什么去掉常量也做了说明，掌握了方法剩下的确实就是练习了
2018-09-26

Never too late

0
算法导论里面还讲解了小o和w标记法，也就是渐进上届和渐进下届
2018-09-26
 作者回复
是的 我故意没讲 一块讲更容易混 而且一般都用大O表示

2018-09-26


落叶飞逝的恋

0
渐进分析的其他符号是否需要理解？
2018-09-26
 作者回复
暂时不需要 常用的就是大O 感兴趣的话可以去了解下

2018-09-26


落叶飞逝的恋

0
还有空间复杂度不是一般使用S来进行标记的吗？为什么文章里还是用O来表示？
2018-09-26
 作者回复
应该是O S我没听说过啊 你哪本书里看到的呀

2018-09-26


范柏柏

0
由现在开始就应该培养自己一种思维。
不是写完程序事后去优化。
而是在敲之前就清晰的把握最优的复杂度。
期待老师后续的课程。
2018-09-26

守着云开

0
看懂啦 老师带我飞
2018-09-26

黑桃K

0
思考题回答：从复杂度分析上，理论角度可以简单辅助判别数据量极大的情况下的效率。但是性能测试作为开篇讲到的事后测试，往往在特定的平台和基准下有特定的表现，两者都很重要。如果在编码时结合利用复杂度分析，择优选择算法，对后面性能测试会起到良性结果。当然，不排除特定情况下o（n）的算法比o（logn）好。
总结：高阶优先，加法法则，乘法法则，非多项式复杂度，多数据规模复杂度，空间复杂度
2018-09-26
 作者回复
理解的到位！

2018-09-26


斗米担米

0
性能测试应该不能检测到具体耗时耗内存的位置，复杂度分析还是很有意义的
2018-09-26

万利

0
打卡
2018-09-26

蔷薇骑士

0
性能测试是实践检验，是很有必要的，但它像文中所说受限于测试环境，数据规模，测试场景，也是有局限性的。而复杂性分析偏向于理论，是一种很好的补充。至于说是否要对每段代码做复杂度分析，就取决于成本和收益了，现实中应该不太可能，个人感觉对核心算法和代码做分析，另外对出现性能问题的代码针对性分析比较有可行性。
2018-09-26

拂衣袖

0
像追剧一般的等你更新啊
2018-09-26

objcoding

0
不错，都看懂了
2018-09-26

落叶飞逝的恋

0
加法法则与乘法法则，对于同一个代码所得出的时间复杂度结果不一样，会不会真实的结果被覆盖。一个是n的平方，一个是n的立方。这个怎么解释
2018-09-26
 作者回复
怎么会不一样呢 能具体举一个例子吗

2018-09-26


90飞

0
1、这是我看过和听过的对复杂度讲解的最能适合我理解的了。
2、关于课后思考题，小公司没做过这方面的测试，不是很了解。但是看了好多人的留言，觉得都好有道理，学到了，真是厉害！
2018-09-26

林展翔

0
如果我在循环的判断是以宏（值已知）来进行判断的，在这种情况下，时间复杂度是O(n) 还是 O(1)呢？
2018-09-26

看到进击的合成尸就让他滚去敲代...

0
不好意思老师，，我的问题，整体是立方阶，这个函数是平方阶，，我看错了，，不好意思了老师
2018-09-26

小康

0
时间复杂度表示算法的执行时间与数据规模之间的增长关系。
空间复杂度表示算法存储空间的与数据规模之间的增长关系。
2018-09-26

无疆

0
多谢老师的讲解,感觉听懂是听懂了,就是需要多多练习吧, 而且不知道去哪练习,离开了老师怎么开始? 呵呵
2018-09-26
 作者回复
别急 后面每种数据结构和算法 都会分析相应的时间 空间复杂度。你可以拿来当作练习

2018-09-26


张秧

0
经过老师的讲解，对复杂度理解的更透彻
2018-09-26

程序媛小喵喵

0
我不认为是多此一举，一个从事实出发一个从用理论分析，即能互相补充，又能验证测试数据的正确性。不过不是先分析下时间空间复杂度再进行性能测试吗？
2018-09-26

春暖花开

0
老师，提个建议，我是边播放边看着文字学习的，有时你说得太快，我反应不过来，想暂停一下播放，然后自己去理解一下你讲过的内容，理解过后想再继续播放，现在没有暂停和继续播放的体验按钮...
2018-09-26

wanter

0
各位大佬们的总结我收下了，那么问题来了，谁能推荐个好用的笔记软件呢？win + Android +Mac
2018-09-26

lovelykooo

0
打卡1
2018-09-26

andyXu

0
做好代码的复杂度分析，可以确认性能测试的正确性，以及性能测试覆盖度。
我觉得先分析整体代码结构，然后在分析具体关键代码复杂度。这样更加高效
2018-09-26

落叶飞逝的恋

0
加法法则里面交代了f(n),但是冒出的g(n)，是n平方的缩写？
2018-09-26
 作者回复
不管fn还是gn都是n的表达式。为了区别两个不同的表达式 就一个叫fn 一个叫gn了

2018-09-26


Vincent

0
int cal(int n) {
int sum_1 = 0;
int p = 1;
for (; p < 100; ++p) {
sum_1 = sum_1 + p;
}

int sum_2 = 0;
int q = 1;
for (; q < n; ++q) {
sum_2 = sum_2 + q;
}

int sum_3 = 0;
int i = 1;
int j = 1;
for (; i <= n; ++i) {
j = 1; 
for (; j <= n; ++j) {
sum_3 = sum_3 + i * j;
}
}

return sum_1 + sum_2 + sum_3;
}

老师，我很好奇 前面的两个for循环，里面的p不应该是<=100或者是q>=n 这样才满足循环了100次或者n次 是忘记添加=了吗
2018-09-26
 作者回复
你说的没错 是忘记了 不过不加也不影响结论哈

2018-09-26


三金ฅฅ*

0
谢谢老师，学数据结构时当时老师讲到复杂度分析没怎么觉得这个重要，没怎么用心！现在全明白啦！不过还需要多看几遍！
2018-09-26

Viola

0
请问老师是否可以多给点类似于上边的代码，让我们练习一下分析过程。没有从事过开发，大学学的也都还给老师了，或者老师给个作业链接也行，谢谢。
2018-09-26
 作者回复
下一节会有一个题目 让你们分析复杂度

2018-09-26


流水花开

0
之前买了本，数据结构与算法，自己看起来还是比较费力的，听老师的讲解，感觉理解起来轻松多了！很高兴，老师带我们学习数据结构与算法！
2018-09-26

谷晨霞

0
这位哥哥适合去大学当老师啊，我当时的数据结构课到底是怎么学的，感觉当时完全理解不了，这么一讲就很明白。性能测试跟运行环境，数据体量，软硬件都有关系，算法复杂度是算法层面的初步估计，性能测试是应用层面的实测，意义不同。主要业务处理模块还是要关注算法复杂度。
2018-09-26

石树

0
学习是一场修行，引用胡适的一句话:怕什么真理无穷，进一寸有一寸的欢喜
2018-09-26
 作者回复
受教！

2018-09-26


Haoz

0
一、为什么需要复杂度分析?

事后统计法（通过统计、监控得到算法执行的时间和占用的内存）有着非常大的局限性
- 测试结果非常依赖测试环境
- 测试结果受数据规模的影响很大

二、大 O 复杂度表示法

公式：T(n) = O(f(n))

Ps：公式中的 O 表示代码的执行时间 T(n) 与 f(n) 表达式成正比

1、时间复杂度分析
时间复杂度的全称是「渐进时间复杂度」，表示算法的「执行时间」与「数据规模」之间的增长关系

- 只关注循环执行次数最多的一段代码
- 加法法则：总复杂度等于量级最多的那段代码的复杂度
- 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

2、复杂度量级的分类
- 多项式量级(O(1)、O(logn)、O(n)、O(nlogn)、O(n^k))
- 非多项式量级（ O(2^n)、O(n!) ）

3、空间复杂度分析
空间复杂度全称是渐进空间复杂度，表示算法的「存储空间」和「数据规模」之间的增长关系

三、思考

按照自己的理解，性能分析只能大概计算出项目的某些性能指标，以 App 为例，性能分析包括 App 的冷启动时间、热启动时间、Crash 率等，这些指标一般是为了衡量新旧版本之间是否有所优化、以及跟竞品之间进行比较。

但无法准确的衡量当前项目中某些算法或者模块的性能，而如果进行时间复杂度和空间复杂度的分析，能让我们计算出项目处于哪个数量级，更有利于我们进行针对性的优化，以及更好的衡量时间复杂度和空间复杂度之间的取舍。
2018-09-26
 作者回复
总结的不错！

2018-09-26


南瓜马车

0
小白打卡，转行学习中，比看书容易理解
2018-09-26

海洋

0
很不错，以后写代码拿这个心里估算一下，对效率有个大致的估计。也是代码调优的重要参考。
2018-09-26

可苦可乐

0
终于知道对数阶的时间复杂度怎么来的,写的很清楚
2018-09-26

CodeLiar

0
nlogn的曲线？
2018-09-26

小学徒

0
这个分两方面来说，如果单单是开发时来花时间去分析复杂度的话确实明面上是浪费时间，
但如果从整个项目的角度来说，如果你花2个小时，让这个项目效率提升1秒钟，当100万个用户使用的时候，节省的时间却是比2小时多很多
2018-09-26

蒋礼锐

0
时间复杂度用来衡量程序所需要的时间, 空间复杂度用来衡量程序所消耗的储存大小, 通常情况下时间复杂度更能直观反映算法的好坏, 甚至还有空间换时间的说法.

为什么不使用实际运行代码的时间和内存大小来衡量?

1 运行代码的环境不一样, i9 和 i3的速度肯定有所不同

2 测试数据的规模, 100个数据和100的100次方个数据所花的时间肯定不一样, 某些算法在小规模数据上具有优势(比如插入排序之与快排), 而实实在在的跑100的100次方个数据不够现实.

3 不可能先把各种复杂度都写出来测试后再修改, 这样十分的耗费时间,且低效, 需要一个可以在设计代码阶段就让你知道你的算法好不好的衡量指标
2018-09-26
 作者回复
总结的不错

2018-09-26


木心

0
我理解的是不是时间复杂度高了，空间复杂度就低了，此消彼长。
2018-09-26
 作者回复
他俩没直接的关系 理解的有点不对哦

2018-09-26


Light Lin

0
空间复杂度那里有点懵，如果把那行申请数组空间中的 n 改为常数，那空间复杂度是不是O(1)
2018-09-26
 作者回复
是的。不过前提是能改成常数

2018-09-26


看到进击的合成尸就让他滚去敲代...

0
但 f() 函数本身不是一个简单的操作，它的时间复杂度是 T2(n) = O(n)，所以，整个 cal() 函数的时间复杂度就是，T(n) = T1(n) * T2(n) = O(n*n) = O(n∧2)，，后面这个2应该是3吧，应该是立方阶吧，，还请老师指导
2018-09-26
 作者回复
为啥是3呢 能说说你的推理吗

2018-09-26


lovetechlovelife

0
就拿我现在的工作，大数据开发来讲，因为集群资源有限，同一时间段内运行的job会很多，这个时候就要优化自己的程序，让应用在使用更少的cpu、更少的内存的情况下很快的跑完。
2018-09-26

Fighting

0
时间复杂度的分析方法：
（1）关注循环次数最多的一段代码
（2）加法原则，总复杂度等于级数最大的那段代码
（3）乘法选择，同加法原则
2018-09-26

枕之雪

0
我和其中一位同学的观点挺像的，进行复杂度分析是为了在编程中应用，一般我们在实现某项功能的时候，比如说需要用到嵌套循环，复杂度基本就定下来了，我们在这个基础上要降低时间复杂度的话，用什么办法呢？阶数越高，一般复杂度越高，如何去分解。不知道这种理解是否正确，希望老师讲一些降低复杂度的方法
2018-09-26
 作者回复
这个要具体问题具体分析了 你说的嵌套循环 复杂度是定的 那确实有可能没法再优化了

2018-09-26


蒋礼锐

0
老师，按照某一行的运行时间来定unit time是不是不够准确？因为sum=0的这一行和for循环里又有判断，还有加一操作的这一行，时间应该是不一样的，直观感觉应该后者为前者的两倍

所以对于这个界定是不是用基本运算的时间来定更确切？比如加减乘除等。

只是一种猜测，我也不知道这个应该用什么去准确衡量这个单位时间
2018-09-26
 作者回复
说明你认真看看 认真思考了。确实不够准确 但是简单啊 更准确的度量可能也有 但统计起来就没那么简单了。我们只是粗略估计 就可以用一个粗略的度量标准

2018-09-26


太空土豆

0
第一个例子里面5，6行中，第6行执行n次，而第5行for里面的执行需要分解。判断语句和后面++语句要分解成两个简单语句。这样计算出的表达式才是语句执行频度与问题规模n相关的一个表达式。虽然与最终复杂度结果不冲突，遇到了，尽量避免误导。
2018-09-26
 作者回复
👍

2018-09-26


再见理想

0
感谢老师， 从零学起，自己做了一份笔记，加油！
2018-09-26

空白

0
老师有这个大O公式的推导过程么？
2018-09-26
 作者回复
严格的推导过程没有呢 专栏里讲的就是粗略的大o的由来

2018-09-26


再见理想

0
感谢老师！
2018-09-26

太空土豆

0
这一讲比较难讲。
复杂度实质是反应算法执行时间与输入数据规模n的变化趋势。O(1)为常量，即该算法时间与输入数据规模无关。O(n)表示该算法时间与输入数据规模n呈线性增长变化……。
当然，这里算法运行时间与具体的运行环境无关，它是在一种假设的“计算模型机”下考虑的。这种模型机有这几种假设:有一套标准的简单指令系统；任何一项简单的工作都在一个时间单元内完成；内存无限。
要真正弄清时间复杂度，要学会简单情况下计算语句执行频度，一般情况下可以用多项式表示。计算语句频度某些情况很复杂，特别涉及一些递归调用。但如果涉及到考试或者面试，也就那几种情况，可以归纳总结一下。讲义中那个对数级例子很好。
谢谢老师。
2018-09-26
 作者回复
👍 说的很好👍

2018-09-26


啦啦的小猪

0
老师讲得很好！看完后现在脑子对这特别清晰！谢谢老师～
2018-09-26

Piggy

0
分析时间复杂度，把代码拆开来一块一块、一层一层分析，嵌套是相乘、并列是相加。
按照控制流图拆块、拆层🤪🤪
2018-09-26

Hy

0
1 i=1;
2 while (i <= n) {
3 i = i * 2;
4 }
第三行为何执行次数最多呢，感觉第二行会多执行吧，因为最后一次判断超出后不再进入代码块
2018-09-26
 作者回复
哈哈 对于复杂度分析来说 多一两次 少一两次都不影响结果

2018-09-26


言止于心

0
老师，请问非多项式的时间复杂度都会用在哪些地方？是没有什么实际使用作用吗？
2018-09-26
 作者回复
是没有实际的作用 因为执行时间随n的增大增长速度太快了

2018-09-26


水果刀

0
手动点赞
2018-09-26

ivan

0
针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m)*T2(n) = O(f(m) * f(n))。



请问下老大，这种情况下，加和乘计算都可以是吗
2018-09-26
 作者回复
亲 没怎么看懂你说的呢

2018-09-26


长安

0
这节课所学总结:
时间复杂度T(n)=O(f(n)) 即用大O法来近似估算算法的操作次数 老师讲了三种情况 
一段代码时 看循环语句里的操作次数
两段代码时 取操作次数最大的为时间复杂度 如例子中的双重循环 
两段代码且问题规模不同时 将两段代码的时间复杂度相加为整个算法的时间复杂度
常用的时间复杂度可分为两大类 多项式阶和非多项式阶 通过热评第二条了解到两类的不同特点 
最后知道了空间复杂度也是用大O法来表示
2018-09-26
 作者回复
👍

2018-09-26


流星雨

0
做个标记，这次一定要学好数据结构与算法，感觉这一篇解决了我以前的疑难杂症！！！
2018-09-26

李奇

0
对项目进行性能测试更多是获得这个系统的执行效率，那这个系统中各个部分对效率的影响和贡献率是多少呢，这就需要我们去分析代码的时间和空间复杂度，这样就能知道哪个部分是最拖后腿的，那就能集中对这部分代码进行优化，提高开发效率。
2018-09-26

肖观腾

0
听不过瘾啊，每天都能更新就好啦啦啦
2018-09-26

大老李

0
大学的学完了就忘，现在再听老师讲一遍，感觉理解的更到位了
2018-09-26

scarlett

0
通俗易懂，以前看书怎么也学不会 时间空间复杂度，看了老师的这一篇完全理解了，期待期待。
2018-09-26

　　　　　　　　　　　Spike　...

0
我觉得问第二个例子中5、6行代码为什么是2n平方遍而不是n平方遍的应该是问的第七八行吧，而且解释应该是“第七行有n平方遍，第八行有平方遍，加起来是2n的平方遍”
2018-09-26
 作者回复
没错

2018-09-26


活的潇洒

0
第一发送的在线图片有误
http://on-img.com/chart_image/5baaeffde4b015327aefce96.png
2018-09-26

Rain

0
从这里开始文科生基本就读不懂了😂
2018-09-26

~记得微笑∩﹏∩

0
老师讲的很好，点赞
2018-09-26

Jason

0
我觉得复杂度分析放在代码设计时，和性能测试并不冲突。设计时通过多个方案的复杂度分析可以找到最优的方案，而性能测试则是去验证自己的猜想，找出设计时未考虑到的情况
2018-09-26

Jason

0
我觉得复杂度分析放在代码设计时，和性能测试并不冲突。设计时通过多个方案的复杂度分析可以找到最优的方案，而性能测试则是去验证自己的猜想，找出设计时未考虑到的情况
2018-09-26

桃子公举

0
作为前端 出来没有参与过性能测试 也用不到很复杂的算法 用到最多的就是for循环了吧 不过理解之后自己还是会在实际项目中尽量注意的
2018-09-26

港

0
我认为复杂度分析不是多此一举，性能测试能够测试到是否满足项目的需要，但是复杂度分析有可能让自己写出更加节省时间和空间的程序。

我认为每段代码都分析时间和空间复杂度并非浪费时间，因为代码的时间和空间上面小的浪费累计起来就可能是大的问题。
2018-09-26

Starbug

0
课程总结：
1. 时间、空间复杂度分析，提供了一种抽象的、行业内共通的评价标准，比如查看某个库的文档，一看提供的某个接口的时间、空间复杂度是O(n)，你就可以估摸一下这个库的质量，效率是否满足你的需求
2. 大O分析法，分析的是程序运行时随着问题规模扩大时(n增加）的时间、空间增加趋势，可以快速估算出时间、空间成本，并思考是否有更优的解决方案。比如初版算法用暴力法时间复杂度为O(n^2)，那就可以根据大O分析法去思考，是否能优化到O(nlogn)或者O(n)，甚至有些magic方法能达到O(1)
3. 加法法则、乘法法则、NP问题（Non-Deterministic Polynomial），这些概念非常亲切，想起来大学时代的算法课
课后问题：
1. 性能测试是很必要的，一方面不同的运行环境下软件的运行效率不一样，需要通过性能测试来得到具体数据；另一方面性能测试可以模拟随机的输入来测试代码在不同情况（边界条件）下的运行情况，甚至能查出一些逻辑问题
2. 时间、空间复杂度分析也很重要，因为性能测试是有成本的，一个设计使用规模为几亿甚至更高量级的算法，要完全模拟真实环境成本很高，往往会在不同的问题规模下进行性能测试采样数据，再通过分析采样数据是否符合复杂度分析的结果，并推理更大规模时代码的运行情况如何。
3. 是否需要每段代码都分析时间、空间复杂度呢？我觉得不需要，具体情况需要具体分析，线上环境不会用到甚至只会在初始化时运行一次的算法，就没有必要太执着于分析复杂度，而系统的核心模块，线上环境需要频繁调用的，那么就需要进行仔细的复杂度分析并且进行性能测试，避免成为系统的瓶颈。

2018-09-26
 作者回复
总结的到位

2018-09-26


碘酒

0
还有一个n！，n！是耗时最长的函数。
2018-09-26
 作者回复
对的

2018-09-26


北天魔狼

0
我认为空间复杂度分析可以合理预测计算量大时产生的影响，测试只能测试得出当前的性能。
2018-09-26
 作者回复
是的 理解的没错

2018-09-26


XXYang

0
所以为了节约时间，少写循环。。
2018-09-26

武坤

0
请问，多项式量级非多项式量级是如何区分的？为什么只有O(2n) 和 O(n!)才是非多项式量级？
2018-09-26
 作者回复
我百度了篇文章 
https://blog.csdn.net/qq_38250032/article/details/81586329

2018-09-26


New Yorker

0
几点感悟，
1.复杂度分析是一种很灵活的方法，根据程序的执行次数等会有不同的最佳方案

2.复杂度分析主要有n n*n logn nlogn 几种，寻找复杂度的入手点其实是最里层的循环


2018-09-26

周文凯 Kevin

0
总算弄明白这个时间复杂度的大O计算方法了，讲得很透彻！

性能分析和时间复杂度相辅相成
2018-09-26

小兔子乖乖别开门

0
老师，空间复杂度的对数的底数也忽略吗？空间复杂度不是表示内存占用吗？占用的空间，底数不同空间就应该不同吧？
2018-09-26
 作者回复
复杂度表示的是一种增长趋势 并不是实际的内存占用量

2018-09-26


djane

0
【笔记】
一、为什么需要复杂度分析？
事后统计法有非常大的局限性。
1、测试结果非常依赖测试环境。
2、测试结果受数据规模的影响很大。
所以，我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法。

二、大 O 复杂度表示法
所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正。
表达式：T(n) = O(f(n))
大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度。
（当 n 很大时，你可以把它想象成 10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了。）

三、时间复杂度分析
1、只关注循环执行次数最多的一段代码。
在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了。
2、加法法则：总复杂度等于量级最大的那段代码的复杂度。
3、乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。

四、几种常见时间复杂度实例分析
常用的的复杂度量级，粗略地分为两类，多项式量级和非多项式量级。
1、非多项式量级：O(2^n)（指数阶）、O(n!)（阶乘阶）。
把时间复杂度为非多项式量级的算法问题叫作（Non-Deterministic Polynomial，非确定多项式）问题。
（当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。）
2、多项式时间复杂度：O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）、O(n^k)（k次方阶）、O(m+n)、O(m*n)。

五、空间复杂度分析
空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。
常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。
2018-09-26
 作者回复
写的很好👍

2018-09-26


Valar Morghulis

0
算法复杂度分析的关键是 看随着数据规模的变化，算法执行次数的变化。
2018-09-26

万象

0
不应该在程序开始写的时候过度考虑复杂度，而是让我们对复杂度有意识，最起码要避免低级的复杂度问题，久而久之自然而然就写出高质量的代码
2018-09-26
 作者回复
理解到位

2018-09-26


shupian418

0
for (i=0;i<n;i++) {
for (j=0;j<3;j++ ){
...
}
}
老师这种复杂度时O(n)吗？
2018-09-26
 作者回复
是的 👍

2018-09-26


奔跑的蜗牛

0
认认真真地看完了一遍，看懂了！但是，手应该不熟！
2018-09-26

Wm.

0
看完之后，立马对时间复杂度和空间复杂度有了更深的理解。针对第二个例子，
for (; j <= n; ++j) {
sum = sum + i * j;
}
如作者所言，for循环是个判断，因此要进行n次，所以最后结果为2*n方，但这并不影响大O的最后的结果。所
2018-09-26

Spark_Shade

0
第二个例子中，7,8行代码，执行时间里的系数2是怎么来的？
2018-09-26
 作者回复
两行代码 所以是2呢

2018-09-26


子青

0
对于科班来说有点过于基础，期待后面的实战
2018-09-26
 作者回复
开头简单点 要照顾一下其他同学

2018-09-26


少凯

0
在进行复杂度分析时，如果调用库函数，需要了解这些库函数的复杂度，否则分析容易出现偏差。
2018-09-26

秋风

0
相对于时间复杂度的分析，老师我记得算法导论里花了一章的篇幅去讨论摊还分析，那么这个摊还分析的意义我有点不理解
2018-09-26

择动

0
当然得分析，写代码总不能靠猜的。不然自己都虚。无凭无据的，怎么能证明自己的算法好，项目好呢。所以还是得分析，为的就是有理有据，我老师是这么教育我的：靠瞎撞太挫了。
2018-09-26

墨墨

0
老师好，我没上过高中，有几处疑问：
1.加法法则公式抽象成T1(n)=O(f(n))，T2(n)=O(g(n))那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n))).
这里的O(max(f(n), g(n))). 取的是f(n)和g(n)中的最大的吗？
2.多项式量级里的对数阶O(logn)
为什么x=log2n,是怎么算的
为什么对数之间可以互相转换 log3n 等于 log32 * log2n
3.因为没读过高中，有些函数看起来比较吃力，怕后面会掉队，有什么可以推荐下学习的吗
2018-09-26

木头衣服

0
学过高数就会觉得很简单呀。其实就像老师在前面所讲的，在大规模的运用中重要性逐步凸显。换句话说，复制度低的代码，能有更广泛的适用性和可迁移性，从最开始就注意这点，积累下来，越往高处走就越轻松，如修炼内功。
2018-09-26

JStFs

0
乘法法则举的例子中，嵌套的内层方法中的入参虽然是“n”，但其实n的变化是从1，2，3，…，n
显然这个n是变化的，与外层方法的入参n根本不是一个意义。王老师降两者的复杂度直接相乘得到n平方是否有些不严格？

我的拙见是，复杂度应该是1+2+3+…+n=n*（n+1）/2
虽然最后也是接近于n平方，但逻辑是否更强一点？
2018-09-26

落叶秋_风隐忧🍂

0
for (; i <= n; ++i) 对这一行算作执行n次有点不理解。
这一行for里面有两条语句（i<=n和++i），不应该算是执行了2*n次操作吗，还请老师解惑
2018-09-26

Joshua 兆甲

0
如果可以，希望老师讲一讲sql查询语句的复杂度分析。
crud boy的单纯想法。
2018-09-26

MJ

0
代码规模巨大，分析复杂度会不会很麻烦，有没有自动化的工具呢？
2018-09-26

陈振荣

0
1.大O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度

2. 只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。

3. 时间复杂度分析方法
只关注循环执行次数最多的一段代码
加法法则：总复杂度等于量级最大的 那段代码的复杂度
乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

4. 问题：文中分析空间复杂度那段代码为什么有点傻呢？for循环语句中＋＋i和i＋＋只是个人习惯问题吗？
2018-09-26

小泰

0
看第一个例子的时候看到2n^2的时候，没太注意，继续看，发现第二个例子还是2n^2这样，看留言发现很多同学都有这个疑问，作者也给了回复说“因为两层循环 一层是n 两层是n*n。不信你自己令n=5 自己算算”，其实疑惑点在2上面，仔细看下代码才发现是两行代码执行了n次，所以是2n^2。还是要仔细呀
2018-09-26

秋风

0
我也粗浅的看了算法导论，第二第三章里对算法执行效率和函数增长率的分析，我理解是，其实就是函数极限，有一个夹逼定理，好像叫做洛必达法则是吗，当n趋近于无穷大时，表示算法执行时间的函数f(x)会有一直不大于的函数cg(x)，这个g(x)的n最高次，就认为是算法的执行效率，因为当n趋近于无穷大时低阶的项对于函数的走向的影响会趋向于无穷小。
还有小o、w什么的
2018-09-26

流沙咖啡

0
早上看的时候没有行号，中午重新打开看居然就有了！！！
2018-09-26

AI

0
Python也可以使用吗？
2018-09-26

代码之美

0
我有个疑问，for循环语句里，每次循环的时间都是相等的吗？还有，如果在循环里加一个栈，每次来个数据放栈里，时间是相等的吗？如果不是，那这个公司还适用吗？
2018-09-26

yeStwind

0
更新还可以再快一点:-)
2018-09-26

steventang

0
性能测试和算法时空复杂度分析两者并不矛盾，只是定义前提和使用场景不同。
第一，时空分析强调分析效率和规模（单一因素）的关系。这让我们开发人员能够在设计数据结构和算法前能在心里有个预估，知道瓶颈可能出现在哪里。实际开发中特别是规模上来后设计优劣就显现了。
第二，性能测试是从众多的因素中找出影响性能的调优过程。它可以反向验证算法。
2018-09-26

lynxcat

0
你好，请教一下如果一段代码中涉及到多个未知数据量，如以下代码片段
for i := 0; i < len(stores.List); i++ {
sid := stores.List[i].Sid
orders := getStoreOrders(sid, token) //通过sid循环找到Order列表，并循环处理
members := getStoreMembers(sid, token) //通过sid找到members列表，并循环处理
statistics := getStoreStatistics(orders, members, sid) //嵌套循环order 与members得出最终结果 
}
f(n)为stores， m(n)为循环orders, g(n)为循环members
最终的复杂度是否是 T(n) = O( O(f(n)*m(n)) + O(f(n) * g(n)) + O(f(n) * m(n) * g(n))) 
化简为 T(n) = O(f(n)*m(n)*g(n))

如果是这样的话，那么在计算复杂度的时候能不能不对所有代码进行分析，通过对程序的理解直接找到循环层次最深的那段代码分析之后作为最终的复杂度呢
2018-09-26

A漩

0
性能测试是被动的测试，发现问题再解决问题。
学习算法养成良好的编码习惯是主动的避免问题。两者兼得才是最佳之选，所以不存在浪费时间的场景。
入行将近5年了，愈发感觉数据结构和算法的重要性。尤其是看源码，了解思想看起来才游刃有余。
2018-09-26

hemmmapart

0
感谢老师很用心😁😁
2018-09-26

Alvin

0
讲的非常好！ 
加法、乘法规则，O(logn) 和O(nlogn) 的讲解让我理解的更透彻了！
有一种终于看清楚的感觉！！！
2018-09-26

15221031154

0
事后统计法也是有必要的，通常时间复杂度在针对于执行次数越多的情况才会体现出来，比如同样是O（1）复杂度的代码，一个是循环调用远程服务执行10次(次数是固定的)，一个是只调用1次（批量操作），虽然从时间复杂度来讲都是O(1)。

但是从代码优化层面来讲，感觉时间复杂度只是一方面的评判标准。理论上越省时间，越省空间越好，能少一行代码就少一行代码，能少创建一个变量就少创建一个变量
2018-09-26

Crystal

0
多项式量级和非多项式量级的区别定义是什么呢？
2018-09-26

CathyLin

0
新鲜出炉，当日刷完啦~
刚刚码了好多字，提交的时候要求登录，不知道有没有提交上 :(
2018-09-26

Jan

0
总的时间复杂度就等于量级最大的那段代码的时间复杂度,即：T2(n)，為什麼T(n)等於兩個相加：
T(n)=T1(n)+T2(n)=O(max(f(n)+g(n))).

2018-09-26
 作者回复
啊 我没看到这么写呀

2018-09-26


家明

0
借助老师的教程，终于有信息把数据结构与算法这块硬骨头啃掉了
2018-09-26

灯火可亲

0
想知道有没有工具可以帮助我们算出算法复杂度
2018-09-26
 作者回复
这个想法太好了 我思考一下

2018-09-26


lilithinker

0
我操！通俗易懂，太牛逼了…
2018-09-26

Tensor

0
老师，请问最后一段中的print out a[i]什么意思啊 ，没看懂
2018-09-26
 作者回复
就是打印a【i】的值。我没写成代码 怕跟打印函数跟语言太相关 容易看不懂

2018-09-26


ppingfann

0
讲的浅显易懂，我一直没明白O(1)和O(n)的区别，这下终于明白了。
不知道后面会不会讲到大O的由来，因为大O应该是来自于高数中的知识，如果能讲透就更便于记忆了。
2018-09-26

hope

0
看完了，先打卡，稍后做总结
2018-09-26

BD

0
1.算法的时间复杂度公式从小到大有O(1) O(logn) O(n) 
O(nlogn) O(n²) O(n!) 。

2.时间复杂度T(n)与规模n成正比与常数没关系
2018-09-26

Charles | 姜海龙

0
听了老的课，学习到了很多，明白了以前不明白的东西！
2018-09-26

Nov.

0
边听音频边看文字，必要的时候，暂停，自己画一画。多思考。
2018-09-26

行走着的宋公子

0
复杂度分析是理论评判标准，带着标准写代码，这种潜移默化的影响，是对程序员很大的帮助。
2018-09-26
 作者回复
是的 潜移默化这个词用的到位

2018-09-26


大智若愚

0
下一节有对递归算法的时间复杂度分析嘛？对递归算法的分析老是掌握不了
2018-09-26
 作者回复
别急 慢慢来

2018-09-26


UpToSky

0
老师好！两个小疑问。
1. 为什么要把循环变量的初始化写在循环外面，这样做有什么优点？
2. 循环变量使用 ++i 和使用 i++ 有什么区别？
谢谢！
2018-09-26
 作者回复
1. 写到里面也可以 没啥区别
2. 也没啥区别：）

2018-09-26


Tensor

0
老师，请问您写的for (; i <= n; ++i)是执行了n次，
我看大话数据结构的for(i=1;1<=n,i++)是执行了n+1次，
这是为什么啊？是因为i++和++i的原因吗？

2018-09-26
 作者回复
其实不用纠结这个的 n次 还是n+1次 复杂度只是一个增长趋势的度量 一两个常量是左右不了复杂度的

2018-09-26


caidy

0
我不认为提前做时间复杂度和空间复杂度分析是浪费时间，而且老师最后也说了，熟悉了之后，渐变复杂度分析也是很快的，关键在于提前分析，我们能够知道最坏的情况下，系统性能是什么样子的，能投提前选择方案，做到知己，如果等到发生问题，再来分析，最快情况有可能出现重新设计算法，那这样更加不划算，所以提前做好预测不失为一个好的方法。
2018-09-26
 作者回复
嗯嗯 对的！

2018-09-26


Xypgg™

0
文章很好，很方便理解
2018-09-26

Yannnn

0
终于理解对数时间复杂度的含义了！！当初在学习时就有些困惑，一直未解决。
2018-09-26

黄国华

0
递归式求解什么时候讲呢
2018-09-26
 作者回复
第10讲会讲

2018-09-26


惟新

0
复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。

时间复杂度度量：常量阶、对数阶、线性阶、线性对数阶、平方阶、立方阶...k次方阶、指数阶、阶乘阶。

时间复杂度 粗略分为 多项式量级 和 非多式量级（指数阶和阶乘阶）。

指数阶和阶乘阶为NP问题（非确定多项式）,随数据规模增长而急剧增长，通常要避免。
--------------------------------------------
通过阅读其他朋友的留言，项目性能测试之后，在做复杂度分析，其中印象最深的是 这样和同事交流的时候，一说这个项目的时间复杂度和空间复杂度，内心就会有一个直观的认识。
其他的好处，比如说，和性能测试相比，复杂度分析有成本低，效率高，易操作，指导性强。还可以养成随时考虑代码复杂度的习惯，提高编程质量。
2018-09-26
 作者回复
理解的正确！

2018-09-26


Dwyane

0
终于等到你！加油，坚持！
2018-09-26

张三丰

0
1. 只关注循环执行次数最多的一段代码 是一段代码 不是一行代码 为何不O(2n) O(3n)等等 而都用O(n)表示 写法上的规定吗
2018-09-26
 作者回复
因为是一个估计值 表示一个增长趋势。前面的系数没啥用 所以就省略了 统一表示成o（n）

2018-09-26


微秒

0
老师你好，看了今天你写的文章。我有一个问题，数据规模n到底指的是什么呢？因为你这里说n是每行代码的执行次数，但是遍观全文，感觉貌似是由于数据量才导致了代码执行次数。
2018-09-26
 作者回复
你理解的没错啊 假设数据规模是n。然后看代码执行时间。n并不是每行代码执行的次数和。每行代码执行的次数和有可能是n平方 n立方等

2018-09-26


Casper

0
最后一道题的时间复杂度应该是 √n吧
2018-09-26

luffy

0
看完第一个代码片段，豁然开朗，原来困惑我的是不知道计算规则。
2018-09-26

沉睡的木木夕

0
for (; i <= n; ++i) 
{
sum = sum + i;
}
4,5行是2*N我还是没弄懂，希望懂了的，告诉我下
照我的理解，i<=n,++i，sum=sum+i 都是需要CPU参与运算的，按照前面说的，都为unit_time
那么就不应该是2*N而是3*N
为什么要说是两行就是2*N，那循环体内，我改成int ret = sum+i; sum = ret; 是不是就变成了3*N？
2018-09-26
 作者回复
实际上 2n 还是 3n 甚至是4n都没区别的。因为本身就是估算。在大o复杂度表示里面 n前面的系数都会被省略的

2018-09-26


zwh

0
这个专栏早点出来就好了。。那会看算法书真的一度怀疑自己智商是否属于正常。。然后果断放弃了
2018-09-26

岁月如歌

0
您好，大部分内容我都能看懂，但是O（nlog（n））这个复杂度您能否给一个例子，我自己感觉嵌套调用
f(int i){
...
}

for（int i=0;i<n;i++）{
f(i)
}
是这样吗？
2018-09-26
 作者回复
你写的没错啊 就是你写的这样子

2018-09-26


A 凡

0
关于时间复杂度看了之后认识清晰了很多，但是感觉关于空间复杂度被一笔带过了，认识还有点模糊
2018-09-26
 作者回复
因为空间复杂度要比时间复杂度简单很多 也好分析很多 所以重点就放在了时间复杂度上

2018-09-26


leopard

0
算法的复杂度分析能够不依赖程序的语言、运行环境，能根据数据的规模对程序的运行效率进行估算。这样在写程度时我们就有了理论依据，知道什么样的算法的效率高，朝这个方向努力。而单纯的性能测试太依赖运行环境具有很大的随机性。
2018-09-26
 作者回复
理解的正确！

2018-09-26


spark

0
看了这篇文章，终于搞懂时间复杂度了，先前看java数据结构与算法这本书，看了几次都没看懂，这次终于看懂了，给老师一个大赞！👍
2018-09-26

张三丰

0
而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。 请问什么是低阶和系数 能举个具体例子吗
2018-09-26
 作者回复
2n 前面的2就是系数
n^2 + n 其中n就是低阶

2018-09-26




0
时间和空间复杂度分析的是随数据规模的增大，算法执行时间和内存空间占用的增长趋势！
2018-09-26

Aruen

0
讲的非常透彻，对时间、空间复杂度有了重新的认识，理解的更透彻了！
2018-09-26

边风

0
老师的图是什么软件画的？
2018-09-26
 作者回复
编辑给画的

2018-09-26


zyiz

0
老师 最后一段代码的时间复杂度是多少呢？ 是O(logN)吗？
2018-09-26
 作者回复
是o（n）。你再想想

2018-09-26


老王

0
空间复杂度那个代码不是有个递归？print
2018-09-26
 作者回复
哈哈 不好意思 让你误解了 我改成print out了 跟函数没关系

2018-09-26


longer

0
性能测试我理解是必须要有实现代码之后才能进行的，已经花了很多时间和精力去实现了，然后性能测试不过，不是很浪费时间？

但是也并不是说做了时间空间复杂度分析之后就可以保证性能测试能过，但是可以降低这样的概率，减少返工可能性。况且掌握了方法之后，时间复杂度分析并不是那么难的事情。
2018-09-26
 作者回复
理解的没错

2018-09-26


蝴蝶

0
看完了，立个Flag,文章出的当天一定看完。
2018-09-26

yeStwind

0
王老师，第二个例子，第 6、7 行代码循环执行了 n2遍，所以需要 2n2 * unit_time 的执行时间，这句没看懂。我理解5、6、7行分别执行了n次，时间复杂度应该是n的立方。

极客时间版权所有: https://time.geekbang.org/column/article/40036
2018-09-26

Andy

0
在不考虑i业务意义，只从分析和理解对数阶时间复杂度的角度出发，个人觉得将原函数进行如下转换更容易理解为什么该算法的时间复杂度为O(log2(n))。
i=1; i=0;
while (i <= n) { => while (i <= log2(n)) {
i = i * 2; i++;
} }
个人愚见，不对之处请老师同学们指正。
2018-09-26
 作者回复
看起来似乎有道理 不过我得再想想你这个有没有规律

2018-09-26


thinkings

0
i=1; 
while (i <= n) {
i = i * 2
}
按照文章中的分析方法，每行代码的执行时间是uint_time，代码中执行次数最多的是
while (i <= n) {
i = i * 2
}；而这个代码每次循环的复杂度是2，即N次循环是2n，即最后复杂度是O(n);
是不是应该这样理解更准确呢？
即
i=1; 
while (i <= n) {
i = i * 2
}
和
i=1; 
while (i <= n) {
i = i + 2
}
复杂度是否应该是一样的？
2018-09-26

拉欧

0
复杂度分析是分析算法效率的关键
2018-09-26

LeonZ

0
谢谢！讲得比我老师清楚，开心
2018-09-26

ComputerGeek

0
时间复杂度和空间复杂度分析肯定是有必要的，一个节省CPU时钟周期，一个节省内存。要想写出高效的代码，二者缺一不可！
2018-09-26

爱学习

0
前几天看复杂度分析，一头雾水，今天看老师写的，领悟很多，再看几遍，争取拿下
2018-09-26

by

0
老师，开发中可能会遇到集合里是对象，对象里有集合的情况，需要获取每个对象里的集合的每个值做判断，这样得需要2层for，时间复杂度也就是n的2次方，知道复杂度很大，但是不得不这么做，岂不是很纠结？还有一个问题就是，如果知道这个集合里的对象大小很小循环次数少，这样的情况呢？
2018-09-26

火山飘雪

0
性能测试和时间复杂度并不冲突，性能测试是对项目做整体的耗时监测，而时间复杂度的分析是对具体代码端的执行效率分析，再者文中也提到了性能测试是跟平台有关的，而时间复杂度分析是跟平台无关的。学会并掌握了时间复杂度的分析方法，形成一种思想，在编写代码时就会把执行效率考虑进去了。
2018-09-26

撒旦CC

0
为什么用O来表示时间复杂度呢，而不是其他符号？
2018-09-26

code047

0
打卡
2018-09-26

李简单

0
老师，如果时间复杂度只考虑最大变化量的话，像T(n)=O(2n),T(n)=O(2n^2)。n前面的2需要考虑吗？
2018-09-26

…

0
我们知道，对数之间是可以互相转换的，log3n 就等于 后面这块有个小错。
2018-09-26

ACE~洛洛

0
首先，计算机的资源是有限的；我们要尽可能的节约计算机的资源但是同时也要在性能上得到最大的优化，项目做出来的实际性能测试和我们分析的性能有着不可分割的关系，因为性能测试这工作是要从每一段代码进行出发考虑，才能达到整体的优化，如果光靠后期测试来评估，那么在后期提升性能上就会很艰巨，所有在写代码的时候进行时间空间复杂度分析，有助于我们实时的把控资源效率，降低后期维护的工作量
2018-09-26

涛

0
讲的非常好，下面说老师讲的有问题的，请私下给老师说，不要误导别的同学。
2018-09-26

不许联想

0
这才是我要的，这才是科学方法论
2018-09-26

linhaixiaohuo

0
买了本算法导论看，里面公式多，少例子，老师的更通俗易懂的讲解刚好能够相辅相成的学懂。
2018-09-26

亢龙有悔

0
内容细致入微，比书上写的浅显易懂多了。
2018-09-26

Northern

0
渐进时间复杂度
2018-09-26