[RePractise –](http://repractise.phodal.com/#%E5%BC%95%E8%A8%80)

## 关于作者

黄峰达（Phodal Huang）是一个创客、工程师、咨询师和作家。他毕业于西安文理学院电子信息工程专业，现作为一个咨询师就职于 ThoughtWorks 深圳。长期活跃于开源软件社区 GitHub，目前专注于物联网和前端领域。

作为一个开源软件作者，著有 Growth、Stepping、Lan、Echoesworks 等软件。其中开源学习应用 Growth，广受读者和用户好评，可在 APP Store 及各大 Android 应用商店下载。

作为一个技术作者，著有《自己动手设计物联网》（电子工业出版社）、《全栈应用开发：精益实践》（电子工业出版社，正在出版）。并在 GitHub 上开源有《Growth: 全栈增长工程师指南》、《GitHub 漫游指南》等七本电子书。

作为技术专家，他为英国 Packt 出版社审阅有物联网书籍《Learning IoT》、《Smart IoT》，前端书籍《Angular 2 Serices》、《Getting started with Angular》等技术书籍。

他热爱编程、写作、设计、旅行、hacking，你可以从他的个人网站：https://www.phodal.com/ 了解到更多的内容。

其它相关信息：

微博：http://weibo.com/phodal

GitHub： https://github.com/phodal

知乎：https://www.zhihu.com/people/phodal

SegmentFault：https://segmentfault.com/u/phodal

当前为预览版，在使用的过程中遇到任何问题请及时与我联系。阅读过程中的问题，不妨在 GitHub 上提出来： Issues

阅读过程中遇到语法错误、拼写错误、技术错误等等，不妨来个 Pull Request，这样可以帮助到其他阅读这本电子书的童鞋。

我的电子书：

《GitHub 漫游指南》

《我的职业是前端工程师》

《Serverless 架构应用开发指南》

《Growth: 全栈增长工程师指南》

《Phodal’s Idea 实战指南》

《一步步搭建物联网系统》

《RePractise》

《Growth: 全栈增长工程师实战》

我的微信公众号:

作者微信公众号：phodal-weixin

作者微信公众号：phodal-weixin

支持作者，可以加入作者的小密圈:

小密圈

小密圈

或者转账：

支付宝 微信

## 引言

回到一年前的今天 (2014.09.29)，一边在准备着去沙漠之旅，一边在准备国庆后的印度培训。

当时我还在用我的 Lumia 920，上面没有各式各样的软件，除了我最需要的地图、相机。所以，我需要为我的手机写一个应用，用于在地图上显示图片信息及照片。

今天 Github 已经可以支持 geojson 了，于是你可以看到我在之前生成的 geojson 在地图上的效果 gps.geojson。

Re-Practise

在过去的近一年时期里，花费了很多时间在提高代码质量与构建架构知识。试着学习某一方面的架构知识，应用到某个熟悉领域。

所谓的一万小时天才理论一直在说明练习的重要性，你需要不断地去练习。但是并不是说你练习了一万小时之后就可以让你成为一个专家，而练习是必须的。

让我想起了在大学时代学的 PID 算法，虽然我没有掌握好控制领域的相关理论及算法，但是我对各种调节还算有点印象。简单地来说，我们需要不断调整自己的方向。

现在还存在的那些互联网公司或者说开源项目，我们会发现两个不算有趣的规律：

一个一直在运行的软件。

尝试了几个产品，最后找到了一个合适的方向。

我发现我属于不断尝试地类型。一直想构建一个开源软件，但是似乎一直没有找对合理的用户？但是，我们会发现上述地两者都在不断地 retry，不断地 retry 归根于那些人在不断的 repractise。与之成为反例的便是：

一个成功发布几次的软件，但是最后失败了

尝试了不同的几个产品，但是失败了

所谓的失败，就是你离开人世了。所以，在我们还活着的时候，我们总会有机会去尝试。在那之前，我们都是在不断地 re-practise。

这让我想到了 Linux，这算是一个不错地软件，从一开始就存活到了现在。但是有多少开源软件就没有这么幸运，时间在淘汰越来越多的过去想法。人们创造事物的能力也越来越强，但是那只是因为创造变得越来越简单。

在我们看到的那些走上人生巅峰的 CEO，还都在不断地 re-practise。

技术与业务

于是，我又再次回到了这样一个现实的问题。技术可以不断地练习，不断地调整方向。但是技术地成本在不断地降低，代码的长度在不断地降低。整个技术的门槛越来越低，新出现的技术总会让新生代的程序员获利。但是不可避免地，业务地复杂度并没有因此而降低。这就是一个复杂的话题，难道业务真的很复杂吗？

人们总会提及写好 CSS 很难，但是写好 Java 就是一件容易的事。因为每天我们都在用 Java、JavaScript 去写代码，但是我们并没有花费时间去学。

因为我们一直将我们的时候花费的所谓的业务上，我们可以不断地将一些重复的代码抽象成一个库。但是我们并没有花费过多的时间去整理我们的业务，作为程序员，我们切换工作很容易只是因为相同的技术栈。作为一些营销人员，他们从一个领域到一个新的领域，不需要过多的学习，因为本身是相通的。

技术本身是如此，业务本身也是如此。

从技术到技术 - 领域是一条难走通的路？

资讯爆炸

回顾到近几年出现的各种资讯程序 —— 开发者头条、极客头条、掘金、博乐头条等等，他们帮助我们的是丰富我们的信息，而不是简化我们的信息。

作为一个开发人员，过去我们并不需要关注那么多的内容。如果我们没有关注那么多的点，那么我们就可以集中于我们的想法里。实现上，我们需要的是一个更智能的时代。

业务本身是一种重复，技术本身也是重复的。只是在某个特定的时刻，一个好的技术可以帮助我们更好地 Re-Practise。如推荐算法本身依赖于人为对信息进行分类，但是我们需要去区分大量地信息。而人本身的经历是足够有险的，这时候就需要机器来帮我们做很多事。

今天我在用 MX5，但是发现不及 Lumia 1020 来得安静。功能越强大的同时，意味着我在上面花费的时间会更多。事情有好的一面总会有不好的一面，不好的一面也就意味着有机会寻找好的一面。

我们需要摒弃一些东西，以重新纠正我们的方向。于是，我需要再次回到 Lumia 1020 上。

Lost

一开始就输在起跑线上

这是一个很有意思的话题，尽管试图将本章中从书中删除，但是我还是忍了下来。如果你学得比别人晚，在很长的一段时间里 (可能直到进棺材) 输给别人是必然的 —— 落后就要挨打。就好像我等毕业于一所二本垫底的学校里，如果在过去我一直保持着和别人 (各种重点) 一样的学习速度，那么我只能一直是 Loser。

需要注意的是，对你来说考上二本很难，并不是因为你比别人笨。教育资源分配不均的问题，在某种程度上导致了新的阶级制度的出现。如我的首页说的那样: THE ONLY FAIR IS NOT FAIR—— 唯一公平的是它是不公平的。我们可以做的还有很多 ——CREATE & SHARE。真正的不幸是，因为营养不良导致的教育问题。如果你还有机会正常地思想，那说明这个世界对你还是公平的。

前端篇：前端演进史

细细整理了过去接触过的那些前端技术，发现前端演进是段特别有意思的历史。人们总是在过去就做出未来需要的框架，而现在流行的是过去的过去发明过的。如，响应式设计不得不提到的一个缺点是：他只是将原本在模板层做的事，放到了样式（CSS）层来完成。

复杂度同力一样不会消失，也不会凭空产生，它总是从一个物体转移到另一个物体或一种形式转为另一种形式。

如果六、七年前的移动网络速度和今天一样快，那么直接上的技术就是响应式设计，APP、SPA 就不会流行得这么快。尽管我们可以预见未来这些领域会变得更好，但是更需要的是改变现状。改变现状的同时也需要预见未来的需求。

什么是前端？

维基百科是这样说的：前端 Front-end 和后端 back-end 是描述进程开始和结束的通用词汇。前端作用于采集输入信息，后端进行处理。计算机程序的界面样式，视觉呈现属于前端。

这种说法给人一种很模糊的感觉，但是他说得又很对，它负责视觉展示。在 MVC 结构或者 MVP 中，负责视觉显示的部分只有 View 层，而今天大多数所谓的 View 层已经超越了 View 层。前端是一个很神奇的概念，但是而今的前端已经发生了很大的变化。

你引入了 Backbone、Angluar，你的架构变成了 MVP、MVVM。尽管发生了一些架构上的变化，但是项目的开发并没有因此而发生变化。这其中涉及到了一些职责的问题，如果某一个层级中有太多的职责，那么它是不是加重了一些人的负担？

前端演进史

过去一直想整理一篇文章来说说前端发展的历史，但是想着这些历史已经被人们所熟知。后来发现并非如此，大抵是幸存者偏见 —— 关注到的都知道这些历史。

数据 - 模板 - 样式混合

在有限的前端经验里，我还是经历了那段用 Table 来作样式的年代。大学期间曾经有偿帮一些公司或者个人开发、维护一些 CMS，而 Table 是当时帮某个网站更新样式接触到的 ——ASP.Net（maybe)。当时，我们启动这个 CMS 用的是一个名为 aspweb.exe 的程序。于是，在我的移动硬盘里找到了下面的代码。

<TABLE cellSpacing=0 cellPadding=0 width=910 align=center border=0>

  <TBODY>

  <TR>

    <TD vAlign=top width=188><TABLE cellSpacing=0 cellPadding=0 width=184 align=center border=0>

        <TBODY>

        <TR>

          <TD><IMG src="Images/xxx.gif" width=184></TD></TR>

        <TR>

          <TD>

            <TABLE cellSpacing=0 cellPadding=0 width=184 align=center 

            background=Images/xxx.gif border=0>

虽然，我也已经在 HEAD 里找到了现代的雏形 ——DIV + CSS，然而这仍然是一个 Table 的年代。

<LINK href="img/xxx.css" type=text/css rel=stylesheet>

人们一直在说前端很难，问题是你学过么？？？

人们一直在说前端很难，问题是你学过么？？？

人们一直在说前端很难，问题是你学过么？？？

也许，你也一直在说 CSS 不好写，但是 CSS 真的不好写么？人们总在说 JS 很难用，但是你学过么？只在需要的时候才去学，那肯定很难。你不曾花时间去学习一门语言，但是却能直接写出可以 work 的代码，说明他们容易上手。如果你看过一些有经验的 Ruby、Scala、Emacs Lisp 开发者写出来的代码，我想会得到相同的结论。有一些语言可以让写程序的人 Happy，但是看的人可能就不 Happy 了。做事的方法不止一种，但是不是所有的人都要用那种方法去做。

过去的那些程序员都是真正的全栈程序员，这些程序员不仅仅做了前端的活，还做了数据库的工作。

Set rs = Server.CreateObject("ADODB.Recordset")

sql = "select id,title,username,email,qq,adddate,content,Re_content,home,face,sex from Fl_Book where ispassed=1 order by id desc"

rs.open sql, Conn, 1, 1

fl.SqlQueryNum = fl.SqlQueryNum + 1

在这个 ASP 文件里，它从数据库里查找出了数据，然后 Render 出 HTML。如果可以看到历史版本，那么我想我会看到有一个作者将 style=「」的代码一个个放到 css 文件中。

在这里的代码里也免不了有动态生成 JavaScript 代码的方法：

show_other = "<SCRIPT language=javascript>"

show_other = show_other & "function checkform()"

show_other = show_other & "{"

show_other = show_other & "if (document.add.title.value=='')"

show_other = show_other & "{"

