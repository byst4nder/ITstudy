针对于同样的话题，开始了解其中的一些问题。当敏捷的思想贯穿于开发过程时，我们不得不面对持续集成与发布这样的问题。我们确实可以在不同的服务下工作，然而当我们需要修改 API 时，就对我们的集成带来很多的问题。我们需要同时修改两个 API！我们也需要同时部署他们！

混合微服务

在设计所谓的「Next-Generation CMS」，即 Echoes CMS 的时候，对于我这种懒得自己写 Django App 的人来说，通过我会去复制别人的代码，于是我继续在 Github 上漫游。接着找到了 DjangoProject.com 的源码，又看了看 Mezzanine (ps: 我博客用的就是这个 CMS)。于是从 DjangoProject 复制了 Blog 的代码，从 Mezzanine 复制了 conf 的代码，然后就有了 Echoes 的 codebase。然后，继之前的文章 (《微服务的小思考》我想了想，这不就是我想要的模型么？

微服务与 Django

Django 应用架构 Django MVC 结构如下如示:

Django MVC

Django MVC

然后，记住这张图，忘记上面的 MVC，Django 实际上是一个 MTV

Model

Template

View

主要是 Django 中的 views.py 通常是在做 Controller 的事。

然而对于一个 Django 的应用来说，他的架构如下所示:

Django apps architecture

Django apps architecture

Django 的每个 App 就代表着程序的一个功能。每个 App 有自己的 models、views、urls、templates 所以对于一个 app 来说他的结构如下:

.

|______init__.py

|____models.py

|____tests.py

|____views.py

如果是新版的 Django 那么它的结构如下:

.

|______init__.py

|____admin.py

|____migrations

| |______init__.py

|____models.py

|____tests.py

|____views.py

上面少了 templates，最后会有一个总的 URL，即第一张图的 URL Dispatcher。接着，让我们看看微服务是怎样的。

一个典型的微服务如下所示:

microservices architecture

microservices architecture

有不同的技术栈 python、spring、scala，但是他们看上去和 Django 应用的图差不多，除了数据库不一样。

与其将复杂的测试、逻辑部分变得不可测，不如把这些部分放置于系统内部。

Linux OS Hybrid

Linux OS Hybrid

当我们在我们的服务器上部署微服务的时候，也就意味着实现所以的服务都是在我们系统的内部，我们有一个 Kernel 以及他们的 Kernel Moduels，即微服务群们。他们调用 DB，或者某些第三方服务。

System Libraries 相当于我们的 URL Dispatcher。而我们的 URL Dispatcher 实际上所做的便是将各自调用的服务指向各自的 app。

这样我们即可以解决部署的问题，又可以减少内部耦合。

其他

我猜，微服务的流行是因为程序员可以欢乐地使用自己的语言，哪怕是 Logo。

参考

Microservices - Not A Free Lunch!

Microservices

前后端篇

前后端分离

这是一个很古老的话题，对于大公司来说就是部门大了，需要拆分。因此开始之前，先提一下「康威定律」：

Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations.

换成中文，即：设计系统的组织，其产生的设计和架构等价于组织间的沟通结构。上图

Conway

Conway

这张图可以解释相当多的软件开发过程中的问题，而我们知道软件开发的主要问题是沟通问题。组织结构影响了我们的沟通结构，进而影响了我们的软件系统结构。好吧，我承认可能离题有点远。不过，我想说的是组织结构可能不允许我们做出一些好的系统架构。

如我们在《RePractise 前端篇：前端演进史》中提到的那样：我们已经有了一个桌面版网页，然后我们打造了一个 APP。然而，总有些客户想在手机上浏览但是又不想下 APP，我们就需要一个移动版。为什么会这样？因为用户已经被养成了这样的习惯，大部分的网站提到了桌面版、移动版、APP。要维护这样的三个不同的系统，对于大部分的业务公司来说成本太高了。

于是，大部分公司来说解决方案就是 后台 + 大前端 （桌面前端、移动 Web、手机 APP）。Angular 和 React 就是为了解决这样的问题，而出现了不同的解决方案 —— 基于 Angular.js 的混合应用框架 Ionic、以及 React Native。不过在当前，我对 React Native 的共用 UI 还是持观望态度。有人可能会提到 Vue 和 Weex，但是我觉得并没有那么好用。或许是因为我接触 React 比较早，我觉得 Vue 的语法四不像。

在这样的情形下，我们只需要几个后台开发人员和几个前端开发人员就可以完成系统的设计了。这种前端开发人员就是最近几年人们「最想要」的。

单页面应用后台渲染

我已经想不到一个好的关于前端分享的主题了，于是联想到最近想要做的一件事，就想到了这个标题。或许这是一个好的主题，又或许这不是一个好的主题。但是至少我可以 Share 一下我的经验：

基于 Mustache 模板引擎的前后台渲染。

基于 PreRender 方式的 Angular.js 应用的后台渲染

服务端渲染的 React

开始之前，我希望即使你们需要后台渲染，你们也应该前后端分离！由后台来提供 API 数据，前端用自己的后台来渲染页面。听上去有点绕，简单的来说就是不要把大量的业务逻辑放前台来，只把显示逻辑放在前台上。这样一来，即使有一天我们换了新的前端，如移动应用，那么我们的后台也是可用的。。

前后台渲染同一模板

我接触的第一个 SPA 应用是一个基于 Spring MVC 和 Backbone 的移动网站，但是它比一般的 SPA 应该要复杂 —— 由于 SEO 的缘故，它需要支持后台渲染。

当搜索引擎通过 URL 访问我们的网站的时候，我们就需要返回相应的 HTML。这意味着我们需要在后台有对应的模板引擎来支持，而由于 SPA 的性质又决定了，这需要使用一个纯前端的模板引擎。因此，我们并不能使用两个模板引擎来做这件事，维护两套模板注定会是一件痛苦的事，并且当时还没有 React 这种模板引擎在。不过，后来我们发现维护两种不同的渲染方式也是一件痛苦的事。因此，我们就会有了类似于下图的架构：

Spring MVC Backbone

Spring MVC Backbone

我们在后台使用 Spring MVC 作为基础架构、Mustache 作为模板引擎，和使用 JSP 作为模板引擎相比没有多大的区别 —— 由 Controller 去获取对应的 Model，再渲染给用户。多数时候搜索引擎都是依据 Sitemap 来进行索引的，所以我们的后台很容易就可以处理这些请求。同样的当用户访问相应的页面的时候，也返回同样的页面内容。当完成页面渲染的时候，就交由 Backbone 来处理相应的逻辑了。换句话来说，从这时候它就变成了一个单页面应用。

尽管这是一个三年年前开始的项目，但是在今天看来，这种做法仍然相应地有趣： 大部分的单页面应用只有一个首页，并由 HTTP 服务器（如 Nginx）、Web 框架（如 Express、Koa）对路由做一些处理，可以让用户通过特定地 URL 访问特定地页面。而我们需要保证所有的用户访问地都是真实的页面，既然 JavaScript 没有加载完，用户也能看到完整的页面。

在这个项目里，最大的挑战就是如何保证后台渲染和前台渲染的业务逻辑是一样的。如当我们想要针对不同的产品显示不同的内容时，我们就需要在 JavaScript 中赋予一些逻辑，我们还需要在 Java 在有同样的逻辑。相比于在同一个代码里有桌面版、移动版来说，逻辑有更加复杂的趋势 —— 因为在这种情况下，我们只需要维护两个不同的模板即可。而在 SPA 的情况下，我们要维护两套逻辑。后来，这个框架交由下文中的 React 与响应式设计重写。

在今天你仍然可以使用这样的方式来渲染，JDK 1.8 自带了嵌入式 JavaScript 引擎 Nashorn，完成支持 ECMAScript 5.1 规范以及一些扩展。

PreRender 方式

在我们重新设计系统的时候，曾经考虑过类似的做法。将我们的所有页面渲染成静态的 HTML，然后用爬虫抓取我们的所有页面，再上传到 AWS 即可。当时我们咨询了其他小组的做法，其中有一个小组正是采用了这种 PreRender 的方式 —— 在本地运行起一个 Server，由 PhantomJS 来渲染页面，再保存为对应的 HTML。

PreRender 就是预先渲染好 HTML，并针对于爬虫返回特定的 HTML。（PS：不过作为一个很有经验的 SEO 开发人员，我一点不喜欢这种作法。要知道 Google 有时候会模拟成真实的用户，不带有爬虫的那些参数和标志，去访问页面。如果你返回给 Google 的两个页面差异太大 —— 可能是你忘记更新了频率，那么 Google 可能就会认为你在作弊。）

PreRender

PreRender

对于一般用户来说就不会返回后台渲染的结果了：

Angular PreRender

Angular PreRender

和上面的第一种情况相比，这种作法可以大大减少服务器地负担，并且可以直接交由 CDN 就可以了。这时我们只需要考虑要渲染哪些页面即可，对于数据量比较少的网站来说这是一个不错的做法，但是多了就不一样了。

对于我们来说，有两个问题：一个是速度的问题，他们有上万条数据就需要近一天左右的时间来生成（渲染时间长），而我们有上百万条数据。二是数据的实时问题，我们的产品数据每天都会更新一次。

React

对于使用 React 的开发人员来说，要处理后台渲染就是一种更简单的事，毕竟 React 中提供了一个方法叫 renderToString ()。我们所要做的就是用 Express 或者 Koa 对路由进行处理，然后返回对应的内容即可：

React Server Side Render

React Server Side Render

然后，剩下的事都可以交由 React 来解决，就是这么简单。

因为在这个时候我们在前后台使用的都是 JavaScript，我们可以在这个地方直接实现对数据库的操作，就会出现我们在开头说到的前后台分离的问题。这样做并不合理，后台只应该返回我们所需要的数据，并且它可以随时被其他语言替换掉。

从真实世界到前后端

RePractise 终于又迎来了新的一篇，要知道上一篇可是在半年前呢 ——《Repractise 前端篇：前端演进史 》。照 RePractise 惯例，这又是一篇超长文以及个人的扯淡过程。

当然这也是一个神奇的标题，因为我已经想不到一个好的名字了，不过先这样吧。这篇文章算是我最近两三个月的一篇思考。在上一个项目的打杂生涯里，我开始去学习架构方面的知识，开始去接触 DDD 的思想。从编码到架构，再回到实际的编码中，总会有很多的灵感闪现。

从真实世界到前后端

我们所写的代码在某种程度上都反应了真实世界的模型、行为等等。一个比较常见的模型就是：购物模型。同时，这也是一个很好的展示前后端分离的模型。

store-model.jpg

store-model.jpg

（PS: 原谅我的画工）

便利店与售货员

对于一般的便利店来说，只有一个销售员，ta 负责整个商店的一系列事务。从某种意义上来说，ta 就是整个系统的核心，负责了系统的业务和事件。

一般来说在一个购买流程里，会有三个主要的人或物：

售货员。一般来说，ta 只会在最后的结账流程中出以及顾客询问时做出响应。

货物。没啥可解释的，就是一堆模型。0

顾客 。浏览商店、对比商店、blabla 等等。

如果我们要构建这样一个系统，我们只需要区分出系统的各个部分，那么剩下的事情就变得很简单了。

domain.jpg

domain.jpg

由于整个系统仍然是相当复杂的，我们在这里只关注于用户购买的过程。

模型、领域、抽象

从购买过程来说，顾客所要做的事情就是：

浏览、对比商品

加到购物车

结账、付钱

对应的也就是有模型、领域和抽象几个概念。

模型

这些商品实现上就是相当于一系列的模型及数据。在用户购买之前，我们只需要一个去获取一个个的数据接口，并展示这些数据。

对应于这些商品要建起 Schema 来是一件容易的事。作为一个商品，他们都拥有着一些共同的元素：price, name, description, location, manufacturer 等等的信息。其中一些属性，还会有复杂的对应关系：

Product Schema

Product Schema

这些需要在我们建立数据库的时候，尽可能地明确好这些关系。由于业务本身是难以预料的，你可能和我们之前的项目一样需要一个 addtionInfo 的字段，来用 JSON 存储一些额外的字段。当然如果你使用的是 NoSQL，那就再好不过了。

最好你还使用了读写分离架构，一种比较常见的用法就是 CMS 网站，人们使用数据库来存储内容，使用静态页面来展示这些内容。比较好的实践还有 CQRS (Command Query Responsibility Segregation，命令查询职责分离模式)，用于 CRUD（增、删、改，当然也可以查）的 Command，以及 Query 的查询分开。简单的来说，就是有两个不同的数据持久化中心：

Basic CQRS

Basic CQRS

这一点特别适合于那些查询、搜索为主的网站，如淘宝。哈哈，我们离题有点远了，总之我们就是在这里提供了数据库的灵气，并对一些字段做一些简单的处理。听上去感觉 GraphQL 更适合做这样的事。

领域

而顾客及售货员在整个过程中做的事情就是领域 (Domain，《实现领域驱动设计》)—— 即一个组织所做的事情以及其中所包含的一切。对于顾客和售货员来说，他们在各自的领域里做着不同的事。

对于顾客来说，其整个浏览过程，基本上都是在前端完成：

搜索、查找商品 -> 获得商品列表

查找商品详细

切换到下一个商品

这个场景下就特别适合于上面说到的读写分离架构。在浏览过程中，对用户的数据进行监控，以用于了解用户的行为，改善用户体验。这也是很常见的功能，或者说他们是无处不在的模式：

结果页 / 列表页

详情页

随后的用户收藏、添加到购物车、购买、交付等流程都需要与后台进行更紧密的交付。而这些都和售货员都有紧密的关系，而这些就不是一种简单的事。

从用户购买完成以后，剩下的就是一堆琐碎的事了，而这些都是由后端来完成的：

订单子系统

物流系统

发票系统

支付系统

等等。

对于用户来说，一种最简单的情况就是亚马逊，你只需要按一下「一键下单」即可。不需要关心后面的操作了，同样的这也适合于我们的业务场景。

抽象

抽象本来不打算写的，但是后来想了想还是写。总的来说整个过程还是需要相对比较好的抽象能力，要不我就很难讲述清楚这里面的过程了。

抽象是很神奇的东西，也可以分为几个不同的境界 —— 但是我也不知道有几个境界，简单的来说就是不同的人看上去就有不同的东西。如有的人看到下面的画就是一坨 shit—— 还不如小学生画的呢，有的人就会惊呼大师。

星空

星空

反正，我也很看不懂。这一点倒类似于最初我对设计模型的理解一样：

一开始不以为然

然后发现很棒

接着使用过度

最后就和最好的编程器 Emacs 一样

Editor Learning Curve

Editor Learning Curve

这些都在随着编程生涯的展开而发生一些变化，我们不断地抽象出一些概念，以至于到了最后刚进入这个行业的人都看不懂。但是，这些都是一点点在一层层抽象的基础上产生的。

Needs

Needs

所以，我就把这一小小节扯完了，反正我是不想说得太抽象了。接着，让我们再扯点技术性的话题。

前后台分离：后台

典型的 Web 应用框架就是类似于这样的架构：

Spring Web App Architecture

Spring Web App Architecture

又或者是 MVC 架构，但是这已经不重要了。我们都前后端分离了，是时候把 V 层去掉了。

MVC Role Diagram

MVC Role Diagram

我们继续以上面的浏览来购买流程来做扯淡，后台除了提高上面的商品信息以外，在购买的时候还需要对用户进行授权。当然注册就是另外一个话题了，另外一个很大的话题。

所有的这些我们都可以向前台提供对应的 API 即可。理想的情况下，我们对应于不同的模块可以有不同的服务：

MicroServices

MicroServices

但是现实并不总是这么美好的，而在我们当前情况下则可以 —— 毕竟所有的用户都应该能浏览所有的商品，这时就不需要做特殊的处理了。

在这个过程中，我们还有一系列的操作需要在后台来完成。不过，这些都可以在内部中完成的。而复杂的过程，实际上还存在于前端的逻辑当中。

前后台分离：前端

开始时，我们需要这样做去获取一个个的商品详情。这些数据也可以在返回页面模板的时候，直接将 API 数据填充到 HTML 中 —— 带后台渲染的 React 都是这样做的。然后在用户浏览的过程中，我们还需要遵循这样的数据流程：

获取数据。无论是 Ajax，还是新的 Fetch API 都可以做这样的事。

处理数据。依据于业务的需要对数据进行一些特殊的处理，如修改时间、价格的显示格式，描述的长度等等。

显示数据。只需要一个简单的模板引擎，过去的 JSP、Mustache、今天的 React 都在做同样的事。

而在进入这个页面之前，我们还需要关注几个基本的元素，虽然这些都是将由框架来解决的。

路由。无论你遵不遵循 REST 的实践，我们只需要给对应的页面一个 URL 即可。相应的如果我们需要 SEO，那么我们也需要在后台有一个对应的 URL。理想的情况下，他们应该是由一个 URL。

模块化。从过去 Require.js 的火热，到今天的各式各样的框架内建的模块化框架，他们解决都是一个问题：代码度的问题。这一点和后台采用的微服务架构的缘由好像是一样。

控制器。我也想不起来为什么控制器非在这里不可，但是我想只有这样，我才能快速地找到这个文件。

作为前端，我们不仅仅要负责的页面的美观，还要对用户的事件做出响应，并且做好用户体验。

事件

这就是最近火热的关于 DOM 的讨论的原因，当顾客想了解一下一些不一样东西的时候，我们就需要对 DOM 进行操作。

我突然就有一个问题了，你真的有那么多 DOM 需要操作么？你又不是 Facebook，有那么多的 Timeline 和事件流。还有你的用户体验是不是做得足够好了？顺便再补一刀，如果你使用了 React，并且没有进行前后端分离，那就等下一个恶梦。

最后，当用户买下东西的时候，我们也需要这样的交互流程。

RePractise

因为最近我对 DDD 又有了一些想法，还在想着如何直接由真实世界来建模。顺便整理了这些思路到一起，但是好似这样的设计更简单。

重构篇

什么是重构？

重构，一言以蔽之，就是在不改变外部行为的前提下，有条不紊地改善代码。

相似的

代码重构（英语：Code refactoring）指对软件代码做任何更动以增加可读性或者简化结构而不影响输出结果。

网站重构

