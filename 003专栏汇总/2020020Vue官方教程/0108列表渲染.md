列表渲染

文档视频教程帮助工具核心插件信息
          
          教程
          
            
          
        基础深入了解组件过渡 & 动画可复用性 & 组合工具规模化内在迁移更多用  把一个数组对应为一组元素我们可以用 v-for 指令基于一个数组来渲染一个列表。v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组，而 item 则是被迭代的数组元素的别名。结果：在 v-for 块中，我们可以访问所有父作用域的属性。v-for 还支持一个可选的第二个参数，即当前项的索引。结果：你也可以用 of 替代 in 作为分隔符，因为它更接近 JavaScript 迭代器的语法：在  里使用对象你也可以用 v-for 来遍历一个对象的属性。结果：你也可以提供第二个的参数为 property 名称（也就是键名)：还可以用第三个参数作为索引：在遍历对象时，会按 Object.keys(）的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下都一致。维护状态当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用「就地更新」的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。这个类似 Vue 1.x 的 track-by="$index"。这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态（例如：表单输入值）的列表渲染输出。为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性：建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。因为它是 Vue 识别节点的一个通用机制，key 并不仅与 v-for 特别关联。后面我们将在指南中看到，它还具有其它用途。不要使用对象或数组之类的非基本类型值作为 v-for 的 key。请用字符串或数值类型的值。更多 key attribute 的细节用法请移步至  的 API 文档。数组更新检测变异方法（mutation method)Vue 将被侦听的数组的变异方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：你可以打开控制台，然后对前面例子的 items 数组尝试调用变异方法。比如 example1.items.push({ message: 'Baz' })。替换数组变异方法，顾名思义，会改变调用了这些方法的原始数组。相比之下，也有非变异（non-mutating method）方法，例如 filter()、concat(）和 slice(）。它们不会改变原始数组，而总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧数组：你可能认为这将导致 Vue 丢弃现有 DOM 并重新渲染整个列表。幸运的是，事实并非如此。Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的启发式方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。注意事项由于 JavaScript 的限制，Vue 不能检测以下数组的变动：举个例子：为了解决第一类问题，以下两种方式都可以实现和 vm.items[indexOfItem] = newValue 相同的效果，同时也将在响应式系统内触发状态更新：你也可以使用  实例方法，该方法是全局方法 Vue.set 的一个别名：为了解决第二类问题，你可以使用 splice：对象变更检测注意事项还是由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除：对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性。但是，可以使用 Vue.set(object, propertyName, value）方法向嵌套对象添加响应式属性。例如，对于：你可以添加一个新的 age 属性到嵌套的 userProfile 对象：你还可以使用 vm.$set 实例方法，它只是全局 Vue.set 的别名：有时你可能需要为已有对象赋值多个新属性，比如使用 Object.assign(）或 _.extend()。在这种情况下，你应该用两个对象的属性创建一个新的对象。所以，如果你想添加新的响应式属性，不要像这样：你应该这样做：显示过滤/排序后的结果有时，我们想要显示一个数组经过过滤或排序后的版本，而不实际改变或重置原始数据。在这种情况下，可以创建一个计算属性，来返回过滤或排序后的数组。例如：在计算属性不适用的情况下（例如，在嵌套 v-for 循环中）你可以使用一个方法：在  里使用值范围v-for 也可以接受整数。在这种情况下，它会把模板重复对应次数。结果：在  上使用 类似于 v-if，你也可以利用带有 v-for 的 <template> 来循环渲染一段包含多个元素的内容。比如： 与  一同使用注意我们不推荐在同一元素上使用 v-if 和 v-for。更多细节可查阅风格指南。当它们处于同一节点，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。当你只想为项渲染节点时，这种优先级的机制会十分有用，如下：上面的代码将只渲染未完成的 todo。而如果你的目的是有条件地跳过循环的执行，那么可以将 v-if 置于外层元素（或 )上。如：在组件上使用 这部分内容假定你已经了解组件相关知识。你也完全可以先跳过它，以后再回来查看。在自定义组件上，你可以像在任何普通元素上一样使用 v-for 。2.2.0+ 的版本里，当在组件上使用 v-for 时，key 现在是必须的。然而，任何数据都不会被自动传递到组件里，因为组件有自己独立的作用域。为了把迭代数据传递到组件里，我们要使用 prop：不自动将 item 注入到组件里的原因是，这会使得组件与 v-for 的运作紧密耦合。明确组件数据的来源能够使组件在其他场合重复使用。下面是一个简单的 todo 列表的完整例子：注意这里的 is="todo-item" 属性。这种做法在使用 DOM 模板时是十分必要的，因为在 <ul> 元素内只有 <li> 元素会被看作有效内容。这样做实现的效果与 <todo-item> 相同，但是可以避开一些潜在的浏览器解析错误。查看 DOM 模板解析说明 来了解更多信息。