从 Vue Router 0.7.x 迁移

文档视频教程帮助工具核心插件信息
          
          教程
          
            
          
        基础深入了解组件过渡 & 动画可复用性 & 组合工具规模化内在迁移更多只有 Vue Router 2 是与 Vue 2 相互兼容的，所以如果你更新了 Vue，你也需要更新 Vue Router。这也是我们在主文档中将迁移路径的详情添加进来的原因。有关使用 Vue Router 2 的完整教程，请参阅 Vue Router 文档。Router 初始化 不再会有一个特殊的 API 用来初始化包含 Vue Router 的 app，这意味着不再是：你只需要传一个路由属性给 Vue 实例：或者，如果你使用的是运行时构建（runtime-only）方式：升级路径运行 迁移助手 找到 router.start 被调用的示例。Route 定义 路由现在被定义为一个在 router 实例里的一个  选项数组。所以这些路由：会以这种方式定义：考虑到不同浏览器中遍历对象不能保证会使用相同的 property 顺序，这种数组的语法可以保证更多可预测的路由匹配。升级路径运行 迁移助手 找到 router.map 被调用的示例。如果你需要在启动的 app 时通过代码生成路由，你可以动态地向路由数组推送定义来完成这个操作。举个例子：如果你需要在 router 被实例化后增加新的路由，你可以把 router 原来的匹配方式换成一个包括你新添的加路由的匹配方式：升级路径运行 迁移助手 找到 router.on 被调用的示例。router.beforeEach 现在是异步工作的，并且携带一个 next 函数作为其第三个参数。出于 Vue Router 和其他路由库一致性的考虑，重命名为 升级路径运行 迁移助手 找到 subRoutes 选项的示例。现在用一个路由定义的选项作为代替。举个例子，你将会更新：成像下面的 routes 配置里定义的样子：升级路径运行 迁移助手 找到 router.redirect 被调用的示例。现在是你进行 alias 操作的路由定义里的一个选项。举个例子，你需要在你的 routes 定义里将：配置这个样子：如果你需要进行多次 alias 操作，你也可以使用一个数组语法去实现：升级路径运行迁移助手找到 router.alias 被调用的示例。任意的 Route 属性现在任意的 route 属性必须在新 meta 属性的作用域内，以避免和以后的新特性发生冲突。举个例子，如果你以前这样定义：你现在需要把它更新成：如果在一个路由上访问一个属性，你仍然会通过 meta。举个例子：升级路径运行 迁移助手 找到任意的路由不在 meta 作用域下的示例。URL 中的 Query 数组 [] 语法当传递数组给 query 参数时，URL 语法不再是 /foo?users[]=Tom&users[]=Jerry，取而代之，新语法是 /foo?users=Tom&users=Jerry，此时 $route.query.users 将仍旧是一个数组，不过如果在该 query 中只有一个参数：/foo?users=Tom，当直接访问该路由时，vue-router 将无法知道我们期待的 users 是个数组。因此，可以考虑添加一个计算属性并且在每个使用 $route.query.users 的地方以该计算属性代替：Route 匹配路由匹配现在使用 path-to-regexp 这个包，这将会使得工作与之前相比更加灵活。一个或者更多的命名参数语法稍微有些许改变，所以以 /category/*tags 为例，应该被更新为 /category/:tags+。升级路径运行 迁移助手 找到弃用路由语法的示例。链接 v-link 指令已经被一个新的  组件指令替代，这一部分的工作已经被 Vue 2 中的组件完成。这将意味着在任何情况下，如果你拥有这样一个链接：你需要把它更新成：注意：<router-link>不支持 target="_blank" 属性，如果你想打开一个新标签页，你必须用<a>标签。升级路径运行 迁移助手 找到 v-link 指令的示例。v-link-active 也因为指定了一个在  组件上的 tag 属性而被弃用了。举个例子，你需要更新：成这个写法： <a>标签将会成为真实的链接（并且可以获取到正确的跳转)，但是激活的类将会被应用在外部的<li>标签上。升级路径运行 迁移助手 找到 v-link-active 指令的示例编程导航 为了与 HTML5 History API 保持一致性，router.go 已经被用来作为 后退/前进导航，用来导向特殊页面。升级路径运行 迁移助手 ，找到 router.go 和 router.push 指令被调用的示例。路由选择：Modes Hashbangs 将不再为谷歌需要去爬去一个网址，所以他们将不再成为哈希策略的默认选项。升级路径运行 迁移助手 找到 hashbang: false 选项的示。所有路由模型选项将被简化成一个单个的  选项。你需要更新：成这个写法：升级路径运行 迁移助手 找到 history: true 选项的示。所有路由模型选项将被简化成一个单个的  选项。你需要更新：成这个写法：升级路径运行 迁移助手 找到 abstract: true 选项的示例。路由选项：Misc 它已经被替换为可以接受一个函数的  选项，所以滑动行为可以完全的被定制化处理 - 甚至为每次路由进行定制也可以满足。这将会开启很多新的可能，但是简单的复制旧的行为：你可以替换为：升级路径运行 迁移路径 找到 saveScrollPosition: true 选项的示例。为了与 HTML 的 标签保持一致性，重命名为 base。升级路径运行 迁移路径 找到 root 选项的示例。由于 Vue 的过渡系统  transition control 的存在，这个选项将不再需要。升级路径运行 迁移路径 找到 transitionOnLoad: true 选项的示例。出于简化钩子的考虑被移除。如果你真的需要抑制过渡错误，你可以使用 … 作为替代。升级路径运行 迁移指令 找到 suppressTransitionError: true 选项的示例。路由挂钩 使用  这一组件进行替代。升级路径运行 迁移路径 找到 activate 钩子的示例。使用  在路由中作为替代。升级路径运行 迁移路径 找到 canActivate 钩子的示例。使用  或者  钩子作为替代。升级路径运行 迁移路径 找到 deactivate 钩子的示例。在组件中使用  作为替代。升级路径运行 迁移路径 找到 canDeactivate 钩子的示例。在新的 Vue 路由中将不再被使用。升级路径运行 迁移助手 找到 canReuse: false 选项的示例。$route 属性是响应式的，所以你可以就使用一个 watcher 去响应路由的改变，就像这样：升级路径运行 迁移助手 找到 data 钩子的示例。定义你自己的属性（例如：isLoading)，然后在路由上的 watcher 中更新加载状态。举个例子，如果使用 axios 获取数据：