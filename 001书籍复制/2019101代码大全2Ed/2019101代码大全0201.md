# 02 利用隐喻对编程进行更深刻的理解

相关章节——设计中的启发：「设计是一个启发过程」 见 7.5 节

计算机科学的语言可能是所有科学领域中最丰富的。想象一下。你走进一间干净整洁、温度严格控制在 68 F 的房间，在这里，你将会找到病毒、蠕虫、臭虫、炸弹、崩溃、火焰、扭曲的变形者、特洛伊木马和致命错误，在其它领域中，你会遇到这种情况吗？

这些形象的隐喻描述了特定的软件现象。同样形象的隐喻描述了更为广泛的现象，你可以利用它们来加深你对软件开发的理解。

本书其余部分与本章关于隐喻的论述无关，如果你想了解实质问题可以跳过这一章。但你要想对软件开发有更清楚的理解，请阅读这一章。

## 2.1 隐喻的重要性

重大发现往往是从类比中产生的。通过把一个你所陌生的事物与你所熟知的事物比较，你会对它有进一步的认识，从而形成你对它的独到的深刻理解，这种隐喻方法被称之「模型化」。在科学发展史上，充满了利用类比而产生的发现。化学家 Kekle 梦见一条蛇咬住了自己的尾巴，醒来后，他由此联想到苯的结构，提出了苯是环形分子的假说，这一假说在 1966 年被 Barbour 用实验所证实。

分子运动论是在 「保龄球」 模型上建立起来的。在这里，分子被假想为具有质量并且与保龄球一样相互之间进行完全弹性碰撞的小球，并且在此基础上，又产生了许多有用的模型。

光的波动理论是在与声音类比的基础上产生的。光与声都具有振幅（亮度与音量），频率（颜色与音调）和其它类似性质。这种类比是如此有效，以致于科学家们花费了大量时间来寻找像空气传播声音一样传播光的物质 「以太」，但他们从来也没能找到。有时如此有效的类比这次却导出了错误结果。

通常，模型的力量在于它能提供生动形象的概念而易被人整个接受。并提供特性、联系和附加的疑问，有时模型会提出令人困惑的问题，这时往往是由于模型被误解了，那些建筑 「以太」 的科学家们，就是因为误解了模型。

正如你所预料的，有些模型比其它的要好。好的模型要简单、与其它模型关联密切、能解释大部分实验事实和观测现象。

比如一个悬在铁链上来回晃动的大石头。在 Galileo 之前，Aristotelian 看到它时想到的是重物必然要从高处落下来停在低处，他认为石头是在克服阻力下落，而当 Galileo 看到同一现象时他认为自己看到了一个单摆，他认为石头是在不断地重复同一运动。

这两个模型所提供的信息是截然不同的。Aristotelian 认为石头是在下落，因而他关心的是石头的重量、升起的高度及停下所需的时间。而 Galileo 从单摆模型出发，他关心的是石头的重量、铁链的半径、石头的角位移及石头每摆一次所需要的时间。Galileo 之所以能发现单摆定律，就是因为他的模型与 Aristotelian 不同，从而导致他们提出了不同的问题。

隐喻对加深软件理解所做出的贡献，与它对其它领域所做出的贡献一样大。1973 年，在图灵奖颁奖演说中，Charles Bachman 叙述了从地心说向日心说转移的过程。Ptolemy 的地心说统治了近 1400 年。直到 1543 年，Copernicus 提出了日心说，这一思想模型的转变导致了一系列新星的发现，把月亮定义为卫星而不是行星，也改变了人类对自身在宇宙中地位的理解。

Bachman 把天文学中从地心说向日心说的转変，与 70 年代前期在计算机编程中的变化作了个对比。在当时，数据处理正从以计算机为中心向以数据库为中心进行转变。Bachman 指出，在旧的处理模式中，数据被当成是一个连续流过计算机的卡片流（以计算机为中心）；而在新的模式中，数据好比是一个水池，而计算机则偶尔涉足其中（以数据库为中心）。

今天，很难想象谁会认为太阳绕着地球转；也同样难以想象谁会把数据当成流过计算机的卡片流。在这两个例子中，旧的理论一旦被抛弃，很难想象有谁会再把它捡起来。具有讽刺意味的是，旧理论的相信者认为新理论荒唐可笑，就像我们今天看旧理论一样。

当日心说出现之后，地心说便成了那些相信它的天文学家的阻得。同样，计算机中心模式也已经成了那些相信它的计算机科学家的阻碍，因为我们现在已经有了数据库中心模式。

如果一旦看了新的模型，我们便说：「哦，当然正确的模型更有用，其余的都是错误的」，那只会降低模型的作用。因为这太偏激了。科学史并不是由一系列从 「错误」 模型到 「正确」 模型开关组成的，而是逐渐由 「坏的」 模型变为 「较好」 的模型，从包含面较窄到包含面较宽，从覆盖领域较少到覆盖领域较多。

事实上，很多被较好模型替代的旧模型仍然在发挥作用。例如，工程师们仍然在用牛顿力学进行工程计算，虽然它已经被相对论力学所取代。

软件科学是一门比其它学科年轻得多的学科，还很不成熟，远未形成一套标准的模型。所以，现在拥有的是大量相互矛盾的模型。这其中有些很好，有些则很差。因此，对这些模型理解得好坏，便决定了你对软件开发理解的好坏。

## 2.2 如何使用软件隐喻

软件隐喻更像是一束搜索灯光，而不是一张地图，它并不会告诉你到哪里去寻找答案；它只给你以启发，教你如何寻找答案，而不是像数学算法一样硬性规定出到哪里找出答案。






个公式是一套完整建立的、进行某一些任务的规则。它的结果是可以预测的、确定的，并不取决于运气。公式会告诉你直接从 A 点走到 B 点，中间不准绕路，不准随意顺便访问 C D、E 或 F 点，也不准停下来闻一下玫瑰花香或者喝杯咖啡什么的，一切必须按规定来。

启发是一种帮助你寻求答案的技术。它的结果往往和运气有关，因为它只告诉你如何去找，而并未告诉你应该找到些什么。它不会告诉你怎样直接从点 A 到点 B。甚至很可能它根本就不知道点 A 和点 B 在哪里。事实上，可以认为启发是一个穿着小丑儿外套的公式。它往往不可预测，更富有趣味，不会保证一定会发生或不会发生什么。

比如，开车去某人家的公式是这样的：沿 167 号公路向南到 Sumner，从 Bonney 湖出口向山上开 2,.4 英里，借助加油站的灯光向左拐，在第一个右转弯处向右转，再拐入通向褐色房子的公路，寻找的门牌号是北大街 714 号。

以下则是一个如何找到我们房屋的启发：找到我们寄给你的最后一封信，开车到回信地址

所说的小镇，到了镇上后随便问哪个人我们住哪儿，别担心，镇上的人都认识我们。如果你谁也遇不到的话，就打电话找我们。

公式和启发之间的区别是微妙的，这两个例子或许会说明一些问题。从本书的角度来看它们之间的主要区别是：它们与答案之间的直接程度。公式给予直接指令；而启发则告诉你该怎样找到这些指令，或者至少告诉你到哪里寻找它们。

如果有一套指令告诉你该如何解决程序中的问题，这当然会使编程变得很容易，而且结果也可以预测了。但是编程科学目前还没有那样发达，也许永远也不会。编程中最富于挑战性的问题便是将问题概念化，编程中许多错误往往都是概念性错误，因为每个程序在概念上都是独特的，所以创立一套可以指导每一个问题的规则是非常困难，甚至是不可能的。这样，从总体上知道该如何解决问题，便几乎和知道某一特定问题的答案一样重要了。

你是怎样使用软件隐喻的呢？应该用它来帮助你获得关于编程过程的内在理解，利用它们来帮助你考虑编程活动，想象解决问题的更好办法。你不要一看到某一行代码就说这与这一章所使用的某个隐喻相矛盾。随着时间推移，在编程过程当中使用隐喻的程序员肯定比不使用这方法的人编写代码更快更好

## 2.3 通常的软件隐喻

随着软件的发展，隐喻越来越多，已经到了使人迷惑的地步，Fred Brooks 说写软件就像耕种、猎狼或者在一个沥青矿坑中淹死一只恐龙。Paul Heekel 说这就像电影《白雪公主与七个小矮人》。David Gries 说这是科学，Donald Knuth 则说这是门艺术，Watts Hamphrey 则说这是一个过程，Peter Freeman 说这是个系统，Harlan Mills 认为这就像解数学题、做外科手术、或者是宰一条狗，Mark Spinrad 和 Curt Abraham 说这更像是开发西部、在冰水中洗澡或者围着营火吃豆子

### 2.3.1 软件书写：写代码（Writing Code）

开发软件最原始的隐喻出自 「写代码」 一词。这个写的隐喻说明开发一个程序就像随便写封信，你准备好纸、笔和墨水，坐下从头写到尾就算完成了。这不需要任何正式计划，你只是把你要说的都写出来

许多想法都源于写隐喻。Jon Beitle 说，你应该准备好一杯白兰地，一支上等雪茄，与你喜欢的猎狗一同坐在火边，像一个优秀小说家一样享受一次 「自由编程」。Brian 和 Kernighan 把写隐喻风格的书称为《风格要素》（《The Elements of Style》）之后，把他们编程风格的书称作《编程风格要素》（《The Elements of Programming Style》），程序员们则经常谈论程序的 「可读性」。

在一些小问题中，写代码隐喻可以充分描述它们。但是对于其余的问题，它就力不从心了，它不可能全面彻底地描述软件开发过程。写往往是一种个人活动，而软件开发往往需要许多人分担各种不同的责任。当你写完一封信时，你把它装进信封并把它寄出去后，你就再也不能改变它的內容了，无论从哪个角度说，这项工作都已经完成了。软件的内容是很容易改变的却很难彻底完成。几乎有 50% 的软件开发工作量是在软件最初发行之后オ进行的（Lient セ和 Swanson, 1980)。编写软件，主要工作量集中在初始阶段。在软件创建中，把精力集中于初始阶段往往不如在初始工作完成后，再集中精力进行代码的重新调整工作。简而言之，写隐喻往往把软件工作表示成是一项过于简单而刻板的工作。

不幸的是，写隐喻已经通过我们这个星球上最流行的软件书 - Fred Brooks 的《The Mythical Man Month》而变得永存了。Brooks 说，「扔掉一个计划，又有什么呢？」 这使得我们联想到一大堆被扔进废纸篓的手稿。当你写封家常信问候你叔叔时，准备扔掉一封信是可能的这也可能是 Brooks1975 年写那本书时，当时软件工程的水平。

但是，到了九十年代，再把写隐喻解释为准备扔掉一封信时，恐怕是不合时宜的。现在，开发一个主要系统的投资已经相当于建一幢十层办公楼或造一艘远洋客轮的费用了。我们应该在第一次调试时就完成它，或者在它们成本最低时试几次运气，其它几个隐喻较好地解决了说明达到这一目的的方法问题。

### 2.3.2 软件播种：生成系统（Growing a System)

与刻板的写隐喻相反，一些软件开发者认为你应该把创建软件当作播种或培植庄稼。你设计一小部分，编码一小部分，测试一小部分，然后在某个时候把它加到系统上，通过小步走你减小了每次可能遇到的错误。

有时，一项先进的技术可能是通过拙劣的隐喻来表达的。在这种情况下，应努力保留这项技术并換一个隐喻来表达它。在这里增量技术是先进的，但是种庄稼的比喻则是十分拙劣的。

次干ー点儿的想法可能和植物生长有某种类似之处，但是耕种类比实在太牵强，而且也令人感到陌生，因而也就很快被后面的隐喻所取代了。很难把耕种隐喻推广到每次做一点儿这简单想法之外。如果你来用耕种隐喻，你就会发现自己在谈论给系统计划施肥，减少详细设

计，通过有效地田间管理提高编码产量，最后收获编码。你也会谈论进行轮作，用种小麦代替

大麦，让土地体息一年以提高土壤中的养分。

软件种植隐喻的弱点是你对于软件开发失去了直接控制。你在春天播种代码，最后在秋天收获一大堆代码

### 2.3.3 软件珍珠培植法：系统积累（System Accretion

有时候，人们在谈论种植软件而事实上他们指的是软件积累。这两个隐喻是密切联系的，但是软件积累更深刻一些。「积累」 这个词，含有通过外加或吸收，绶慢生长的意思，就像河蚌逐渐分泌酸钙形成珍珠一样。在地质学上，水中悬浮物逐渐沉积形成陆地的过程也与此相似。

这并不是说你要从水中悬浮物里沉积出代码来；这只意味着你应该学会每次向你的系统中加一点儿东西。另外一个与积累密切相联的词是增量。增量设计、构造、测试是软件开发的最强有力工具之ー。「增量」 一词在设计者心目中还远未达到 「结构化」 或 「面向对象设计」 等的地位，所以迄今为止也没有一本关于这方面的论述，这实在是令人遗憾的，因为这种书中所收集的技术将具有极大的潜力。

在增量开发中，你首先设计系统可以运行的最简单版本。它甚至可以不接受实际数据输入，或者对数据进行处理。它也可以不产生输出，只需要成为ー个坚实的骨架结构，以便能承受将要在它之上发展的真实系统。它可以调用任何一个实现预定功能而设立的伪子程序。就像河蚌刚开始产生珍珠的核一一粒沙子

当你搭好骨架后，逐漸地往上添加肌肉和皮肤。你把每一个伪子程序变成真正的子程序。此时你不必再假设产生结果了，你可以随意访问一个代码来产生结果。也不必使其假设接收输入，你可以用同样的方法让它接收输入。你每次加入一点儿代码直到你最终完成它。

这种方法的发展是令人印象非常深刻的。Fred Brooks，在 1975 年时还认为：「应做好建造个扔掉一个的准备」，在 1987 年时，却说在过去的岁月里，还没有一样东西像增量概念这样如此深刻地改变了他自己的实践或效率。

增量隐喻的力量在于：作为一个隐喻，它并没有过分作出许诺，它不像耕种隐喻那样容易被错误延伸。河蚌育珍珠的联想对理解增量发展法或积累法有很大帮助。

### 2.3.4 软件创建：建造软件（building software）

「建造」 一词的想象比 「写」 或者 「种植 ' 软件的想象更为贴切，它与 「增量」 软件的想法是基本一致的。建造隐喻暗示了许多诸如计划、准备、执行等工作阶段。如果你仔细研究这个隐喻，你还会发现它还暗示着其它许多东西。

建造一个四英尺高的塔需要一双稳健的手、一个平台和十个完好的啤酒罐。而建造一个四百英尺高的塔却決不仅仅是需要一千个啤酒罐就够了，它还需要一种完全不同的计划和创建方法

如果你想建一个简单的建筑物，比如说一个狗舍，你买来了木板和钉子，到下午的时候，你已经给你的爱犬造好了一幢新房子，假设你忘了修ー个门，不过这没关系，你可以补救一下或推倒一节重新开始。你所浪费的不过是一个下年的时间罢了。这与小型软件的发展失败非常类似。如果你有 25 行代码设计错了。那你重新再来一遍好了，你不会因此浪费许多的。

然而如果你是在造一幢房子，那修建的过程就要复杂些了，而拙劣设计的后果也严重得多。首先，你必须決定造一幢什么样的房子，这就像软件开发中的问题定义。然后，你与建筑师必须搞出一个你们都同意的总体方案，这和软件的总体设计是一样的。接着，你又画出细节蓝图并找来一位承包商，这相当于软件中的详细设计。下面的工作是选好房址、打地基、建造起房屋的框架、建好墙壁并加上屋顶、用干斤锤检查墙壁是否垂直，这同软件创建基本差不多。当房屋的绝大部分工作已经完成时，你请来园艺师和装修师，以便使你的房间和空地得到最好的利用，这可以与软件优化相类似。在整个过程中，会有各种监督人员来检查房址、地基、框架、供电系统和其它东西，这也可以与软件开发中的评审和鉴定相类似。

较大的规模和复杂性往往意味着可以产生较大的成果。在修房子的时候，材料可能比较贵，但更大的花费是劳动力。拆掉一面墙并把它移到六英尺之外是很昂贵的，但并不是因为你浪费了许多钉子，而是因为你需要付出劳动。你应该尽可能精心设计，以避免那些本可避免的错误，以降低成本。在开发软件过程中，材料更便宜，然而劳动力成本却更高。改变一个报告的格式，可能与移走一幢房子里的墙壁一样昂贵，因为二者成本的主要部分都是劳动力。

这两个活动之间还有什么类似之处呢？在建房子中，你不会去建造那些你可以现成买来的东西，比如洗衣机、烘干机，电冰箱、吸尘器等，除非你是个机械迷。同时，你也会去购买已经做好的地毯、门、窗和浴室用品，而不是自己动手建。如果你正在建造一个软件，你也会这样做。你会推广使用高级语言的特点，而不是去编写操作系统一级的代码。你也会利用已经存在的显示控制和数据库处理系统，利用已经通过的子程序。如果样样都自己动手是很不明智的。

如果你想修建一幢陈设一流的别墅，情况就不同了，你可能定做全套家具，因为希望洗碗机、冰箱等与你的家具协调一致，同时你还会定做別具风格的门和窗户。这种定制化的方式与流软件开发也是非常类似的。为了这一目的，你可能创建精度更高、速度更快的科学公式。你也会设计自己的显示控制、数据库处理系统和自己的子程序，以使整个软件给人以一气阿成，天衣无缝的感觉。

当然这两种建造方法也要付出代价，工作的每一步都要依据事先制定好的计划进行。如果软件开发工作的顺序有误，那么这个软件将是难以编码、难以测试和难以调试的。这可能会使整个计划延误甚至失败，因为每个人从事的工作都非常复杂，把它们综合到一起后会使人无所适从。

如果你在盖办公楼时工作做得不好，那么在楼内办公的人便可能面临危险。同样，如果你在创建医药、航空电子、空中交通管制、加工控制等软件时工作做得不好，后果也可能是灾难性的。危及别人生命是劣质软件的最可怕后果，但并不是它的唯一危害。如果公司的股东们因为你编写了错误软件而赔钱，那也是令人遗憾的。无论如何，无辜的人们没有义务为你的工作失误而付出代价。

对于软件作修改与建造建筑物也有类似之处。如果你要移走的那面墙壁还要支撑其它东西而不仅仅是隔开两个房间，那么你要付出的成本将会更高。同样，对软件做结构性的修改也将比增加或减少外设特征付出更高昂的代价。

最后，建筑类比对于超大型软件也是同样适用的。一幢超大型建筑物存在错误的后果将是灾难性的，整个工程可能不得不返工。建筑师们在制定和审查计划时是非常仔细的，他们往往留出安全裕度，多用 10% 的材料来加强结构总比一幢大楼坍塌要好得多，同时还必须仔细注意工时计划，在修建帝国大厦时，每辆卡车的每次卸货时间都留出了十五分钟的裕度。因为如果有一辆卡车不能在指定时间到达指定的位置，整个计划就有可能被延误。

同样，对于超大型软件来说，计划工作需要比一般的大型软件在更高的层次上进行。1977 年，Capers Jones 1 估计说，对于一个拥有 750,000 行代码的系统来说，可能需要多达 600 页的功能定义文件。对于一个人来说，不要说理解这种规模全部的设计，就是读完它也是非常困难的。安全系数对于这种项目是必须的，制定该系统的工时计划尤为重要。当我们在建造与帝国大厦同等经济规模的软件时，我们也需要同等严密的计划。而我们现在才刚刚开始考虑这种规模项目的计划技术。

这两者之间的相似还可以推广到其它方面，这就是为什么建筑物创建隐喻是如此强有力的原因。许多常用的软件词汇来源于建筑学，如：软件体系结构、搭结构架、构造、分割代码、插入子程序等等。

### 2.3.5 实用软件技术：智能工具箱（The Intelectual Toolbox)

在过去的十几年中，优秀的软件开发人员们积累了几十条关于开发软件的技术和技巧，有些像咒语般灵验，这些技术不是规则，它们是分析工具。一个优秀的工匠知道用什么样的工具干哪一样工作，而且知道该如何使用它们。程序员也是如此，关于编程你理解得越深入你的工具箱里的工具也就越多，何时何地该如何运用它们的知识也就越多。

把方法和技巧当作工具是很有益处的，因为这样可以使我们对其有一个正确的态度。不要把最新的 「面向对象设计技术」 当作上帝赐予的法宝，它不过是一件在某些场合下有用而在某些场合下又无用的技术。如果你拥有的唯一工具就是一把锤子，那么你就会把整个世界都当作一个钉子。好在没有人会花 500 美元一天的费用来雇佣一个仅告诉你去买一把可以解决一切问题的锤子的研究小组，也没有人建议你丢掉你的改锥、手钻和电烙铁。

在软件开发中，常常会有人告诉你用一种方法来代替另外一种方法。这实在不幸，如果你仅仅采用一种方法，那你就会把整个世界都当成那个工具的作用对象。你会失去用更适合的方法解决问题的机会。工具箱隐喻有助于我们保留一切方法、技巧、技术等，并在适当的时候使用它们。

### 2.3.6 复合隐喻（Combing Metaphors

因为隐喻更像是一种启发，而不是公式，所以，它们并不是互相排斥的。你可以同时使用增量隐崳和建筑隐崳。如果你愿意的话，你也可以采用 「写」 隐喻，或者把写隐喻与耕种隐喻一起使用。只要能激发你的思想，你尽可以采用一切你认为合适的隐喻。

使用隐喻是一项模糊的事情。你不得不把它们外推到可以从中受到启发的外延中。如果你把它过分外推或者推广到了错误方向，它很可能使你误入歧途。就像是再好的工具也有可能被误用一样，你也可能错误使用隐喻。但是，它们的作用将无可置疑地使其成为你的智能工具箱中的一件有力工具。

## 2.4 小结

隐喻仅仅是启发，而不是公式，因此，它们更倾向于比较随便，无拘无束。

1、隐喻通过把软件开发与你所熟知的事情联系在一起，从而使你对其有更深刻的理解。

2、一些隐喻要好于其它隐喻。

3、把软件创建与建造建筑物类比，表明开发软件前要精心准备，并表明了大规模项目与小规模项目之间的差别。

4、认为软件开发实践是智能工具箱中的工具进一步表明，每个程序员都有许多自己的工具，没有任何一种工具是万能的。为每件工作选择合适的工具，是成为一个优秀程序员的首要素质之一。

