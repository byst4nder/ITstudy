This method is like bezierCurveTo(), but it uses a quadratic Bezier curve instead of a cubic Bezier curve and has only a single control point.

You can use these methods to draw paths like those in Figure 21-9.

Figure 21-9. Curved paths in a canvas

Example 21-7 shows the code used to create Figure 21-9. The methods demonstrated in this code are some of the most complicated in the Canvas API; see the reference section for complete details on the methods and their arguments.

Example 21-7. Adding curves to a path

// A utility function to convert angles from degrees to radians function rads(x) { return Math.PI*x/180; } // Draw a circle. Scale and rotate if you want an ellipse instead. // There is no current point, so draw just the circle with no straight // line from the current point to the start of the circle. c.beginPath(); c.arc(75,100,50, // Center at (75,100), radius 50 0,rads(360),false); // Go clockwise from 0 to 360 degrees // Draw a wedge. Angles are measured clockwise from the positive x axis. // Note that arc() adds a line from the current point to the arc start. c.moveTo(200, 100); // Start at the center of the circle c.arc(200, 100, 50, // Circle center and radius rads(-60), rads(0), // start at angle -60 and go to angle 0 false); // false means clockwise c.closePath(); // Add radius back to the center of the circle // Same wedge, opposite direction c.moveTo(325, 100); c.arc(325, 100, 50, rads(-60), rads(0), true); // counterclockwise c.closePath(); // Use arcTo() for rounded corners. Here we draw a square with // upper left corner at (400,50) and corners of varying radii. c.moveTo(450, 50); // Begin in the middle of the top edge. c.arcTo(500,50,500,150,30); // Add part of top edge and upper right corner. c.arcTo(500,150,400,150,20); // Add right edge and lower right corner. c.arcTo(400,150,400,50,10); // Add bottom edge and lower left corner. c.arcTo(400,50,500,50,0); // Add left edge and upper left corner. c.closePath(); // Close path to add the rest of the top edge. // Quadratic Bezier curve: one control point c.moveTo(75, 250); // Begin at (75,250) c.quadraticCurveTo(100,200, 175, 250); // Curve to (175,250) c.fillRect(100-3,200-3,6,6); // Mark the control point (100,200) // Cubic Bezier curve c.moveTo(200, 250); // Start at (200,250) c.bezierCurveTo(220,220,280,280,300,250); // Curve to (300,250) c.fillRect(220-3,220-3,6,6); // Mark control points c.fillRect(280-3,280-3,6,6); // Define some graphics attributes and draw the curves c.fillStyle = "#aaa"; // Gray fills c.lineWidth = 5; // 5-pixel black (by default) lines c.fill(); // Fill the curves c.stroke(); // Stroke their outlines

Rectangles

CanvasRenderingContext2D defines four methods for drawing rectangles. Example 21-7 used one of them, fillRect(), to mark the control points of the Bezier curves. All four of these rectangle methods expect two arguments that specify one corner of the rectangle followed by the rectangle width and height. Normally, you specify the upper left corner and then pass a positive width and positive height, but you may also specify other corners and pass negative dimensions.

fillRect() fills the specified rectangle with the current fillStyle. strokeRect() strokes the outline of the specified rectangle using the current strokeStyle and other line attributes. clearRect() is like fillRect(), but it ignores the current fill style and fills the rectangle with transparent black pixels (the default color of all blank canvases). The important thing about these three methods is that they do not affect the current path or the current point within that path.

The final rectangle method is named rect(), and it does affect the current path: it adds the specified rectangle, in a subpath of its own, to the path. Like other path-definition methods, it does not fill or stroke anything itself.

Colors, Transparency, Gradients, and Patterns

The strokeStyle and fillStyle attributes specify how lines are stroked and regions are filled. Most often, these attributes are used to specify opaque or translucent colors, but you can also set them to CanvasPattern or CanvasGradient objects to stroke or fill with a repeated background image or with a linear or radial color gradient. In addition, you can set the globalAlpha property to make everything you draw translucent.

To specify a solid color, use one of the color names defined by the HTML4 standard,[52] or use a CSS color string:

context.strokeStyle = "blue"; // Stroke lines in blue context.fillStyle = "#aaa"; // Fill areas with light gray

The default value for both strokeStyle and fillStyle is「#000000」: opaque black.

Current browsers support CSS3 colors and allow the use of the RGB, RGBA, HSL, and HSLA color spaces in addition to basic hexadecimal RGB colors. Here are some examples:

var colors = [ "#f44", // Hexadecimal RGB value: red "#44ff44", // Hexadecimal RRGGBB value: green "rgb(60, 60, 255)", // RGB as integers 0-255: blue "rgb(100%, 25%, 100%)", // RGB as percentages: purple "rgba(100%, 25%, 100%, 0.5)", // RGB plus alpha 0-1: translucent purple "rgba(0,0,0,0)", // Completely transparent black "transparent", // Synonym for the above "hsl(60, 100%, 50%)", // Fully saturated yellow "hsl(60, 75%, 50%)", // Less saturated yellow "hsl(60, 100%, 75%)", // Fully saturated yellow, lighter "hsl(60, 100%, 25%)", // Fully saturated yellow, darker "hsla(60, 100%, 50%, 0.5)", // Fully saturated yellow, 50% opaque ];

The HSL color space defines a color with three numbers that specify its hue, saturation, and lightness. Hue is an angle in degrees around a color wheel. A hue of 0 is red, 60 is yellow, 120 is green, 180 is cyan, 240 is blue, 300 is magenta, and 360 is back to red again. Saturation describes the intensity of the color, and it is specified as a percentage. Colors with 0 percent saturation are shades of gray. Lightness describes how light or dark a color is and is also specified as a percentage. Any HSL color with 100 percent lightness is pure white, and any color with 0 percent lightness is pure black. The HSLA color space is just like HSL, but it adds an alpha value that ranges from 0.0 (transparent) to 1.0 (opaque).

If you want to work with translucent colors, but do not want to explicitly specify an alpha channel for each color, or if you want to add translucency to opaque images or patterns (for example), you can set the globalAlpha property. Every pixel you draw will have its alpha value multiplied by globalAlpha. The default is 1, which adds no transparency. If you set globalAlpha to 0, everything you draw will be fully transparent and nothing will appear in the canvas. If you set this property to 0.5, pixels that would otherwise have been opaque will be 50 percent opaque. And pixels that would have been 50 percent opaque will be 25 percent opaque instead. If you set globalAlpha, all your pixels will be translucent and you may have to consider how those pixels are combined (or「composited」) with the pixels they are drawn over—see Compositing for details about Canvas compositing modes.

Instead of drawing with solid (but possibly translucent) colors, you can also use color gradients and repeating images when filling and stroking paths. Figure 21-10 shows a rectangle stroked with wide lines and a patterned stroke style on top of a linear gradient fill and underneath a translucent radial gradient fill. The code fragments below show how the pattern and gradients were created.

To fill or stroke using a background image pattern instead of a color, set fillStyle or strokeStyle to the CanvasPattern object returned by the createPattern() method of the context object:

var image = document.getElementById("myimage"); c.fillStyle = c.createPattern(image, "repeat");

The first argument to createPattern() specifies the image to use as the pattern. It must be an <img>, <canvas>, or <video> element from the document (or an image object created with the Image() constructor). The second argument is typically「repeat」for a repeating image fill that is independent of the size of the image, but you can also use「repeat-x」,「repeat-y」, or「no-repeat」.

Note that you can use a <canvas> element (even one that has never been added to the document and is not visible) as the pattern source for another <canvas>:

var offscreen = document.createElement("canvas"); // Create an offscreen canvas offscreen.width = offscreen.height = 10; // Set its size offscreen.getContext("2d").strokeRect(0,0,6,6); // Get its context and draw var pattern = c.createPattern(offscreen,"repeat"); // And use it as a pattern

To fill (or stroke) with a color gradient, set fillStyle (or strokeStyle) to a CanvasGradient object returned by the createLinearGradient() or createRadialGradient() methods of the context. Creating gradients is a multistep process, and using them is trickier than using patterns.

The first step is to create the CanvasGradient object. The arguments to createLinearGradient() are the coordinates of two points that define a line (it does not need to be horizontal or vertical) along which the colors will vary. The arguments to create Radial Gradient() specify the centers and radii of two circles. (They need not be concentric, but the first circle typically lies entirely inside the second.) Areas inside the smaller circle or outside the larger will be filled with solid colors: areas between the two will be filled with a color gradient.

After creating the CanvasGradient object and defining the regions of the canvas that will be filled, you must define the gradient colors by calling the addColorStop() method of the CanvasGradient. The first argument to this method is a number between 0.0 and 1.0. The second argument is a CSS color specification. You must call this method at least twice to define a simple color gradient, but you may call it more than that. The color at 0.0 will appear at the start of the gradient, and the color at 1.0 will appear at the end. If you specify additional colors, they will appear at the specified fractional position within the gradient. Elsewhere, colors will be smoothly interpolated. Here are some examples:

// A linear gradient, diagonally across the canvas (assuming no transforms) var bgfade = c.createLinearGradient(0,0,canvas.width,canvas.height); bgfade.addColorStop(0.0, "#88f"); // Start with light blue in upper left bgfade.addColorStop(1.0, "#fff"); // Fade to white in lower right // A gradient between two concentric circles. Transparent in the middle // fading to translucent gray and then back to transparent. var peekhole = c.createRadialGradient(300,300,100, 300,300,300); peekhole.addColorStop(0.0, "transparent"); // Transparent peekhole.addColorStop(0.7, "rgba(100,100,100,.9)"); // Translucent gray peekhole.addColorStop(1.0, "rgba(0,0,0,0)"); // Transparent again

An important point to understand about gradients is that they are not position-independent. When you create a gradient, you specify bounds for the gradient. If you then attempt to fill an area outside of those bounds, you’ll get the solid color defined at one end or the other of the gradient. If you define a gradient along the line between (0,0) and (100, 100), for example, you should only use that gradient to fill objects located within the rectangle (0,0,100,100).

The graphic shown in Figure 21-10 was created with the pattern pattern and the bgfade and peekhole gradients defined above using this code:

c.fillStyle = bgfade; // Start with the linear gradient c.fillRect(0,0,600,600); // Fill the entire canvas c.strokeStyle = pattern; // Use the pattern for stroking lines c.lineWidth = 100; // Use really wide lines c.strokeRect(100,100,400,400); // Draw a big square c.fillStyle = peekhole; // Switch to the radial gradient c.fillRect(0,0,600,600); // Cover canvas with this translucent fill

Line Drawing Attributes

You’ve already seen the lineWidth property, which specifies the width of the lines drawn by stroke() and strokeRect(). In addition to lineWidth (and strokeStyle, of course), there are three other graphics attributes that affect line drawing.

The default value of the lineWidth property is 1, and you can set it to any positive number, even fractional values less than 1. (Lines that are less than one pixel wide are drawn with translucent colors, so they look less dark than 1-pixel-wide lines). To fully understand the lineWidth property, it is important to visualize paths as infinitely thin one-dimensional lines. The lines and curves drawn by the stroke() method are centered over the path, with half of the lineWidth on either side. If you’re stroking a closed path and only want the line to appear outside the path, stroke the path first, and then fill with an opaque color to hide the portion of the stroke that appears inside the path. Or if you only want the line to appear inside a closed path, call the save() and clip() methods (Clipping) first, and then call stroke() and restore().

Line widths are affected by the current transformation, as you may be able to make out in the scaled axes of Figure 21-7. If you call scale(2,1) to scale the X dimension and leave Y unaffected, vertical lines will be twice as wide as horizontal lines drawn with the same lineWidth setting. It is important to understand that line width is determined by the lineWidth and the current transform at the time stroke() is called, not at the time that lineTo() or another path-building method is called.

Figure 21-10. Pattern and gradient fills

The other three line drawing attributes affect the appearance of the unconnected ends of paths and the vertexes where two path segments meet. They have very little visual impact for narrow lines, but they make a big difference when you are drawing with wide lines. Two of these properties are illustrated in Figure 21-11. The figure shows the path as a thin black line and the stroke as the gray area that surrounds it.

Figure 21-11. The lineCap and lineJoin attributes

The lineCap property specifies how the ends of an open subpath are「capped.」The value「butt」(the default) means that the line terminates abruptly at the end point. The value「square」means that the line extends, by half of the line width, beyond the endpoint. And the value「round」means that the line is extended with a half circle (of radius one-half the line width) beyond the endpoint.

The lineJoin property specifies how the vertexes between subpath segments are connected. The default value is「miter」, which means that the outside edges of the two path segments are extended until they meet at a point. The value「round」means that the vertex is rounded off, and the value「bevel」means that the vertex is cut off with a straight line.

The final line drawing property is miterLimit, which only applies when lineJoin is「miter」. When two lines meet at a sharp angle, the miter between them can become quite long, and these long jagged miters are visually distracting. The miterLimit property places an upper bound on miter length. If the miter at a given vertex would be longer than half of the line width times miterLimit, that vertex will be drawn with a beveled join instead of a mitered join.

Text

To draw text in a canvas, you normally use the fillText() method, which draws text using the color (or gradient or pattern) specified by the fillStyle property. For special effects at large text sizes, you can use strokeText() to draw the outline of the individual text glyphs (an example of outlined text appears in Figure 21-13). Both methods take the text to be drawn as their first argument and take the X and Y coordinates of the text as the second and third arguments. Neither method affects the current path or the current point. As you can see in Figure 21-7, text is affected by the current transformation.

The font property specifies the font to be used for text drawing. The value should be a string in the same syntax as the CSS font attribute. Some examples:

"48pt sans-serif" "bold 18px Times Roman" "italic 12pt monospaced" "bolder smaller serif" // bolder and smaller than the font of the <canvas>

The textAlign property specifies how the text should be horizontally aligned with respect to the X coordinate passed to fillText() or strokeText(). The textBaseline property specifies how the text should be vertically aligned with respect to the Y coordinate. Figure 21-12 illustrates the allowed values for these properties. The thin line near each string of text is the baseline, and the small square marks the point (x,y) that was passed to fillText().

Figure 21-12. The textAlign and textBaseline properties

The default textAlign is「start」. Note that for left-to-right text, an alignment of「start」is the same as「left」and an alignment of「end」is the same as「right」. If you set the dir attribute of the <canvas> element to「rtl」(right-to-left), however,「start」alignment is the same and「right」alignment and「end」is the same as「left」.

The default textBaseline is「alphabetic」, and it is appropriate for Latin and similar scripts. The value「ideographic」is used with ideographic scripts such as Chinese and Japanese. The value「hanging」is intended for use with Devangari and similar scripts (which are used for many of the languages of India). The「top」,「middle」, and「bottom」baselines are purely geometric baselines, based on the「em square」of the font.

fillText() and strokeText() take an optional fourth argument. If given, this argument specifies the maximum width of the text to be displayed. If the text would be wider than the specified value when drawn using the font property, the canvas will make it fit by scaling it or by using a narrower or smaller font.

If you need to measure text yourself before drawing it, pass it to the measureText() method. This method returns a TextMetrics object that specifies the measurements of the text when drawn with the current font. At the time of this writing, the only「metric」contained in the TextMetrics object is the width. Query the on-screen width of a string like this:

var width = c.measureText(text).width;

Clipping

After defining a path, you usually call stroke() or fill() (or both). You can also call the clip() method to define a clipping region. Once a clipping region is defined, nothing will be drawn outside of it. Figure 21-13 shows a complex drawing produced using clipping regions. The vertical stripe running down the middle and the text along the bottom of the figure were stroked with no clipping region and then filled after the triangular clipping region was defined.

Figure 21-13. Unclipped strokes and clipped fills

Figure 21-13 was generated using the polygon() method of Example 21-4 and the following code:

// Define some drawing attributes c.font = "bold 60pt sans-serif"; // Big font c.lineWidth = 2; // Narrow lines c.strokeStyle = "#000"; // Black lines // Outline a rectangle and some text c.strokeRect(175, 25, 50, 325); // A vertical stripe down the middle c.strokeText("<canvas>", 15, 330); // Note strokeText() instead of fillText() // Define a complex path with an interior that is outside. polygon(c,3,200,225,200); // Large triangle polygon(c,3,200,225,100,0,true); // Smaller reverse triangle inside // Make that path the clipping region. c.clip(); // Stroke the path with a 5 pixel line, entirely inside the clipping region. c.lineWidth = 10; // Half of this 10 pixel line will be clipped away c.stroke(); // Fill the parts of the rectangle and text that are inside the clipping region c.fillStyle = "#aaa" // Light gray c.fillRect(175, 25, 50, 325); // Fill the vertical stripe c.fillStyle = "#888" // Darker gray c.fillText("<canvas>", 15, 330); // Fill the text

It is important to note that when you call clip(), the current path is itself clipped to the current clipping region, and then that clipped path becomes the new clipping region. This means that the clip() method can shrink the clipping region but can never enlarge it. There is no method to reset the clipping region, so before calling clip() you should typically call save(), so that you can later restore() the unclipped region.

Shadows

Four graphics attribute properties of the CanvasRenderingContext2D object control the drawing of drop shadows. If you set these properties appropriately, any line, area, text, or image you draw will be given a drop shadow, which will make it appear as if it is floating above the canvas surface. Figure 21-14 shows shadows beneath a filled rectangle, a stroked rectangle, and filled text.

The shadowColor property specifies the color of the shadow. The default is fully transparent black, and shadows will never appear unless you set this property to a translucent or opaque color. This property can only be set to a color string: patterns and gradients are not allowed for shadows. Using a translucent shadow color produces the most realistic shadow effects because it allows the background to show through.

The shadowOffsetX and shadowOffsetY properties specify the X and Y offsets of the shadow. The default for both properties is 0, which places the shadow directly beneath your drawing, where it is not visible. If you set both properties to a positive value, shadows will appear below and to the right of what you draw, as if there were a light source above and to the left, shining onto the canvas from outside the computer screen. Larger offsets produce larger shadows and make drawn objects appear as if they are floating「higher」above the canvas.

The shadowBlur property specifies how blurred the edges of the shadow are. The default value is 0, which produces crisp, unblurred shadows. Larger values produce more blur, up to an implementation-defined upper bound. This property is a parameter to a Gaussian blur function and is not a size or length in pixels.

Figure 21-14. Automatically generated shadows

Example 21-8 shows the code used to produce Figure 21-14 and demonstrates each of these four shadow properties.

Example 21-8. Setting shadow attributes

// Define a subtle shadow c.shadowColor = "rgba(100,100,100,.4)"; // Translucent gray c.shadowOffsetX = c.shadowOffsetY = 3; // Shadow offset to lower right c.shadowBlur = 5; // Soften shadow edges // Draw some text in a blue box using that shadow c.lineWidth = 10; c.strokeStyle = "blue"; c.strokeRect(100, 100, 300, 200); // Draw a rectangle c.font = "Bold 36pt Helvetica"; c.fillText("Hello World", 115, 225); // Draw some text // Define a less subtle shadow. A larger offset makes items "float" higher. // Note how the transparent shadow overlaps the blue box. c.shadowOffsetX = c.shadowOffsetY = 20; c.shadowBlur = 10; c.fillStyle = "red"; // Draw a solid red rectangle c.fillRect(50,25,200,65); // that floats above the blue box

The shadowOffsetX and shadowOffsetY properties are always measured in the default coordinate space and are not affected by the rotate() or scale() methods. Suppose, for example, that you rotate the coordinate system by 90 degrees to draw some vertical text and then restore the old coordinate system to draw horizontal text. Both the vertical and horizontal text will have shadows oriented in the same direction, which is what you probably want. Similarly, shapes drawn with different scaling transforms will still have shadows of the same「height」.[53]

Images

In addition to vector graphics (paths, lines, etc.), the Canvas API also supports bitmap images. The drawImage() method copies the pixels of a source image (or of a rectangle within the source image) onto the canvas, scaling and rotating the pixels of the image as necessary.

drawImage() can be invoked with three, five, or nine arguments. In all cases, the first argument is the source image from which pixels are to be copied. This image argument is often an <img> element or an off-screen image created with the Image() constructor, but it can also be another <canvas> element or even a <video> element. If you specify an <img> or <video> element that is still loading its data, the drawImage() call will do nothing.

In the three-argument version of drawImage(), the second and third arguments specify the X and Y coordinates at which the upper left corner of the image is to be drawn. In this version of the method, the entire source image is copied to the canvas. The X and Y coordinates are interpreted in the current coordinate system and the image is scaled and rotated if necessary.

The five-argument version of drawImage() adds width and height arguments to the x and y arguments described above. These four arguments define a destination rectangle within the canvas. The upper left corner of the source image goes at (x,y) and the lower right corner goes at (x+width, y+height). Again, the entire source image is copied. The destination rectangle is measured in the current coordinate system. With this version of the method, the source image will be scaled to fit the destination rectangle, even if no scaling transform has ever been specified.

The nine-argument version of drawImage() specifies both a source rectangle and a destination rectangle and copies only the pixels within the source rectangle. Arguments two through five specify the source rectangle. They are measured in CSS pixels. If the source image is another canvas the source rectangle uses the default coordinate system for that canvas and ignores any transformations that have been specified. Arguments six through nine specify the destination rectangle into which the image is drawn and are in the current coordinate system of the canvas, not in the default coordinate system.

Example 21-9 is a simple demonstration of drawImage(). It uses the nine-argument version to copy pixels from a portion of a canvas and draw them, enlarged and rotated back onto the same canvas. As you can see in Figure 21-15, the image is enlarged enough to be pixelated, and you can see the translucent pixels used to smooth the edges of the line.

Figure 21-15. Pixels enlarged with drawImage()

Example 21-9. Using drawImage()

// Draw a line in the upper left c.moveTo(5,5); c.lineTo(45,45); c.lineWidth = 8; c.lineCap = "round"; c.stroke(); // Define a transformation c.translate(50,100); c.rotate(-45*Math.PI/180); // Straighten out the line c.scale(10,10); // Enlarge it so we can see the individual pixels // Use draw image to copy the line c.drawImage(c.canvas, 0, 0, 50, 50, // source rectangle: untransformed 0, 0, 50, 50); // destination rectangle: transformed

In addition to drawing images into a canvas, we can also extract the content of a canvas as an image using the toDataURL() method. Unlike all the other methods described here, toDataURL() is a method of the Canvas element itself, not of the CanvasRenderingContext2D object. You normally invoke toDataURL() with no arguments, and it returns the content of the canvas as a PNG image, encoded as a string using a data: URL. The returned URL is suitable for use with an <img> element, and you can make a static snapshot of a canvas with code like this:

var img = document.createElement("img"); // Create an <img> element img.src = canvas.toDataURL(); // Set its src attribute document.body.appendChild(img); // Append it to the document

All browsers are required to support the PNG image format. Some implementations may support other formats as well, and you can specify the desired MIME type with the optional first argument to toDataURL(). See the reference page for details.

There is one important security restriction you must be aware of when using to Data URL(). To prevent cross-origin information leaks, toDataURL() does not work on <canvas> elements that are not「origin-clean.」A canvas is not origin-clean if it has ever had an image drawn in it (directly by drawImage() or indirectly through a CanvasPattern) that has a different origin than the document that contains the canvas.

Compositing

When you stroke lines, fill regions, draw text, or copy images, you expect the new pixels to be drawn on top of the pixels that are already in the canvas. If you are drawing opaque pixels, they simply replace the pixels that are already there. If you are drawing with translucent pixels, the new (「source」) pixel is combined with the old (「destination」) pixel so that the old pixel shows through the new pixel based on how transparent that pixel is.

This process of combining new translucent source pixels with existing destination pixels is called compositing, and the compositing process described above is the default way that the Canvas API combines pixels. You don’t always want compositing to happen, however. Suppose you’ve drawn into a canvas using translucent pixels and now want to make a temporary alteration to the canvas and then restore it to its original state. An easy way to do this is to copy the canvas (or a region of it) to an offscreen canvas using drawImage(). Then, when it is time to restore the canvas, you can copy your pixels from the offscreen canvas in which you saved them back to the on-screen canvas. Remember, though, that the pixels you saved were translucent. If compositing is on, they won’t fully obscure and erase the temporary drawing you’ve done. In this scenario, you need a way to turn compositing off: to draw the source pixels and ignore the destination pixels regardless of the transparency of the source.

To specify the kind of compositing to be done, set the globalCompositeOperation property. The default value is「source-over」, which means that source pixels are drawn「over」the destination pixels and are combined with them if the source is translucent. If you set this property to「copy」, compositing is turned off: source pixels are copied to the canvas unchanged and destination pixels are ignored. Another globalCompositeOperation value that is sometimes useful is「destination-over」. This kind of compositing combines pixels as if the new source pixels were drawn beneath the existing destination pixels. If the destination is translucent or transparent, some or all of the source pixel color is visible in the resulting color.

「source-over」,「destination-over」, and「copy」are three of the most commonly used types of compositing, but the Canvas API supports 11 values for the global Composite Operation attribute. The names of these compositing operations are suggestive of what they do, and you can go a long way toward understanding compositing by combining the operation names with visual examples of how they work. Figure 21-16 illustrates all 11 operations using「hard」transparency: all the pixels involved are fully opaque or fully transparent. In each of the 11 boxes, the square is drawn first and serves as the destination. Next globalCompositeOperation is set, and the circle is drawn as the source.

Figure 21-16. Compositing operations with hard transparency

Figure 21-17 is a similar example that uses「soft」transparency. In this version, the source circle and destination square are drawn using color gradients so that the pixels have a range of transparencies.

You may find that it is not so easy to understand the compositing operations when used with translucent pixels like these. If you are interested in a deeper understanding, the reference page for CanvasRenderingContext2D includes the equations that specify how individual pixel values are computed from source and destination pixels for each of the 11 compositing operations.

At the time of this writing, browser vendors disagree on the implementation of 5 of the 11 compositing modes:「copy」,「source-in」,「source-out」,「destination-atop」, and「destination-in」behave differently in different browsers and cannot be used portably. A detailed explanation follows, but you can skip to the next section if you don’t plan on using any of these compositing operations.

Figure 21-17. Compositing operations with soft transparency

The five compositing modes listed above either ignore the destination pixel values in the computation of result pixels or make the result transparent anywhere the source is transparent. The difference in implementation has to do with the definition of the source pixels. Safari and Chrome perform compositing「locally」: only the pixels actually drawn by the fill(), stroke(), or other drawing operation count as part of the source. IE9 is likely to follow suit. Firefox and Opera perform compositing「globally」: every pixel within the current clipping region is composited for every drawing operation. If the source does not set that pixel, it is treated as transparent black. In Firefox and Opera, this means that the five compositing modes listed above actually erase destination pixels outside of the source and inside the clipping region. Figures 21-16 and 21-17 were generated in Firefox, and this is why the boxes around「copy」,「source-in」,「source-out」,「destination-atop」, and「destination-in」are thinner than the other boxes: the rectangle around each sample is the clipping region and these four compositing operations erase the portion of the stroke (half of the lineWidth) that falls inside the path. For comparison, Figure 21-18 shows the same figure as Figure 21-17, but generated in Chrome.

Figure 21-18. Compositing locally rather than globally

The HTML5 draft current at the time of this writing specifies the global compositing approach implemented by Firefox and Opera. Browser vendors are aware of the incompatibility and are not satisfied with the current state of the specification. There is a distinct possibility that the specification will be altered to require local compositing instead of global compositing.

Finally, note that it is possible to perform global compositing in browsers like Safari and Chrome that implement local compositing. First, create a blank offscreen canvas of the same dimensions as the on-screen canvas. Then draw your source pixels into the offscreen canvas and use drawImage() to copy the offscreen pixels to the on-screen canvas and composite them globally within the clipping region. There is not a general technique for performing local compositing in browsers like Firefox that implement global compositing, but you can often come close by defining an appropriate clipping region before performing the drawing operation that is to be locally composited.

Pixel Manipulation

The getImageData() method returns an ImageData object that represents the raw (non-premultiplied) pixels (as R, G, B, and A components) from a rectangular region of your canvas. You can create empty blank ImageData objects with createImageData(). The pixels in an ImageData object are writable, so you can set them any way you want, and then copy those pixels back onto the canvas with putImageData().

These pixel manipulation methods provide very low-level access to the canvas. The rectangle you pass to getImageData() is in the default coordinate system: its dimensions are measured in CSS pixels and it is not affected by the current transformation. When you call putImageData(), the position you specify is also measured in the default coordinate system. Furthermore, putImageData() ignores all graphics attributes. It does not perform any compositing, it does not multiply pixels by globalAlpha, and it does not draw shadows.

Pixel manipulation methods are useful for implementing image processing. Example 21-10 shows how to create a simple motion blur or「smear」effect on the graphics in a canvas. The example demonstrates getImageData() and putImageData() and shows how to iterate through and modify the pixel values in an ImageData object, but it does not explain these things in any detail. See the CanvasRenderingContext2D reference pages for complete details on getImageData() and putImageData() and see the ImageData reference page for details on that object.

Example 21-10. Motion blur with ImageData

// Smear the pixels of the rectangle to the right, producing a // sort of motion blur as if objects are moving from right to left. // n must be 2 or larger. Larger values produce bigger smears. // The rectangle is specified in the default coordinate system. function smear(c, n, x, y, w, h) { // Get the ImageData object that represents the rectangle of pixels to smear var pixels = c.getImageData(x,y,w,h); // This smear is done in-place and requires only the source ImageData. // Some image processing algorithms require an additional ImageData to // store transformed pixel values. If we needed an output buffer, we could // create a new ImageData with the same dimensions like this: // var output_pixels = c.createImageData(pixels); // These dimensions may be different than w and h arguments: there may be // more than one device pixel per CSS pixel. var width = pixels.width, height = pixels.height; // This is the byte array that holds the raw pixel data, left-to-right and // top-to-bottom. Each pixel occupies 4 consecutive bytes in R,G,B,A order. var data = pixels.data; // Each pixel after the first in each row is smeared by replacing it with // 1/nth of its own value plus m/nths of the previous pixel's value var m = n-1; for(var row = 0; row < height; row++) { // For each row var i = row*width*4 + 4; // The offset of the second pixel of the row for(var col = 1; col < width; col++, i += 4) { // For each column data[i] = (data[i] + data[i-4]*m)/n; // Red pixel component data[i+1] = (data[i+1] + data[i-3]*m)/n; // Green data[i+2] = (data[i+2] + data[i-2]*m)/n; // Blue data[i+3] = (data[i+3] + data[i-1]*m)/n; // Alpha component } } // Now copy the smeared image data back to the same position on the canvas c.putImageData(pixels, x, y); }

Note that getImageData() is subject to the same cross-origin security restriction that the toDataURL() is: it does not work on any canvas that has ever had an image drawn in it (directly by drawImage() or indirectly through a CanvasPattern) that has a different origin than the document that contains the canvas.

Hit Detection

The method isPointInPath() determines whether a specified point falls within (or on the boundary of) the current path and returns true if so, or false otherwise. The point you pass to the method is in the default coordinate system and is not transformed. This makes this method useful for hit detection: determining whether a mouse click occurred over a particular shape.

You can’t pass the clientX and clientY fields of a MouseEvent object directly to is Point InPath(), however. First, the mouse event coordinates must be translated to be relative to the canvas element rather than the Window object. Second, if the onscreen size of the canvas is different than its actual dimensions, the mouse event coordinates must be scaled appropriately. Example 21-11 shows a utility function you can use to determine whether a give MouseEvent was over the current path.

Example 21-11. Testing whether a mouse event is over the current path

// Returns true if the specified mouse event is over the current path // in the specified CanvasRenderingContext2D object. function hitpath(context, event) { // Get <canvas> element from the context object var canvas = context.canvas; // Get canvas size and position var bb = canvas.getBoundingClientRect(); // Translate and scale mouse event coordinates to canvas coordinates var x = (event.clientX-bb.left)*(canvas.width/bb.width); var y = (event.clientY-bb.top)*(canvas.height/bb.height); // Call isPointInPath with these transformed coordinates return context.isPointInPath(x,y); }

You might use this hitpath() function in an event handler like this:

canvas.onclick = function(event) { if (hitpath(this.getContext("2d"), event) { alert("Hit!"); // Click over current path } };

Instead of doing path-based hit detection, you can use getImageData() to test whether the pixel under the mouse point has been painted. If the returned pixel (or pixels) are fully transparent, nothing has been drawn into that pixel and the mouse event is a miss. Example 21-12 shows how you can do this kind of hit detection.

Example 21-12. Testing whether a mouse event is over a painted pixel

// Returns true if the specified mouse event is over a nontransparent pixel. function hitpaint(context, event) { // Translate and scale mouse event coordinates to canvas coordinates var canvas = context.canvas; var bb = canvas.getBoundingClientRect(); var x = (event.clientX-bb.left)*(canvas.width/bb.width); var y = (event.clientY-bb.top)*(canvas.height/bb.height); // Get the pixel (or pixels if multiple device pixels map 1 CSS pixel) var pixels = c.getImageData(x,y,1,1); // If any pixels have a nonzero alpha, return true (hit) for(var i = 3; i < pixels.data.length; i+=4) { if (pixels.data[i] !== 0) return true; } // Otherwise it was a miss. return false; }

Canvas Example: Sparklines

We’ll end this chapter with a practical example for drawing sparklines. A sparkline is a small data-display graphic intended to be included within the flow of text, like this one: . The term「sparkline」was coined by author Edward Tufte, who describes them as「small, high-resolution graphics embedded in a context of words, numbers, images. Sparklines are data-intense, design-simple, word-sized graphics.」(Learn more about sparklines in Tufte’s book Beautiful Evidence [Graphics Press].)

Example 21-13 is a relatively simple module of unobtrusive JavaScript code for enabling sparklines in your web pages. The comments explain how it works. Note that it uses the onLoad() function of Example 13-5.

Example 21-13. Sparklines with the <canvas> element

/* * Find all elements of CSS class "sparkline", parse their content as * a series of numbers, and replace it with a graphical representation. * * Define sparklines with markup like this: * <span class="sparkline">3 5 7 6 6 9 11 15</span> * * Style sparklines with CSS like this: * .sparkline { background-color: #ddd; color: red; } * * - Sparkline color is from the computed style of the CSS color property. * - Sparklines are transparent, so the normal background color shows through. * - Sparkline height is from the data-height attribute if defined or from * the computed style for the font-size otherwise. * - Sparkline width is from the data-width attribute if it is defined * or the number of data points times data-dx if that is defined or * the number of data points times the height divided by 6 * - The minimum and maximum values of the y axis are taken from the data-ymin * and data-ymax attributes if they are defined, and otherwise come from * the minimum and maximum values of the data. */ onLoad(function() { // When the document firsts loads // Find all elements of class "sparkline" var elts = document.getElementsByClassName("sparkline"); main: for(var e = 0; e < elts.length; e++) { // For each element var elt = elts[e]; // Get content of the element and convert to an array of numbers. // If the conversion fails, skip this element. var content = elt.textContent || elt.innerText; // Element content var content = content.replace(/^\s+|\s+$/g, ""); // Strip spaces var text = content.replace(/#.*$/gm, ""); // Strip comments text = text.replace(/[\n\r\t\v\f]/g, " "); // Convert \n etc, to space var data = text.split(/\s+|\s*,\s*/); // Split on space or comma for(var i = 0; i < data.length; i++) { // For each chunk data[i] = Number(data[i]); // Convert to a number if (isNaN(data[i])) continue main; // and abort on failure } // Now compute the color, width, height, and y axis bounds of the // sparkline from the data, from data- attributes of the element, // and from the computed style of the element. var style = getComputedStyle(elt, null); var color = style.color; var height = parseInt(elt.getAttribute("data-height")) || parseInt(style.fontSize) || 20; var width = parseInt(elt.getAttribute("data-width")) || data.length * (parseInt(elt.getAttribute("data-dx")) || height/6); var ymin = parseInt(elt.getAttribute("data-ymin")) || Math.min.apply(Math, data); var ymax = parseInt(elt.getAttribute("data-ymax")) || Math.max.apply(Math, data); if (ymin >= ymax) ymax = ymin + 1; // Create the canvas element. var canvas = document.createElement("canvas"); canvas.width = width; // Set canvas dimensions canvas.height = height; canvas.title = content; // Use the element content as a tooltip elt.innerHTML = ""; // Erase existing element content elt.appendChild(canvas); // Insert the canvas into the element // Now plot the points (i,data[i]), transforming to canvas coordinates. var context = canvas.getContext('2d'); for(var i = 0; i < data.length; i++) { // For each data point var x = width*i/data.length; // Scale i var y = (ymax-data[i])*height/(ymax-ymin); // Scale data[i] context.lineTo(x,y); // First lineTo() does a moveTo() instead } context.strokeStyle = color; // Specify the color of the sparkline context.stroke(); // and draw it } });

* * *

[52] Aqua, black, blue, fuchsia, gray, green, lime, maroon, navy, olive, purple, red, silver, teal, white, and yellow.

[53] At the time of this writing, Google’s Chrome browser, version 5, gets this wrong and transforms the shadow offsets.

Chapter 22. HTML5 APIs

The term HTML5 refers to the latest version of the HTML specification, of course, but it has also come to refer to an entire suite of web application technologies that are being developed and specified as part of or alongside HTML. A more formal term for these technologies is the Open Web Platform. In practice, however,「HTML5」is a convenient shorthand, and this chapter uses it in that way. Some of the new HTML5 APIs are documented elsewhere in this book:

Chapter 15 covers the getElementsByClassName() and querySelectorAll() methods and the dataset attribute of document elements.

Chapter 16 covers the classList property of elements.

Chapter 18 covers XMLHttpRequest Level 2, cross-origin HTTP requests, and the EventSource API defined by the Server-Sent Events specification.

Chapter 20 documents the Web Storage API and the application cache for offline web apps.

Chapter 21 covers the <audio>, <video>, and <canvas> elements and SVG graphics.

This chapter covers a number of other HTML5 APIs:

Geolocation covers the Geolocation API, which allows browsers to (with permission) determine the user’s physical location.

History Management covers history management APIs that allow web applications to save and update their state in response to the browser’s Back and Forward buttons without having to reload themselves from the web server.

Cross-Origin Messaging describes a simple API for passing messages between documents with different origins. This API safely works around the same-origin security policy (The Same-Origin Policy) that prevents documents from different web servers from interacting directly with each other.

Web Workers covers a major new feature of HTML5: the ability to run JavaScript code in an isolated background thread and to safely communicate with those「worker」threads.

Typed Arrays and ArrayBuffers describes special-purpose memory-efficient types for working with arrays of bytes and numbers.

Blobs covers Blobs: opaque chunks of data that serve as the central data exchange format for a variety of new binary data APIs. This section also covers a number of Blob-related types and APIs: File and FileReader objects, the BlobBuilder type, and Blob URLs.

The Filesystem API demonstrates the Filesytem API by which web applications can read and write files within a private sandboxed filesystem. This is one of the APIs that is still in flux and is not documented in the reference section.

Client-Side Databases demonstrates the IndexedDB API for storing and retrieving objects in simple databases. Like the Filesystem API, IndexedDB is unstable and is not documented in the reference section.

Finally, Web Sockets covers the Web Sockets API that allows web applications to connect to servers using bidirectional stream-based networking instead of the stateless request/response networking model supported by XMLHttpRequest.

The features documented in this chapter either do not fit naturally into any of the previous chapters or are not yet stable and mature enough to integrate into the main chapters of the book. Some of the APIs seem stable enough to document in the reference section, while in other cases the API is still in flux and is not covered in Part IV. All but one of the examples in this chapter (Example 22-9), worked in at least one browser when this book went to press. Because the specifications being covered here are still evolving, some of these examples may no longer work when you read this chapter.

Geolocation

The Geolocation API allows JavaScript programs to ask the browser for the user’s real-world location. Location-aware applications can display maps, directions, and other information relevant to the user’s current position. There are, of course, significant privacy concerns here, and browsers that support the Geolocation API always ask the user before allowing a JavaScript program to access the user’s physical location.

Browsers that support the Geolocation API define navigator.geolocation. This property refers to an object with three methods:

navigator.geolocation.getCurrentPosition()

Request the user’s current position.

navigator.geolocation.watchPosition()

Request the current position, but also continue to monitor position and invoke the specified callback when the user’s position changes.

navigator.geolocation.clearWatch()

Stop watching the user’s location. The argument to this method should be the number returned by the corresponding call to watchPosition().

In devices that include GPS hardware, very precise location information can be obtained from the GPS unit. More commonly, however, location information comes via the Web. If a browser submits your Internet IP address to a web service, it can usually determine (based on ISP records) what city you are in (and it is common for advertisers to do this on the server side). A browser can often obtain an even more precise location by asking the operating system for the list of nearby wireless networks and their signal strengths. This information, when submitted to a sophisticated web service allows your location to be computed with surprising accuracy (usually within one city block).

These geolocation technologies involve either an exchange over the network or communication with multiple satellites, so the Geolocation API is asynchronous: get Current Position() and watchPosition() return immediately but accept a callback argument that the browser invokes when it has determined the user’s position (or when the position has changed). The simplest form of location request looks like this:

navigator.geolocation.getCurrentPosition(function(pos) { var latitude = pos.coords.latitude; var longitude = pos.coords.longitude; alert("Your position: " + latitude + ", " + longitude); });

In addition to latitude and longitude, every successful geolocation request also returns an accuracy value (in meters) that specifies how closely the position is known. Example 22-1 demonstrates: it calls getCurrentPosition() to determine the current position and uses the resulting information to display a map (from Google Maps) of the current location, zoomed approximately to the location accuracy.

Example 22-1. Using geolocation to display a map

// Return a newly created <img> element that will (once geolocation succeeds) // be set to display a Google map of the current location. Note that the caller // must insert the returned element into the document in order to make it // visible. Throws an error if geolocation is not supported in the browser function getmap() { // Check for geolocation support if (!navigator.geolocation) throw "Geolocation not supported"; // Create a new <img> element, start a geolocation request to make the img // display a map of where we are, and then return the image. var image = document.createElement("img"); navigator.geolocation.getCurrentPosition(setMapURL); return image; // This function will be invoked after we return the image object, when // (and if) the geolocation request succeeds. function setMapURL(pos) { // Get our position information from the argument object var latitude = pos.coords.latitude; // Degrees N of equator var longitude = pos.coords.longitude; // Degrees E of Greenwich var accuracy = pos.coords.accuracy; // Meters // Construct a URL for a static Google map image of this location var url = "http://maps.google.com/maps/api/staticmap" + "?center=" + latitude + "," + longitude + "&size=640x640&sensor=true"; // Set the map zoom level using a rough heuristic var zoomlevel=20; // Start zoomed in almost all the way if (accuracy > 80) // Zoom out for less accurate positions zoomlevel -= Math.round(Math.log(accuracy/50)/Math.LN2); url += "&zoom=" + zoomlevel; // Add zoom level to the URL // Now display the map in the image object. Thanks, Google! image.src = url; } }

The Geolocation API has several features that are not demonstrated by Example 22-1:

In addition to the first callback argument, getCurrentPosition() and watch Position() accept an optional second callback that is invoked if the geolocation request fails.

In addition to the success and error callbacks, those two methods also accept an options object as an optional third argument. The properties of this object specify whether a high accuracy position is desired, how「stale」the position is allowed to be, and how long the system is allowed to take to determine the position.

The object passed to the success callback also includes a timestamp and may (on some devices) include additional information such as altitude, speed, and heading.

Example 22-2 demonstrates these additional features.

Example 22-2. A demonstration of all geolocation features

// Determine my location asynchronously and display it in the specified element. function whereami(elt) { // Pass this object as the 3rd argument to getCurrentPosition() var options = { // Set to true to get a higher accuracy reading (from GPS, for example) // if available. Note, however that this can affect battery life. enableHighAccuracy: false, // Approximate is okay: this is the default // Set this property if a cached location is good enough. // The default is 0, which forces location to be checked anew. maximumAge: 300000, // A fix from the last 5 minutes is okay // How long are you willing to wait to get the location? // The default is Infinity and getCurrentPosition() never times out timeout: 15000 // Don't take more than 15 seconds }; if (navigator.geolocation) // Request position, if supported navigator.geolocation.getCurrentPosition(success, error, options); else elt.innerHTMl = "Geolocation not supported in this browser"; // This function will be invoked if geolocation fails function error(e) { // The error object has a numeric code and a text message. Code values: // 1: the user did not give permission to share his or her location // 2: the browser was unable to determine the position // 3: a timeout occurred elt.innerHTML = "Geolocation error " + e.code + ": " + e.message; } // This function will be invoked if geolocation succeeds function success(pos) { // These are the fields that we always get. Note that the timestamp // is in the outer object, not the inner, coords object. var msg = "At " + new Date(pos.timestamp).toLocaleString() + " you were within " + pos.coords.accuracy + " meters of latitude " + pos.coords.latitude + " longitude " + pos.coords.longitude + "."; // If our device returns altitude, add that information. if (pos.coords.altitude) { msg += " You are " + pos.coords.altitude + " ± " + pos.coords.altitudeAccuracy + "meters above sea level."; } // if our device returns speed and heading, add that, too. if (pos.coords.speed) { msg += " You are travelling at " + pos.coords.speed + "m/s on heading " + pos.coords.heading + "."; } elt.innerHTML = msg; // Display all the position information } }

History Management

Web browsers keep track of what documents have been loaded into a window and display Back and Forward buttons that allow the user to navigate among those documents. This browser history model dates back to the days in which documents were passive and all computation was performed on the server. Today, web applications often generate or load content dynamically and display new application states without performing new document loads. Applications like these must perform their own history management if they want to user to be able to use the Back and Forward buttons to navigate from one application state to another in an intuitive way. HTML5 defines two mechanisms for history management.

The simpler history management technique involves location.hash and the hashchange event. This technique is also somewhat more widely implemented at the time of this writing: browsers were beginning to implement it even before HTML5 standardized it. In most browsers (but not older versions of IE), setting the location.hash property updates the URL displayed in the location bar and adds an entry to the browser’s history. The hash property sets the fragment identifier of the URL and is traditionally used to specify the ID of a document section to scroll to. But location.hash does not have to be an element ID: you can set it to any string. If you can encode your application state as a string, you can use that string as a fragment identifier.

By setting the location.hash property, then, you allow the user to use the Back and Forward buttons to navigate between document states. For this to work, your application must have some way to detect these changes of state, so that it can read the state stored in the fragment identifier and update itself accordingly. In HTML5, the browser fires a hashchange event at the Window whenever the fragment identifier changes. In browsers that support the hashchange event, you can set window.onhashchange to a handler function that will be called whenever the fragment identifier changes as a result of history navigation. When this handler function is called, your function would parse the location.hash value and redisplay the application using the state information it contains.

HTML5 also defines a somewhat more complex and robust method of history management involving the history.pushState() method and the popstate event. When a web app enters a new state, it calls history.pushState() to add that state to the browsing history. The first argument is an object that contains all the state information necessary to restore the current state of the document. Any object that can be converted to a string with JSON.stringify() will work, and certain other native types such as Date and RegExp should also work as well (see the sidebar below). The second argument is an optional title (a plain text string) that the browser can use (in a <Back> menu, for example) to identify the saved state in the browsing history. The third argument is an optional URL that will be displayed as the location of the current state. Relative URLs are resolved against the current location of the document, and it is common to simply specify a hash (or「fragment identifier」) portion of the URL, such as #state. Associating a URL with each state allows the user to bookmark internal states of your application, and if you include sufficient information in the URL, your application can restore its state when loaded from a bookmark.

Structured Clones

As noted above, the pushState() method accepts a state object and makes a private copy of it. This is a deep copy or deep clone of the object: it recursively copies the contents of any nested objects or arrays. The HTML5 standard calls this kind of copy a structured clone. The process of creating a structured clone is something like passing the object to JSON.stringify() and then passing the resulting string to JSON.parse() (see Serializing Objects). But JSON only supports JavaScript primitives plus objects and arrays. The HTML5 standard says that the structured clone algorithm must also be able to clone Date and RegExp objects, ImageData objects (from the <canvas> element: see Pixel Manipulation), and FileList, File, and Blob objects (described in Blobs). JavaScript functions and errors are explicitly excluded from the structured clone algorithm, as are most host objects such as windows, documents, elements, and so on.

You may not have any reason to store files or image data as part of your history state, but structured clones are also used by a number of other HTML5-related standards, and we’ll see them again throughout this chapter.

In addition to the pushState() method, the History object also defines replaceState(), which takes the same arguments but replaces the current history state instead of adding a new state to the browsing history.

When the user navigates to saved history states using the Back or Forward buttons, the browser fires a popstate event on the Window object. The event object associated with the event has a property named state, which contains a copy (another structured clone) of the state object you passed to pushState().

Example 22-3 is a simple web application—the number guessing game pictured in Figure 22-1 —that uses these HTML5 techniques to save its history, allowing the user to「go back」to review or redo her guesses.

As this book goes to press, Firefox 4 has made two modifications to the History API that other browsers may follow. First, Firefox 4 makes the current state available through the state property of the History object itself, which means that newly loaded pages do not need to wait for a popstate event. Second, Firefox 4 no longer fires a popstate event for newly loaded pages that do not have any saved state. This second change means that the example below does not work quite right in Firefox 4.

Figure 22-1. A number guessing game

Example 22-3. History management with pushState()

<!DOCTYPE html> <html><head><title>I'm thinking of a number...</title> <script> window.onload = newgame; // Start a new game when we load window.onpopstate = popState; // Handle history events var state, ui; // Globals initialized in newgame() function newgame(playagain) { // Begin a new game of guess-the-number // Set up an object to hold document elements we care about ui = { heading: null, // The <h1> at the top of the document. prompt: null, // Ask the user to enter a guess. input: null, // Where the user enters the guess. low: null, // Three table cells for the visual representation mid: null, // ...of the range of numbers to guess. high: null }; // Look up each of these element ids for(var id in ui) ui[id] = document.getElementById(id); // Define an event handler for the input field ui.input.onchange = handleGuess; // Pick a random number and initialize game state state = { n: Math.floor(99 * Math.random()) + 1, // An integer: 0 < n < 100 low: 0, // The lower bound (exclusive) on guesses high: 100, // The upper bound (exclusive) on guesses guessnum: 0, // How many guesses have been made guess: undefined // What the last guess was }; // Modify document content to display this initial state display(state); // This function is called as the onload event handler, and is also called // by the Play Again button displayed at the end of a game. The playagain // argument will be true in that second case. If it is true, then we save // the new game state. But if we were called in response to a load event, // we don't save the state. This is because load events will also occur // when we step backwards through the browser history from some other // document into the existing state of a game. If we were to save a new // initial state, in that case we would overwrite the acutal historical // state of the game. In browsers that support pushState(), the load event // is always followed by a popstate event. So rather than saving state here, // we wait for the popstate. If it gives us a state object, we just use // that. Otherwise, if the popstate has a null state, we know this is // really a new game and we use replaceState to save the new game state. if (playagain === true) save(state); } // Save game state into browser history with pushState(), if it is supported function save(state) { if (!history.pushState) return; // Do nothing if pushState() not defined // We'll associate a URL with the saved state. This URL displays the // guess number, but does not encode the game state, so it is not useful // to bookmark. We can't easily put game state in the URL because it would // make the secret number visible in the location bar. var url = "#guess" + state.guessnum; // Now save the state object and the URL history.pushState(state, // State object to save "", // State title: current browsers ignore this url); // State URL: not useful to bookmark } // This is the onpopstate event handler that restores historical states. function popState(event) { if (event.state) { // If the event has a state object, restore that state // Note that event.state is a deep copy of the saved state object // so we can modify it without altering the saved value. state = event.state; // Restore the historical state display(state); // Display the restored state } else { // When we load the page for the first time, we'll get a popstate event // with no state. Replace that null state with our real state: see the // comment in newgame(). No need to call display() here. history.replaceState(state, "", "#guess" + state.guessnum); } }; // This event handler is invoked each time the user guesses a number. // It updates the game state, saves it, and displays it. function handleGuess() { // Get the user's guess from the input field var g = parseInt(this.value); // If it is a number and is in the right range if ((g > state.low) && (g < state.high)) { // Update the state object based on this guess if (g < state.n) state.low = g; else if (g > state.n) state.high = g; state.guess = g; state.guessnum++; // Now save the new state in the browser's history save(state); // Modify the document to respond to the user's guess display(state); } else { // An invalid guess: don't push a new history state alert("Please enter a number greater than " + state.low + " and less than " + state.high); } } // Modify the document to display the current state of the game. function display(state) { // Display document heading and title ui.heading.innerHTML = document.title = "I'm thinking of a number between " + state.low + " and " + state.high + "."; // Display a visual representation of the range of numbers using a table ui.low.style.width = state.low + "%"; ui.mid.style.width = (state.high-state.low) + "%"; ui.high.style.width = (100-state.high) + "%"; // Make sure the input field is visible, empty, and focused ui.input.style.visibility = "visible"; ui.input.value = ""; ui.input.focus(); // Set the prompt based on the user's most recent guess if (state.guess === undefined) ui.prompt.innerHTML = "Type your guess and hit Enter: "; else if (state.guess < state.n) ui.prompt.innerHTML = state.guess + " is too low. Guess again: "; else if (state.guess > state.n) ui.prompt.innerHTML = state.guess + " is too high. Guess again: "; else { // When correct, hide the input field and show a Play Again button. ui.input.style.visibility = "hidden"; // No more guesses now ui.heading.innerHTML = document.title = state.guess + " is correct! "; ui.prompt.innerHTML = "You Win! <button onclick='newgame(true)'>Play Again</button>"; } } </script> <style> /* CSS styles to make the game look good */ #prompt { font-size: 16pt; } table { width: 90%; margin:10px; margin-left:5%; } #low, #high { background-color: lightgray; height: 1em; } #mid { background-color: green; } </style> </head> <body><!-- The HTML elements below are the game UI --> <!-- Game title and textual representation of the range of numbers --> <h1 id="heading">I'm thinking of a number...</h1> <!-- a visual representation of the numbers that haven't been ruled out --> <table><tr><td id="low"></td><td id="mid"></td><td id="high"></td></tr></table> <!-- Where the user enters their guess --> <label id="prompt"></label><input id="input" type="text"> </body></html>

Cross-Origin Messaging

As noted in Multiple Windows and Frames, some browser windows and tabs are completely isolated from each other, and the code running in one is completely unaware of the others. In other cases, when a script explicitly opens new windows or works with nested frames, the multiple windows and frames are aware of each other. If they contain documents from the same web server, scripts in these windows and frames can interact with each other and manipulate each other’s documents.

Sometimes, however, a script can refer to another Window object, but because the content in that window is from a different origin, the web browser (following the same-origin policy) will not allow the script to see the document content of that other window. For the most part, the browser won’t allow the script to read properties or invoke methods of that other window, either. One window method that scripts from different origins are allowed to invoke is called postMessage(), and this method enables a limited kind of communication—in the form of asynchronous message passing—between scripts from different origins. This kind of communication is defined by HTML5 and is implemented by all current browsers (including IE8 and later). The technique is known as「cross-document messaging,」but since the API is defined on the Window object instead of the document, it might be better known as「inter-window message passing」or「cross-origin messaging.」

The postMessage() method expects two arguments. The first is the message to be sent. The HTML5 specification says that this can be any primitive value or object that can be cloned (see Structured Clones), but some current browser implementations (including Firefox 4 beta) expect strings, so if you want to pass an object or array as a message you should serialize it with JSON.stringify() (Serializing Objects) first.

The second argument is a string that specifies the expected origin of the destination window. Include the protocol, hostname, and (optionally) the port portions of a URL (you can pass a complete URL, but anything other than the protocol, host, and port will be ignored). This is a security feature: malicious code or ordinary users can navigate windows to new documents that you don’t expect, so postMessage() won’t deliver your message if the window contains a document from a different origin than the one you specified. If the message you are passing doesn’t contain any sensitive information and you are willing to pass it to code from any origin, you can pass the string "*" as a wildcard instead. If you want to specify the same origin as the current window, you can simply use "/".

If the origins match, the call to postMessage() will result in a message event being fired at the target Window object. A script in that window can define an event handler function to be notified of message events. This handler is passed an event object with the following properties:

data

This is a copy of the message that was passed as the first argument to postMessage().

source

The Window object from which the message was sent.

origin

A string that specifies the origin (as a URL) from which the message was sent.

Most onmessage() handlers should first check the origin property of their argument and should ignore messages from unexpected domains.

Cross-origin messaging via postMessage() and the message event can be useful when you want to include a module or「gadget」from another site within your web page. If the gadget is simple and self-contained, you can simply isolate it in an <iframe>. Suppose, however, that it is a more complex gadget that defines an API and your web page has to control it or interact with it somehow. If the gadget is defined as a <script> element, it can expose a normal JavaScript API, but including in your page allows it to take complete control of the page and its content. It is not uncommon to do this on the Web today (particularly for web advertising), but it is not really a good idea, even when you trust the other site.

Cross-origin messaging provides an alternative: the gadget author can package the gadget within an HTML file that listens for message events and dispatches those events to the appropriate JavaScript functions. Then the web page that includes the gadget can interact with it by sending messages with postMessage(). Examples 22-4 and 22-5 demonstrate this. Example 22-4 is a simple gadget, included via <iframe>, that searches Twitter and displays tweets that match a specified search term. To make this gadget search for something, the containing page simply sends it the desired search term as a message.

Example 22-4. A Twitter search gadget, controlled by postMessage()

<!DOCTYPE html> <!-- This is a Twitter search gadget. Include it in any webpage, inside an iframe, and ask it to search for things by sending it a query string with postMessage(). Since it is in an <iframe> and not a <script>, it can't mess around with the containing document. --> <html> <head> <style>body { font: 9pt sans-serif; }</style> <!-- Use jQuery for its jQuery.getJSON() utility --> <script src="http://code.jquery.com/jquery-1.4.4.min.js"/></script> <script> // We ought to just be able to use window.onmessage, but some older browsers // (e.g., Firefox 3) don't support it, so we do it this way instead. if (window.addEventListener) window.addEventListener("message", handleMessage, false); else window.attachEvent("onmessage", handleMessage); // For IE8 function handleMessage(e) { // We don't care what the origin of this message is: we're willing // to search Twitter for anyone who asks us. We do expect the message // to come from the window that contains us, however. if (e.source !== window.parent) return; var searchterm = e.data; // This is what we were asked to search for // Use jQuery Ajax utlities and the Twitter search API to find // tweets matching the message. jQuery.getJSON("http://search.twitter.com/search.json?callback=?", { q: searchterm }, function(data) { // Called with request results var tweets = data.results; // Build an HTML document to display these results var escaped = searchterm.replace("<", "&lt;"); var html = "<h2>" + escaped + "</h2>"; if (tweets.length == 0) { html += "No tweets found"; } else { html += "<dl>"; // <dl> list of results for(var i = 0; i < tweets.length; i++) { var tweet = tweets[i]; var text = tweet.text; var from = tweet.from_user; var tweeturl = "http://twitter.com/#!/" + from + "/status/" + tweet.id_str; html += "<dt><a target='_blank' href='" + tweeturl + "'>" + tweet.from_user + "</a></dt><dd>" + tweet.text + "</dd>"; } html += "</dl>"; } // Set the <iframe> document document.body.innerHTML = html; }); } $(function() { // Let our container know we're here and ready to search. // The container can't send any messages to us before it gets this message // from us because we won't be here to receive the message yet. // Normally, containers can just wait for an onload event to know that all // of their <iframe>s have loaded. We send this message for containers that // want to start searching Twitter even before they get their onload event. // We don't know the origin of our container, so use * so that the browser // will deliver it to anyone. window.parent.postMessage("Twitter Search v0.1", "*"); }); </script> </head> <body> </body> </html>

Example 22-5 is a simple JavaScript file that can be inserted into any web page that wants to use the Twitter search gadget. It inserts the gadget into the document and then adds an event handler to all links in the document so that moving the mouse over a link calls postMessage() on the gadget’s frame to make the gadget search for the URL of the link. This allows a user to see what, if anything, people are tweeting about a website before visiting the site.

Example 22-5. Using the Twitter search gadget with postMessage()

// This file of JS code inserts the Twitter Search Gadget into the document // and adds an event handler to all links in the document so that when the // use moves the mouse over them, the gadget searches for the link's URL. // This allows the user to see what people are tweeting about the link // destination before clicking on it. window.addEventListener("load", function() { // Won't work in IE < 9 var origin = "http://davidflanagan.com"; // Gadget origin var gadget = "/demos/TwitterSearch.html"; // Gadget path var iframe = document.createElement("iframe"); // Create the iframe iframe.src = origin + gadget; // Set its URL iframe.width = "250"; // 250 pixels wide iframe.height = "100%"; // Full document height iframe.style.cssFloat = "right"; // Flush right // Insert the iframe at the start of the document document.body.insertBefore(iframe, document.body.firstChild); // Now find all links and hook them up to the gadget var links = document.getElementsByTagName("a"); for(var i = 0; i < links.length; i++) { // addEventListener doesn't work in IE8 and before links[i].addEventListener("mouseover", function() { // Send the url as the search term, and only deliver it if the // iframe is still displaying a document from davidflanagan.com iframe.contentWindow.postMessage(this.href, origin); }, false); } }, false);

Web Workers

One of the fundamental features of client-side JavaScript is that it is single-threaded: a browser will never run two event handlers at the same time, and it will never trigger a timer while an event handler is running, for example. Concurrent updates to application state or to the document are simply not possible, and client-side programmers do not need to think about, or even understand, concurrent programming. A corollary is that client-side JavaScript functions must not run too long: otherwise they will tie up the event loop and the web browser will become unresponsive to user input. This is the reason that Ajax APIs are always asynchronous and the reason that client-side JavaScript cannot have a simple, synchronous load() or require() function for loading JavaScript libraries.

The Web Workers specification[54] very carefully relaxes the single-threaded requirement for client-side JavaScript. The「workers」it defines are effectively parallel threads of execution. Web workers live in a self-contained execution environment, however, with no access to the Window or Document object and can communicate with the main thread only through asynchronous message passing. This means that concurrent modifications of the DOM are still not possible, but it also means that there is now a way to use synchronous APIs and write long-running functions that do not stall the event loop and hang the browser. Creating a new worker is not a heavyweight operation like opening a new browser window, but workers are not flyweight threads either, and it does not make sense to create new workers to perform trivial operations. Complex web applications may find it useful to create tens of workers, but it is unlikely that an application with hundreds or thousands of workers would be practical.

As with any threading API, there are two pieces to the Web Workers specification. The first is the Worker object: this is what a worker looks like from the outside, to the thread that creates it. The second is the WorkerGlobalScope: this is the global object for a new worker, and it is what a worker thread looks like, on the inside, to itself. The subsections that follow explain both. They are followed by a section of examples.

Worker Objects

To create a new worker, just use the Worker() constructor, passing a URL that specifies the JavaScript code that the worker is to run:

var loader = new Worker("utils/loader.js");

If you specify a relative URL, it is resolved relative to the URL of the document that contains the script that called the Worker() constructor. If you specify an absolute URL, it must have the same origin (same protocol, host, and port) as that containing document.

Once you have a Worker object, you can send data to it with postMessage(). The value you pass to postMessage() will be cloned (see Structured Clones), and the resulting copy will be delivered to the worker via a message event:

loader.postMessage("file.txt");

Note that the postMessage() method of a Worker does not have the origin argument that the postMessage() method of a Window does (Cross-Origin Messaging). Also, the postMessage() method of a Worker correctly clones the message in current browsers, unlike Window .postMessage(), which is still restricted to string messages in some important browsers.

You can receive messages from a worker by listening for message events on the Worker object:

worker.onmessage = function(e) { var message = e.data; // Get message from event console.log("URL contents: " + message); // Do something with it }

If a worker throws an exception and does not catch or handle it itself, that exception propagates as an event that you can listen for:

worker.onerror = function(e) { // Log the error message, including worker filename and line number console.log("Error at " + e.filename + ":" + e.lineno + ": " + e.message); }

Like all event targets, Worker objects define the standard addEventListener() and removeEventListener() methods, and you can use these in place of the onmessage and onerror properties if you want to manage multiple event handlers.

The Worker object has just one other method, terminate(), which forces a worker thread to stop running.

Worker Scope

When you create a new worker with the Worker() constructor, you specify the URL of a file of JavaScript code. That code is executed in a new, pristine JavaScript execution environment, completely isolated from the script that created the worker. The global object for that new execution environment is a WorkerGlobalScope object. A WorkerGlobalScope is something more than the core JavaScript global object, but less than a full-blown client-side Window object.

The WorkerGlobalScope object has a postMessage() method and an onmessage event handler property that are just like those of the Worker object but work in the opposite direction: calling postMessage() inside a worker generates a message event outside the worker, and messages sent from outside the worker are turned into events and delivered to the onmessage handler. Note that since the WorkerGlobalScope is the global object for a worker, postMessage() and onmessage look like a global function and global variable to worker code.

The close() function allows a worker to terminate itself, and it is similar in effect to the terminate() method of a Worker object. Note, however, that there is no API on the Worker object to test whether a worker has closed itself, and there is no onclose event handler property, either. If you call postMessage() on a worker that has closed, your message will be discarded silently and no error will be raised. In general, if a worker is going to close() itself, it may be a good idea to first post some kind of「closing」message.

The most interesting global function defined by WorkerGlobalScope is importScripts(): workers use this function to load any library code they require. For example:

// Before we start working, load the classes and utilities we'll need importScripts("collections/Set.js", "collections/Map.js", "utils/base64.js");

importScripts() takes one or more URL arguments, each of which should refer to a file of JavaScript code. Relative URLs are resolved relative to the URL that was passed to the Worker() constructor. It loads and executes these files one after the other, in the order in which they were specified. If loading a script causes a network error, or if executing throws an error of any sort, none of the subsequent scripts are loaded or executed. A script loaded with importScripts() can itself call importScripts() to load the files it depends on. Note, however, that importScripts() does not try to keep track of what scripts have already loaded and does nothing to prevent dependency cycles.

importScripts() is a synchronous function: it does not return until all of the scripts have loaded and executed. You can start using the scripts you loaded as soon as importScripts() returns: there is no need for a callback or event handler. Once you have internalized the asynchronous nature of client-side JavaScript, it can seem strange to go back to simple, synchronous programming again. But that is the beauty of threads: you can use a blocking function call in a worker without blocking the event loop in the main thread, and without blocking the computations being concurrently performed in other workers.

Worker Execution Model

Worker threads run their code (and all imported scripts) synchronously from top to bottom, and then enter an asynchronous phase in which they respond to events and timers. If a worker registers an onmessage event handler, it will never exit as long as there is a possibility that message events will still arrive. But if a worker doesn’t listen for messages, it will run until there are no further pending tasks (such as download and timers) and all task-related callbacks have been called. Once all registered callbacks have been called, there is no way a worker can begin a new task, so it is safe for the thread to exit. Imagine a worker with no onmessage event handler that downloads a file using XMLHttpRequest. If the onload handler for that download begins a new download or registers a timeout with setTimeout(), the thread has new tasks and keeps running. Otherwise, the thread exits.

Since WorkerGlobalScope is the global object for workers, it has all of the properties of the core JavaScript global object, such as the JSON object, the isNaN() function, and the Date() constructor. (Look up Global in the core language reference section for a complete list.) In addition, however, WorkerGlobalScope also has the following properties of the client-side Window object:

self is a reference to the global object itself. Note, however, that WorkerGlobalScope does not have the synonymous window property that Window objects have.

The timer methods setTimeout(), clearTimeout(), setInterval() and clearInterval().

A location property that describes the URL that was passed to the Worker() constructor. This property refers to a Location object, just as the location property of a Window does. The Location object has properties href, protocol, host, hostname, port, pathname, search, and hash. In a worker, these properties are read-only.

A navigator property that refers to an object with properties like those of the Navigator object of a window. A worker’s navigator object has properties appName, appVersion, platform, userAgent, and onLine.

The usual event target methods addEventListener() and removeEventListener().

An onerror property that you can set to an error handler function like the Window .onerror handler described in Error Handling. An error handler, if you register one, is passed the error message, URL, and line number as three string arguments. It can return false to indicate that the error has been handled and should not be propagated as an error event on the Worker object. (At the time of this writing, however, error handling within a worker is not implemented interoperably across browsers.)

Finally, the WorkerGlobalScope object includes important client-side JavaScript constructor objects. These include XMLHttpRequest() so that workers can perform scripted HTTP (see Chapter 18) and the Worker() constructor so that workers can create their own worker threads. (At the time of this writing, the Worker() constructor is not available to workers in Chrome and Safari, however.)

A number of the HTML5 APIs described later in this chapter define features that are available through both an ordinary Window object and also in workers through the WorkerGlobalScope. Often, the Window object will define an asynchronous API and the WorkerGlobalScope will add a synchronous version of the same basic API. These「worker-enabled」APIs will be described when we come to them later in the chapter.

Advanced Worker Features

The worker threads described in this section are dedicated workers: they are associated with, or dedicated to, a single parent thread. The Web Workers specification defines another type of worker, the shared worker. As I write this, browsers do not yet implement shared workers. The intent, however, is that a shared worker is a kind of named resource that can provide a computational service to any thread that cares to connect to it. In practice, interacting with a shared worker is like communicating with a server over a network socket.

The「socket」for a shared worker is known as a MessagePort. MessagePorts define a message-passing API like we’ve seen for dedicated workers and cross-document messaging: they have a postMessage() method and an onmessage event handler attribute. HTML5 allows you to create connected pairs of MessagePort objects with the MessageChannel() constructor. You can pass MessagePorts (via a special postMessage() argument) to other windows or other workers and use them as dedicated communication channels. MessagePorts and MessageChannels are an advanced API that is not yet supported by many browsers and is not covered here.

Web Worker Examples

We’ll end this section with two Web Worker examples. The first demonstrates how to perform long computations in a worker thread so that they don’t affect the UI responsiveness of the main thread. The second example demonstrates how worker threads can use simpler synchronous APIs.

Example 22-6 defines a smear() function that expects an <img> element as its argument. It applies a motion blur effect to「smear」the image to the right. It uses techniques from Chapter 21 to copy the image to an offscreen <canvas> element and then to extract the image’s pixels to an ImageData object. You cannot pass an <img> or a <canvas> element to a worker via postMessage(), but you can pass an ImageData object (details are in Structured Clones). Example 22-6 creates a Worker object and calls postMessage() to send it the pixels to be smeared. When the worker sends the processed pixels back, the code copies them back into the <canvas>, extracts them as a data:// URL, and sets that URL on the src property of the original <img> element.

Example 22-6. Creating a Web Worker for image processing

// Asynchronously replace the contents of the image with a smeared version. // Use it like this: <img src="testimage.jpg" onclick="smear(this)"/> function smear(img) { // Create an offscreen <canvas> the same size as the image var canvas = document.createElement("canvas"); canvas.width = img.width; canvas.height = img.height; // Copy the image into the canvas, then extract its pixels var context = canvas.getContext("2d"); context.drawImage(img, 0, 0); var pixels = context.getImageData(0,0,img.width,img.height) // Send the pixels to a worker thread var worker = new Worker("SmearWorker.js"); // Create worker worker.postMessage(pixels); // Copy and send pixels // Register a handler to get the worker's response worker.onmessage = function(e) { var smeared_pixels = e.data; // Pixels from worker context.putImageData(smeared_pixels, 0, 0); // Copy them to the canvas img.src = canvas.toDataURL(); // And then to the img worker.terminate(); // Stop the worker thread canvas.width = canvas.height = 0; // Don't keep pixels around } }

Example 22-7 is the code used by the worker thread created in Example 22-6. The bulk of this example is the image processing function: a modified version of the code from Example 21-10. Note that this example sets up its message-passing infrastructure in a single line of code: the onmessage event handler simply smears the image it is passed and posts it right back.

Example 22-7. Image processing in a Web Worker

// Get an ImageData object from the main thread, process it, send it back onmessage = function(e) { postMessage(smear(e.data)); } // Smear the ImageData pixels to the right, producing a motion blur. // For large images, this function does a lot of computation and would // cause UI responsiveness issues if it was used on the main thread. function smear(pixels) { var data = pixels.data, width = pixels.width, height = pixels.height; var n = 10, m = n-1; // Make n bigger for more smearing for(var row = 0; row < height; row++) { // For each row var i = row*width*4 + 4; // 2nd pixel offset for(var col = 1; col < width; col++, i += 4) { // For each column data[i] = (data[i] + data[i-4]*m)/n; // Red pixel component data[i+1] = (data[i+1] + data[i-3]*m)/n; // Green data[i+2] = (data[i+2] + data[i-2]*m)/n; // Blue data[i+3] = (data[i+3] + data[i-1]*m)/n; // Alpha component } } return pixels; }

Note that the code in Example 22-7 can process any number of images that are sent to it. For simplicity, however, Example 22-6 creates a new Worker object for each image it processes. To ensure that the worker does not just sit around waiting for messages, it kills the thread with terminate() when done.

Debugging Workers

One of the APIs not available (at least as I write this) in WorkerGlobalScope is the console API and its invaluable console.log() function. Worker threads can’t log output and can’t interact with the document at all, so they can be tricky to debug. If a worker throws an error, the main thread will receive an error event on the Worker object. But often, you need a way for a worker to output debugging messages that are visible in the browser’s web console. One straightforward way to do this is to modify the message passing protocol you use with the worker so that the worker can send debugging messages somehow. In Example 22-6, for example, we could insert the following code at the start of the onmessage event handler:

if (typeof e.data === "string") { console.log("Worker: " + e.data); return; }

With that additional code in place, the Worker thread could display debugging messages simply by passing strings to postMessage().

The next example demonstrates how Web Workers allow you to write synchronous code and use it safely in client-side JavaScript. Synchronous responses showed how to make synchronous HTTP requests with XMLHttpRequest, but it warned that doing so on the main browser thread was a very bad practice. In a worker thread, however, it is perfectly reasonable to make synchronous requests, and Example 22-8 demonstrates worker code that does just that. Its onmessage event handler expects an array of URLs to be fetched. It uses the synchronous XMLHttpRequest API to fetch them, and then posts the textual content of the URLs as an array of strings back to the main thread. Or, if any of the HTTP requests fail, it throws an error that propagates to the onerror handler of the Worker.

Example 22-8. Making synchronous XMLHttpRequests in a Web Worker

// This file will be loaded with new Worker(), so it runs as an independent // thread and can safely use the synchronous XMLHttpRequest API. // Messages are expected to be arrays of URLs. Synchronously fetch the // contents of each URL as a string and send back an array of those strings. onmessage = function(e) { var urls = e.data; // Our input: the URLs to fetch var contents = []; // Our output: the contents of those URLs for(var i = 0; i < urls.length; i++) { var url = urls[i]; // For each URL var xhr = new XMLHttpRequest(); // Begin an HTTP request xhr.open("GET", url, false); // false makes this synchronous xhr.send(); // Blocks until response is complete if (xhr.status !== 200) // Throw an error if request failed throw Error(xhr.status + " " + xhr.statusText + ": " + url); contents.push(xhr.responseText); // Otherwise, store the URL contents } // Finally, send the array of URL contents back to the main thread postMessage(contents); }

* * *

[54] Web workers were originally part of the HTML5 specification, but they were broken off into an independent, but closely related specification. At the time of this writing, specification drafts are available at http://dev.w3.org/html5/workers/ and http://whatwg.org/ww.

Typed Arrays and ArrayBuffers

As you know from Chapter 7, JavaScript arrays are general-purpose objects with numeric properties and a special length property. Array elements can be any JavaScript value. Arrays can grow or shrink dynamically and can be sparse. JavaScript implementations perform lots of optimizations so that typical uses of JavaScript arrays are very fast. Typed arrays are array-like objects (Array-Like Objects) that differ from regular arrays in some important ways:

The elements of a typed array are all numbers. The constructor used to create the typed array determines the type (signed or unsigned integers or floating point) and size (in bits) of the numbers.

Typed arrays have a fixed length.

The elements of a typed array are always initialized to 0 when the array is created.

There are eight kinds of typed arrays, each with a different element type. You can create them with the following constructors:

ConstructorNumeric type

Int8Array() signed bytes

Uint8Array() unsigned bytes

Int16Array() signed 16-bit short integers

Uint16Array() unsigned 16-bit short integers

Int32Array() signed 32-bit integers

Uint32Array() unsigned 32-bit integers

Float32Array() 32-bit floating-point value

Float64Array() 64-bit floating-point value: a regular JavaScript number

Typed Arrays, <canvas>, and Core JavaScript

Typed arrays are an essential part of the WebGL 3D graphics API for the <canvas> element, and browsers have implemented them as part of WebGL. WebGL is not covered in this book, but typed arrays are generally useful and are covered here. You may recall from Chapter 21 that the Canvas API defines a getImageData() method that returns an ImageData object. The data property of an ImageData is an array of bytes. The HTML standard calls this a CanvasPixelArray, but it is essentially the same as the Uint8Array described here, except for the way it handles values outside of the range 0 to 255.

Note that these types are not part of the core language. A future version of the JavaScript language is likely to include support for typed arrays like these, but at the time of this writing, it is unclear whether the language will adopt the API described here or will create a new API.

When you create a typed array, you pass the array size to the constructor or pass an array or typed array to initialize the array elements with. Once you have created a typed array, you can read and write its elements with regular square-bracket notation, just as you would with any other array-like object:

var bytes = new Uint8Array(1024); // One kilobyte of bytes for(var i = 0; i < bytes.length; i++) // For each element of the array bytes[i] = i & 0xFF; // Set it to the low 8 bits of index var copy = new Uint8Array(bytes); // Make a copy of the array var ints = new Int32Array([0,1,2,3]); // A typed array holding these 4 ints

Modern JavaScript implementations optimize arrays to make them very efficient. Nevertheless, typed arrays can be even more efficient in both execution time and memory use. The following function computes the largest prime number less than the value you specify. It uses the Sieve of Eratosthenes algorithm, which requires a large array to keep track of which numbers are prime and which are composite. Since only a single bit of information is required for each array element, an Int8Array can be used more efficiently than a regular JavaScript array:

// Return the largest prime smaller than n, using the sieve of Eratosthenes function sieve(n) { var a = new Int8Array(n+1); // a[x] will be 1 if x is composite var max = Math.floor(Math.sqrt(n)); // Don't do factors higher than this var p = 2; // 2 is the first prime while(p <= max) { // For primes less than max for(var i = 2*p; i <= n; i += p) // Mark multiples of p as composite a[i] = 1; while(a[++p]) /* empty */; // The next unmarked index is prime } while(a[n]) n--; // Loop backward to find the last prime return n; // And return it }

The sieve() function continues to work if you replace the Int8Array() constructor with the traditional Array() constructor, but it runs two to three times more slowly and requires substantially more memory for large values of the parameter n. You might also find typed arrays useful when working with numbers for graphics or mathematics:

var matrix = new Float64Array(9); // A 3x3 matrix var 3dPoint = new Int16Array(3); // A point in 3D space var rgba = new Uint8Array(4); // A 4-byte RGBA pixel value var sudoku = new Uint8Array(81); // A 9x9 sudoku board

JavaScript square-bracket notation allows you to get and set individual elements of a typed array. But typed arrays also define methods for setting and querying entire regions of the array. The set() method copies the elements of regular or typed arrays into a typed array:

var bytes = new Uint8Array(1024) // A 1K buffer var pattern = new Uint8Array([0,1,2,3]); // An array of 4 bytes bytes.set(pattern); // Copy them to the start of another byte array bytes.set(pattern, 4); // Copy them again at a different offset bytes.set([0,1,2,3], 8); // Or just copy values direct from a regular array

Typed arrays also have a subarray method that returns a portion of the array on which it is called:

var ints = new Int16Array([0,1,2,3,4,5,6,7,8,9]); // 10 short integers var last3 = ints.subaarray(ints.length-3, ints.length); // Last 3 of them last3[0] // => 7: this is the same as ints[7]

Note that subarray() does not make a copy of the data. It just returns a new view of the same underlying values:

ints[9] = -1; // Change a value in the original array and... last3[2] // => -1: it also changes in the subarray

The fact that the subarray() method returns a new view of an existing array reveals something important about typed arrays: they are all views on an underlying chunk of bytes known as an ArrayBuffer. Every typed array has three properties that relate to the underlying buffer:

last3.buffer // => returns an ArrayBuffer object last3.buffer == ints.buffer // => true: both are views of the same buffer last3.byteOffset // => 14: this view starts at byte 14 of the buffer last3.byteLength // => 6: this view is 6 bytes (3 16-bit ints) long

The ArrayBuffer object itself has only a single property that returns its length:

last3.byteLength // => 6: this view is 6 bytes long last3.buffer.byteLength // => 20: but the underlying buffer has 20 bytes

ArrayBuffers are just opaque chunks of bytes. You can access those bytes with typed arrays, but an ArrayBuffer is not itself a typed array. Be careful, however: you can use numeric array indexing with ArrayBuffers just as you can with any JavaScript object. Doing so does not give you access to the bytes in the buffer, however:

var bytes = new Uint8Array(8); // Allocate 8 bytes bytes[0] = 1; // Set the first byte to 1 bytes.buffer[0] // => undefined: buffer doesn't have index 0 bytes.buffer[1] = 255; // Try incorrectly to set a byte in the buffer bytes.buffer[1] // => 255: this just sets a regular JS property bytes[1] // => 0: the line above did not set the byte

You can create ArrayBuffers directly with the ArrayBuffer() constructor, and, given an ArrayBuffer object, you can create any number of typed array views of that buffer:

var buf = new ArrayBuffer(1024*1024); // One megabyte var asbytes = new Uint8Array(buf); // Viewed as bytes var asints = new Int32Array(buf); // Viewed as 32-bit signed integer var lastK = new Uint8Array(buf,1023*1024); // Last kilobyte as bytes var ints2 = new Int32Array(buf, 1024, 256); // 2nd kilobyte as 256 integers

Typed arrays allow you to view the same sequence of bytes in chunks of 8, 16, 32, or 64 bits. This exposes the「endianness」: the order in which bytes are arranged into longer words. For efficiency, typed arrays use the native endianness of the underlying hardware. On little-endian systems, the bytes of a number are arranged in an ArrayBuffer from least significant to most significant. On big-endian platforms, the bytes are arranged from most significant to least significant. You can determine the endianness of the underlying platform with code like this:

// If the integer 0x00000001 is arranged in memory as 01 00 00 00, then // we're on a little endian platform. On a big-endian platform we'd get // get bytes 00 00 00 01 instead. var little_endian = new Int8Array(new Int32Array([1]).buffer)[0] === 1;

Today, the most common CPU architectures are little-endian. Many network protocols, however, and some binary file formats, require big-endian byte ordering. In Blobs, you’ll learn how you can use ArrayBuffers to hold bytes read from files or downloaded from the network. When you do this, you can’t just assume that the platform endianness matches the byte order of the data. In general, when working with external data, you can use Int8Array and Uint8Array to view the data as an array of individual bytes, but you should not use the other typed arrays with multibyte word sizes. Instead, you can use the DataView class, which defines methods for reading and writing values from an ArrayBuffer with explicitly specified byte ordering:

var data; // Assume this is an ArrayBuffer from the network var view = DataView(data); // Create a view of it var int = view.getInt32(0); // Big-endian 32-bit signed int from byte 0 int = view.getInt32(4,false); // Next 32-bit int is also big-endian int = view.getInt32(8,true) // Next 4 bytes as a little-endian signed int view.setInt32(8,int,false); // Write it back in big-endian format

DataView defines eight get methods for each of the eight typed array formats. They have names like getInt16(), getUint32(), and getFloat64(). The first argument is the byte offset within the ArrayBuffer at which the value begins. All of these getter methods, other than getInt8() and getUint8(), accept an optional boolean value as their second argument. If the second argument is omitted or is false, big-endian byte ordering is used. If the second argument is true, little-endian ordering is used.

DataView defines eight corresponding set methods that write values into the underlying ArrayBuffer. The first argument is the offset at which the value begins. The second argument is the value to write. Each of the methods, except setInt8() and setUint8(), accepts an optional third argument. If the argument is omitted or is false, the value is written in big-endian format with most significant byte first. If the argument is true, the value is written in little-endian format with the least significant byte first.

Blobs

A Blob is an opaque reference to, or handle for, a chunk of data. The name comes from SQL databases, where it means「Binary Large Object.」In JavaScript, Blobs often represent binary data, and they can be large, but neither is required: a Blob could also represent the contents of a small text file. Blobs are opaque: all you can do with them directly is determine their size in bytes, ask for their MIME type, and chop them up into smaller Blobs:

var blob = ... // We'll see how to obtain a Blob later blob.size // Size of the Blob in bytes blob.type // MIME type of the Blob, or "" if unknown var subblob = blob.slice(0,1024, "text/plain"); // First 1K of the Blob as text var last = blob.slice(blob.size-1024, 1024); // Last 1K of the Blob, untyped

The web browser can store Blobs in memory or on disk, and Blobs can represent really enormous chunks of data (such as video files) that are too large to fit in main memory without first being broken into smaller pieces with slice(). Because Blobs can be so large and may require disk access, the APIs that work with them are asynchronous (with synchronous versions available for use by worker threads).

Blobs are not terribly interesting by themselves, but they serve as a critical data interchange mechanism for various JavaScript APIs that work with binary data. Figure 22-2 illustrates how Blobs can be read from and written to the Web, the local filesystem, local databases, and also other windows and workers. It also shows how Blob content can be accessed as text, as typed arrays, or as URLs.

Figure 22-2. Blobs and the APIs that use them

Before you can work with a Blob, you must obtain one somehow. There are a number of ways to do this, some involving APIs we’ve already covered and some involving APIs that are described later in this chapter:

Blobs are supported by the structured clone algorithm (see Structured Clones), which means that you can obtain one from another window or thread via the message event. See Cross-Origin Messaging and Web Workers.

Blobs can be retrieved from client-side databases, as described in Client-Side Databases.

Blobs can be downloaded from the web via scripted HTTP, using cutting-edge features of the XHR2 specification. This is covered in Downloading Blobs.

You can create your own blobs, using a BlobBuilder object to build them out of strings, ArrayBuffer objects (Typed Arrays and ArrayBuffers), and other Blobs. The BlobBuilder object is demonstrated in Building Blobs.

Finally, and most importantly, the client-side JavaScript File object is a subtype of Blob: a File is just a Blob of data with a name and a modification date. You can obtain File objects from <input type="file"> elements and from the drag-and-drop API, as explained in Files As Blobs. File objects can also be obtained using the Filesystem API, which is covered in The Filesystem API.

Once you have a Blob, there are various things you can do with it, many of them symmetrical to the items above:

You can send a Blob to another window or worker thread with postMessage(). See Cross-Origin Messaging and Web Workers.

You can store a Blob in a client-side database. See Client-Side Databases.

You can upload a Blob to a server by passing it to the send() method of an XMLHttpRequest object. The file upload example (Example 18-9) demonstrated how to do this (remember, a File object is just a specialized kind of Blob).

You can use the createObjectURL() function to obtain a special blob:// URL that refers to the content of a Blob, and then use this URL with the DOM or with CSS. Blob URLs demonstrates this.

You can use a FileReader object to asynchronously (or synchronously, in a worker thread) extract the content of a Blob into a string or ArrayBuffer. Reading Blobs demonstrates the basic technique.

You can use the Filesystem API and the FileWriter object described in The Filesystem API to write a Blob into a local file.

The subsections below demonstrate simple ways to obtain and use Blobs. The more complicated techniques involving the local filesystem and client-side databases are covered later, in sections of their own.

Files As Blobs

The <input type="file"> element was originally intended to enable file uploads in HTML forms. Browsers have always been careful to implement this element so that it only allows the upload of files explicitly selected by the user. Scripts cannot set the value property of this element to a filename, so they cannot go uploading arbitrary files from the user’s computer. More recently, browser vendors have extended this element to allow client-side access to user-selected files. Note that allowing a client-side script to read the contents of selected files is no more or less secure than allowing those files to be uploaded to the server.

In browsers that support local file access, the files property of an <input type="file"> element will be a FileList object. This is an array-like object whose elements are zero or more user-selected File objects. A File object is a Blob that also has name and lastModifiedDate properties:

<script> // Log information about a list of selected files function fileinfo(files) { for(var i = 0; i < files.length; i++) { // files is an array-like object var f = files[i]; console.log(f.name, // Name only: no path f.size, f.type, // size and type are Blob properties f.lastModifiedDate); // another File property } } </script> <!-- Allow selection of multiple image files and pass them to fileinfo()--> <input type="file" accept="image/*" multiple onchange="fileinfo(this.files)"/>

Being able to display the names, types, and sizes of selected files isn’t terribly interesting. In Blob URLs and Reading Blobs, we’ll see how you can actually make use of the content of the file.

In addition to selecting files with an <input> element, a user can also give a script access to local files by dropping them into the browser. When an application receives a drop event, the dataTransfer.files property of the event object will be the FileList associated with the drop, if there was one. The drag-and-drop API was covered in Drag and Drop Events and Example 22-10 below demonstrates its use with files.

Downloading Blobs

Chapter 18 covered scripted HTTP with the XMLHttpRequest object and also documented some of the new features of the XMLHttpRequest Level 2 (XHR2) draft specification. At the time of this writing, XHR2 defines a way to download the contents of a URL as a Blob, but browser implementations do not yet support it. Because the code cannot yet be tested, this section is only a simple sketch of the XHR2 API for working with Blobs.

Example 22-9 shows the basic technique for downloading a Blob from the Web. Contrast this example with Example 18-2, which downloads the contents of a URL as plain text:

Example 22-9. Downloading a Blob with XMLHttpRequest

// GET the contents of the url as a Blob and pass it to the specified callback. // This code is untested: no browsers supported this API when it was written. function getBlob(url, callback) { var xhr = new XMLHttpRequest(); // Create new XHR object xhr.open("GET", url); // Specify URL to fetch xhr.responseType = "blob" // We'd like a Blob, please xhr.onload = function() { // onload is easier than onreadystatechange callback(xhr.response); // Pass the blob to our callback } // Note .response, not .responseText xhr.send(null); // Send the request now }

If the Blob you’re downloading is quite large and you want to start processing it while it is downloading, you can use an onprogress event handler, along with the Blob reading techniques demonstrated in Reading Blobs.

Building Blobs

Blobs often represent chunks of data from an external source such as a local file, a URL, or a database. But sometimes a web application wants to create its own Blobs to be uploaded to the Web or stored in a file or database or passed to another thread. To create a Blob from your own data, use a BlobBuilder:

// Create a new BlobBuilder var bb = new BlobBuilder(); // Append a string to the blob, and mark the end of the string with a NUL char bb.append("This blob contains this text and 10 big-endian 32-bit signed ints."); bb.append("\0"); // NUL-terminate the string to mark its end // Store some data into an ArrayBuffer var ab = new ArrayBuffer(4*10); var dv = new DataView(ab); for(var i = 0; i < 10; i++) dv.setInt32(i*4,i); // Append the ArrayBuffer to the Blob bb.append(ab); // Now get the blob from the builder, specifying a made-up MIME type var blob = bb.getBlob("x-optional/mime-type-here");

We saw at the beginning of this section that Blobs have a slice() method that breaks them into pieces. You can join Blobs together by passing Blobs to the append() method of a BlobBuilder.

Blob URLs

The preceding sections have shown how you can obtain or create Blobs. We’ll now shift gears and start talking about what you can actually do with the Blobs you obtain or create. One of the simplest things you can do with a Blob is create a URL that refers to the Blob. You can then use this URL anywhere you’d use a regular URL: in the DOM, in a stylesheet, or even as the target of an XMLHttpRequest.

Create a Blob URL with the function createObjectURL(). At the time of this writing, the draft specification and Firefox 4 put this function in a global object named URL, and Chrome and Webkit prefix that new global, calling it webkitURL. Earlier versions of the specification (and earlier browser implementations) put the function directly on the Window object. To create Blob URLs portably across browsers, you can define a utility like this:

var getBlobURL = (window.URL && URL.createObjectURL.bind(URL)) || (window.webkitURL && webkitURL.createObjectURL.bind(webkitURL)) || window.createObjectURL;

Web workers are also allowed to use this API and have access to these same functions, in the same URL (or webkitURL) object.

Pass a blob to createObjectURL() and it returns a URL (as an ordinary string). The URL will begin with blob://, and that URL scheme will be followed by a short string of text that identifies the Blob with some kind of opaque unique identifier. Note that this is very different than a data:// URL, which encodes its own contents. A Blob URL is simply a reference to a Blob that is stored by the browser in memory or on the disk. blob:// URLs are also quite different from file:// URLs, which refer directly to a file in the local filesystem, exposing the path of the file, allowing directory browsing, and otherwise raising security issues.

Example 22-10 demonstrates two important techniques. First, it implements a「drop target」that listens for drag-and-drop events involving files. Then, when the user drops one or more files on the drop target, it uses createObjectURL() to obtain a URL for each one and then creates <img> elements to display thumbnails of the images referenced by those URLs.

Example 22-10. Displaying dropped image files with Blob URLs

<!DOCTYPE html> <html><head> <script>// At the time of this writing, Firefox and Webkit disagree on the // name of the createObjectURL() function var getBlobURL = (window.URL && URL.createObjectURL.bind(URL)) || (window.webkitURL && webkitURL.createObjectURL.bind(webkitURL)) || window.createObjectURL; var revokeBlobURL = (window.URL && URL.revokeObjectURL.bind(URL)) || (window.webkitURL && webkitURL.revokeObjectURL.bind(webkitURL)) || window.revokeObjectURL; // When the document is loaded, add event handlers to the droptarget element // so that it can handle drops of files window.onload = function() { // Find the element we want to add handlers to. var droptarget = document.getElementById("droptarget"); // When the user starts dragging files over the droptarget, highlight it. droptarget.ondragenter = function(e) { // If the drag is something other than files, ignore it. // The HTML5 dropzone attribute will simplify this when implemented. var types = e.dataTransfer.types; if (!types || (types.contains && types.contains("Files")) || (types.indexOf && types.indexOf("Files") != -1)) { droptarget.classList.add("active"); // Highlight droptarget return false; // We're interested in the drag } }; // Unhighlight the drop zone if the user moves out of it droptarget.ondragleave = function() { droptarget.classList.remove("active"); }; // This handler just tells the browser to keep sending notifications droptarget.ondragover = function(e) { return false; }; // When the user drops files on us, get their URLs and display thumbnails. droptarget.ondrop = function(e) { var files = e.dataTransfer.files; // The dropped files for(var i = 0; i < files.length; i++) { // Loop through them all var type = files[i].type; if (type.substring(0,6) !== "image/") // Skip any nonimages continue; var img = document.createElement("img"); // Create an <img> element img.src = getBlobURL(files[i]); // Use Blob URL with <img> img.onload = function() { // When it loads this.width = 100; // adjust its size and document.body.appendChild(this); // insert into document. revokeBlobURL(this.src); // But don't leak memory! } } droptarget.classList.remove("active"); // Unhighlight droptarget return false; // We've handled the drop } }; </script> <style> /* Simple styles for the file drop target */ #droptarget { border: solid black 2px; width: 200px; height: 200px; } #droptarget.active { border: solid red 4px; } </style> </head> <body> <!-- The document starts off with just the file drop target --> <div id="droptarget">Drop Image Files Here</div> </body> </html>

Blob URLs have the same origin (The Same-Origin Policy) as the script that creates them. This makes them much more versatile than file:// URLs, which have a distinct origin and are therefore difficult to use within a web application. A Blob URL is only valid in documents of the same origin. If, for example, you passed a Blob URL via postMessage() to a window with a different origin, the URL would be meaningless to that window.

Blob URLs are not permanent. A Blob URL is no longer valid once the user has closed or navigated away from the document whose script created the URL. It is not possible, for example, to save a Blob URL to local storage and then reuse it when the user begins a new session with a web application.

It is also possible to manually「revoke」the validity of a Blob URL by calling URL. revoke ObjectURL() (or webkitURL.revokeObjectURL()) and you may have noticed that Example 22-10 does this. This is a memory management issue. Once the thumbnail image has been displayed, the Blob is no longer needed and it should be allowed to be garbage collected. But if the web browser is maintaining a mapping from the Blob URL we’ve created to the Blob, that Blob cannot be garbage collected even if we’re not using it. The JavaScript interpreter cannot track the usage of strings, and if the URL is still valid, it has to assume that it might still be used. This means that it cannot garbage collect the Blob until the URL has been revoked. Example 22-10 uses local files that don’t require any cleanup, but you can imagine a more serious memory management issue if the Blob in question were one that had been built in memory with a BlobBuilder or one that had been downloaded with XMLHttpRequest and stored in a temporary file.

The blob:// URL scheme is explicitly designed to work like a simplified http:// URL, and browsers are required to act like mini HTTP servers when blob:// URLs are requested. If a Blob URL that is no longer valid is requested, the browser must send a 404 Not Found status code. If a Blob URL from a different origin is requested, the browser must respond with 403 Not Allowed. Blob URLs only work with GET requests, and when one is successfully requested, the browser sends an HTTP 200 OK status code and also sends a Content-Type header that uses the type property of the Blob. Because Blob URLs work like simple HTTP URLs, you can「download」their content with XMLHttpRequest. (As we’ll see in the next section, however, you can read the content of a Blob more directly using a FileReader object.)

Reading Blobs

So far, Blobs have been opaque chunks of data that allow only indirect access, through Blob URLs, to their contents. The FileReader object allows us read access to the characters or bytes contained in a Blob, and you can think of it as the opposite of a BlobBuilder. (A better name would be BlobReader, since it works with any Blob, not just Files.) Since Blobs can be very large objects stored in the filesystem, the API for reading them is asynchronous, much like the XMLHttpRequest API. A synchronous version of the API, FileReaderSync, is available in worker threads, although workers can also use the asynchronous version.

To use a FileReader, first create an instance with the FileReader() constructor. Next, define event handlers. Typically you’ll define handlers for load and error events and possibly also for progress events. You can do this with onload, onerror, and on progress or with the standard addEventListener() method. FileReader objects also trigger loadstart, loadend, and abort events, which are like the XMLHttpRequest events with the same names: see HTTP Progress Events.

Once you’ve created a FileReader and registered suitable event handlers, you must pass the Blob you want to read to one of four methods: readAsText(), readAsArrayBuffer(), readAsDataURL(), and readAsBinaryString(). (You can, of course, call one of these methods first and then register event handlers—the single-threaded nature of JavaScript, described in Web Workers, means that event handlers will never be called until your function has returned and the browser is back in its event loop.) The first two methods are the most important and are the ones covered here. Each of these read methods takes a Blob as its first argument. readAsText() takes an optional second argument that specifies the name of a text encoding. If you omit the encoding, it will automatically work with ASCII and UTF-8 text (and also UTF-16 text with a byte-order mark or BOM).

As the FileReader reads the Blob you’ve specified, it updates its readyState property. The value starts off at 0, indicating that nothing has been read. It changes to 1 when some data is available, and changes to 2 when the read has completed. The result property holds a partial or complete result as a string or ArrayBuffer. You do not normally poll the state and result properties, but instead use them from your on progress or onload event handler.

Example 22-11 demonstrates how to use the readAsText() method to read local text files that the user selects.

Example 22-11. Reading text files with FileReader

<script> // Read the specified text file and display it in the <pre> element below function readfile(f) { var reader = new FileReader(); // Create a FileReader object reader.readAsText(f); // Read the file reader.onload = function() { // Define an event handler var text = reader.result; // This is the file contents var out = document.getElementById("output"); // Find output element out.innerHTML = ""; // Clear it out.appendChild(document.createTextNode(text)); // Display file contents } reader.onerror = function(e) { // If anything goes wrong console.log("Error", e); // Just log it }; } </script> Select the file to display: <input type="file" onchange="readfile(this.files[0])"></input> <pre id="output"></pre>

The readAsArrayBuffer() method is similar to readAsText(), except that it generally takes a little more effort to make use of an ArrayBuffer result than a string result. Example 22-12 is an example that uses readAsArrayBuffer() to read the first four bytes of a file as a big-endian integer.

Example 22-12. Reading the first four bytes of a file

<script> // Examine the first 4 bytes of the specified blob. If this "magic number" // identifies the type of the file, asynchronously set a property on the Blob. function typefile(file) { var slice = file.slice(0,4); // Only read the start of the file var reader = new FileReader(); // Create an asynchronous FileReader reader.readAsArrayBuffer(slice); // Read the slice of the file reader.onload = function(e) { var buffer = reader.result; // The result ArrayBuffer var view = new DataView(buffer); // Get access to the result bytes var magic = view.getUint32(0, false); // Read 4 bytes, big-endian switch(magic) { // Determine file type from them case 0x89504E47: file.verified_type = "image/png"; break; case 0x47494638: file.verified_type = "image/gif"; break; case 0x25504446: file.verified_type = "application/pdf"; break; case 0x504b0304: file.verified_type = "application/zip"; break; } console.log(file.name, file.verified_type); }; } </script> <input type="file" onchange="typefile(this.files[0])"></input>

In worker threads, you can use FileReaderSync instead of FileReader. The synchronous API defines the same readAsText() and readAsArrayBuffer() methods that take the same arguments as the asynchronous methods. The difference is that the synchronous methods block until the operation is complete and return the resulting string or ArrayBuffer directly, with no need for event handlers. Example 22-14 below uses FileReaderSync.

The Filesystem API

In Reading Blobs, you saw the FileReader class used to read the content of user-selected files, or of any Blob. The File and Blob types are defined by a draft specification known as the File API. Another draft specification, even newer than the File API, gives web applications controlled access to a private local filesystem「sandbox」in which they can write files, read files, create directories, list directories, and so on. At the time of this writing, this Filesystem API is implemented only by Google’s Chrome browser, but it is a powerful and important form of local storage, so it is covered here, even though the API is even less stable than most of the other APIs described in this chapter. This section covers basic filesystem tasks but does not demonstrate all features of the API. Because the API is new and unstable, it is not documented in the reference section of this book.

Working with files in the local filesystem is a multistep process. First, you must obtain an object that represents the filesystem itself. There is a synchronous API for doing this in worker threads and an asynchronous API for use on the main thread:

// Obtaining a filesystem synchronously. Pass filesystem lifetime and size. // Returns a filesystem object or raises an exception. var fs = requestFileSystemSync(PERSISTENT, 1024*1024); // The asynchronous version uses callback functions for success and error requestFileSystem(TEMPORARY, // lifetime 50*1024*1024, // size: 50Mb function(fs) { // called with the filesystem object // Use fs here } function(e) { // called with an error object onerror console.log(e); // Or handle it some other way });

In both the synchronous and asynchronous versions of the API, you specify the lifetime and the size of the filesystem you want. A PERSISTENT filesystem is suitable for web apps that want to store user data permanently. The browser won’t delete it except at the user’s explicit request. A TEMPORARY filesystem is appropriate for web apps that want to cache data but can still operate if the web browser deletes the filesystem. The size of the filesystem is specified in bytes and should be a reasonable upper bound on the amount of data you need to store. A browser may enforce this as a quota.

The filesystem obtained with these functions depends on the origin of the containing document. All documents or web apps from the same origin (host, port, and protocol) share a filesystem. Two documents or applications from different origins have completely distinct and disjoint filesystems. The filesystem is also walled off from the rest of the files on the user’s hard drive: there is no way for a web application to「break out」beyond the local root directory or otherwise access arbitrary files.

Note that these functions have「request」in their names. The first time you call one, the browser may ask the user for permission before creating a filesystem and granting access.[55] Once permission has been granted, subsequent calls to the request method should simply return an object that represents the already existing local filesystem.

The filesystem object you obtain with one of the methods above has a root property that refers to the root directory of the filesystem. This is a DirectoryEntry object, and it may have nested directories that are themselves represented by DirectoryEntry objects. Each directory in the file system may contain files, represented by FileEntry objects. The DirectoryEntry object defines methods for obtaining DirectoryEntry and FileEntry objects by pathname (they will optionally create new directories or files if you specify a name that doesn’t exist). DirectoryEntry also defines a createReader() factory method that returns a DirectoryReader for listing the contents of a directory.

The FileEntry class defines a method for obtaining the File object (a Blob) that represents the contents of a file. You can then use a FileReader object (as shown in Reading Blobs) to read the file. FileEntry defines another method to return a FileWriter object that you can use to write content into a file.

Reading or writing a file with this API is a multistep process. First you obtain the filesystem object. Then you use the root directory of that object to look up (and optionally create) the FileEntry object for the file you’re interested in. Then you use the FileEntry object to obtain the File or FileWriter object for reading or writing. This multistep process is particularly complex when using the asynchronous API:

// Read the text file "hello.txt" and log its contents. // The asynchronous API nests functions four deep. // This example doesn't include any error callbacks. requestFileSystem(PERSISTENT, 10*1024*1024, function(fs) { // Get filesystem fs.root.getFile("hello.txt", {}, function(entry) { // Get FileEntry entry.file(function(file) { // Get File var reader = new FileReader(); reader.readAsText(file); reader.onload = function() { // Get file content console.log(reader.result); }; }); }); });

Example 22-13 is a more fully fleshed-out example. It demonstrates how to use the asynchronous API to read files, write files, delete files, create directories, and list directories.

Example 22-13. Using the asynchronous filesystem API

/* * These functions have been tested in Google Chrome 10.0 dev. * You may need to launch Chrome with these options: * --unlimited-quota-for-files : enables filesystem access * --allow-file-access-from-files : allows testing from file:// URLs */ // Lots of the asynchronous functions we use accept an optional error callback. // This one just logs the error. function logerr(e) { console.log(e); } // requestFileSystem() gets us a sandboxed local filesystem accessible only // to apps from this origin. We can read and write files at will, but // can't get out of the sandbox to access the rest of the system. var filesystem; // Assume this is initialized before the funcs below are called. requestFileSystem(PERSISTENT, // Or TEMPORARY for cache files 10*1024*1024, // We'd like 10 megabytes, please function(fs) { // When done, call this function filesystem = fs; // Just save the filesystem into }, // a global variable. logerr); // Call this if an error occurs // Read the contents of the specified file as text and pass them to callback. function readTextFile(path, callback) { // Call getFile() to find the FileEntry for the specified filename filesystem.root.getFile(path, {}, function(entry) { // This function is called with the FileEntry for the file // Now we call the FileEntry.file() method to get the File object entry.file(function(file) { // Call this with the File var reader = new FileReader(); // Create a FileReader reader.readAsText(file); // And read the file reader.onload = function() { // When read successful callback(reader.result); // Pass it to the callback } reader.onerror = logerr; // Log readAsText() errors }, logerr); // Log file() errors }, logerr); // Log getFile() errors } // Append the specified contents to the file at the specified path, creating // a new file if no file by that name already exists. Call callback when done. function appendToFile(path, contents, callback) { // filesystem.root is the root directory. filesystem.root.getFile( // Get a FileEntry object path, // The name and path of the file we want {create:true}, // Create it if it doesn't already exist function(entry) { // Call this when it has been found entry.createWriter( // Create a FileWriter object for the file function(writer) { // Call this function when created // By default a writer starts at the beginning of the file. // We want to start writing at the end of the file writer.seek(writer.length); // Move to end of file // Convert file contents to a Blob. The contents argument // can be a string or a Blob or an ArrayBuffer. var bb = new BlobBuilder() bb.append(contents); var blob = bb.getBlob(); // Now write the blob to the file writer.write(blob); writer.onerror = logerr; // Log errors from write() if (callback) // If there is a callback writer.onwrite = callback; // call it on success }, logerr); // Log errors from createWriter() }, logerr); // Log errors from getFile() } // Delete the named file, calling the optional callback when done function deleteFile(name, callback) { filesystem.root.getFile(name, {}, // Get FileEntry for named file function(entry) { // Pass the FileEntry here entry.remove(callback, // Delete the FileEntry logerr); // Or log remove() error }, logerr); // Log a getFile() error } // Create a new directory with the specified name function makeDirectory(name, callback) { filesystem.root.getDirectory(name, // Name of directory to create { // Options create: true, // Create, if doesn't exist exclusive:true // Error if it does exist }, callback, // Call this when done logerr); // Log any errors } // Read the contents of the specified directory, and pass them, as an array // of strings, to the specified callback function function listFiles(path, callback) { // If no directory specified, list the root directory. Otherwise, look up // the named directory and list it (or log an error looking it up). if (!path) getFiles(filesystem.root); else filesystem.root.getDirectory(path, {}, getFiles, logerr); function getFiles(dir) { // This function is used above var reader = dir.createReader(); // A DirectoryReader object var list = []; // Where we store filenames reader.readEntries(handleEntries, // Pass entries to function below logerr); // or log an error. // Reading directories can be a multistep process. We have to keep // calling readEntries() until we get an empty array. Then we're done // and we can pass the full list to the user's callback function. function handleEntries(entries) { if (entries.length == 0) callback(list); // We're done else { // Otherwise, add these entries to the list and ask for more // The array-like object contains FileEntry objects and // we need to get the name of each one. for(var i = 0; i < entries.length; i++) { var name = entries[i].name; // Get entry name if (entries[i].isDirectory) name += "/"; // Mark directories list.push(name); // Add to list } // Now get the next batch of entries reader.readEntries(handleEntries, logerr); } } } }

Working with files and the filesystem is quite a bit easier in worker threads, where it is okay to make blocking calls and we can use the synchronous API. Example 22-14 defines the same filesystem utility functions as Example 22-13 does, but it uses the synchronous API and is quite a bit shorter.

Example 22-14. The synchronous filesystem API

// Filesystem utilities using the synchronous API in a worker thread var filesystem = requestFileSystemSync(PERSISTENT, 10*1024*1024); function readTextFile(name) { // Get a File from a FileEntry from the root DirectoryEntry var file = filesystem.root.getFile(name).file(); // Use the synchronous FileReader API to read it return new FileReaderSync().readAsText(file); } function appendToFile(name, contents) { // Get a FileWriter from a FileEntry from the root DirectoryEntry var writer = filesystem.root.getFile(name, {create:true}).createWriter(); writer.seek(writer.length); // Start at the end of the file var bb = new BlobBuilder() // Build the file contents into a Blob bb.append(contents); writer.write(bb.getBlob()); // Now write the blob to the file } function deleteFile(name) { filesystem.root.getFile(name).remove(); } function makeDirectory(name) { filesystem.root.getDirectory(name, { create: true, exclusive:true }); } function listFiles(path) { var dir = filesystem.root; if (path) dir = dir.getDirectory(path); var lister = dir.createReader(); var list = []; do { var entries = lister.readEntries(); for(var i = 0; i < entries.length; i++) { var name = entries[i].name; if (entries[i].isDirectory) name += "/"; list.push(name); } } while(entries.length > 0); return list; } // Allow the main thread to use these utilities by sending a message onmessage = function(e) { // We expect the message to be an object like this: // { function: "appendToFile", args: ["test", "testing, testing"]} // We invoke the specified function with the specified args and // post the message back var f = self[e.data.function]; var result = f.apply(null, e.data.args); postMessage(result); };

* * *

[55] At the time of this writing, Chrome doesn’t ask for permission, but it requires you to launch it with the --unlimited -quota-for-files command-line flag.

Client-Side Databases

Web application architecture has traditionally featured HTML, CSS, and JavaScript on the client and a database on the server. Among the most surprising HTML5 APIs, therefore, are client-side databases. These are not just client-side APIs for accessing database servers across the network, but actual client-side databases stored on the user’s computer and directly accessed by JavaScript code in the browser.

The Web Storage API described in localStorage and sessionStorage can be thought of as a particularly simple kind of database that persists simple key/value pairs. But in addition, there are two client-side database APIs that are「real」databases. One, known as Web SQL Database, is a simple relational database that supports basic SQL queries. Chrome, Safari, and Opera implemented this API, but Firefox and IE have not, and likely never will. Work on the official specification of this API has stopped and this full-featured SQL database will probably never become an official standard nor an unofficial but interoperable feature of the web platform.

Standardization efforts are now focused on another database API, known as IndexedDB. It is too early to document this API in any detail (it is not covered in Part IV), but Firefox 4 and Chrome 11 include implementations, and this section includes a working example that demonstrates some of the most important features of the IndexedDB API.

IndexedDB is an object database, not a relational database, and it is much simpler than databases that support SQL queries. It is more powerful, efficient, and robust than the key/value storage provided by the Web Storage API, however. Like the Web Storage and the Filesystem API, IndexedDB databases are scoped to the origin of the containing document: two web pages with the same origin can access each other’s data, but web pages from different origins cannot.

Each origin can have any number of IndexedDB databases. Each one has a name that must be unique within the origin. In the IndexedDB API, a database is simply a collection of named object stores. As the name implies, an object store stores objects (or any value that can be cloned—see Structured Clones). Each object must have a key by which it can be sorted and retrieved from the store. Keys must be unique—two objects in the same store may not have the same key—and they must have a natural ordering so that they can be sorted. JavaScript strings, numbers, and Date objects are valid keys. An IndexedDB database can automatically generate a unique key for each object you insert into the database. Often, though, the objects you insert into an object store will already have a property that is suitable for use as a key. In this case, you specify a「key path」for that property when you create the object store. Conceptually, a key path is a value that tells the database how to extract an object’s key from the object.

In addition to retrieving objects from an object store by their primary key value, you may want to be able to search based on the value of other properties in the object. In order to be able to do this, you can define any number of indexes on the object store. (The ability to index an object store explains the name「IndexedDB.」) Each index defines a secondary key for the stored objects. These indexes are not generally unique and multiple objects may match a single key value. So when querying an object store via an index, you generally use a cursor, which defines an API for retrieving streaming query results one at a time. Cursors can also be used when querying an object store (or index) for a range of keys, and the IndexedDB API includes an object for describing ranges (upper-bounded and/or lower-bounded, inclusive bounds or exclusive bounds) of keys.

IndexedDB provides atomicity guarantees: queries and updates to the database are grouped within a transaction so that they all succeed together or all fail together and never leave the database in an undefined partially updated state. Transactions in IndexedDB are simpler than in many database APIs; we’ll mention them again below.

Conceptually, the IndexedDB API is quite simple. To query or update a database, you first open the database you want (specifying it by name). Next, you create a transaction object and use that object to look up the desired object store within the database, also by name. Finally, you look up an object by calling the get() method of the object store or store a new object by calling put(). (Or by calling add(), if you want to avoid overwriting existing objects.) If you want to look up the objects for a range of keys, you create an IDBRange object and pass it to the openCursor() method of the object store. Or, if you want to make a query using a secondary key, you look up the named index of the object store, and then call the get() or openCursor() method of the index object.

This conceptual simplicity is complicated, however, by the fact that the API must be asynchronous so that web apps can use it without blocking the browser’s main UI thread. (The IndexedDB specification defines a synchronous version of the API for use by worker threads, but at the time of this writing, no browser has yet implemented that version of the API, so it is not covered here.) Creating transactions and looking up object stores and indexes are easy synchronous operations. But opening a database, updating an object store with put(), and querying a store or index with get() or openCursor() are all asynchronous operations. These asynchronous methods all immediately return a request object. The browser triggers a success or error event on the request object when the request succeeds or fails, and you can define handlers with the on success and onerror properties. Inside an onsuccess handler, the result of the operation is available as the result property of the request object.

One convenient feature of this asynchronous API is that it simplifies transaction management. In a typical use of the IndexedDB API, you first open the database. This is an asynchronous operation, so it triggers an onsuccess handler. In that event handler, you create a transaction object, and then use that transaction object to look up the object store or stores you’ll be using. Then you make any number of get() and put() calls on the object stores. They are asynchronous, so nothing happens right away, but the requests generated by those get() and put() calls are automatically associated with the transaction object. If you need to, you can cancel all the pending operations (and undo any that have already completed) in the transaction by calling the abort() method of the transaction object. In many other database APIs, you’d expect the transaction object to have a commit() method to finalize the transaction. In IndexedDB, however, the transaction is committed after the original onsuccess event handler that created the transaction exits and the browser returns to its event loop and after all the operations pending on that transaction complete (without starting any new operations in their callback functions). This sounds complicated, but in practice, it is straightforward. The IndexedDB API forces you to create transaction objects in order to look up object stores, but in common use cases, you really don’t have to think about the transactions very much.

Finally, there is one special kind of transaction that enables a very important part of the IndexedDB API. Creating a new database in the IndexedDB API is easy: you just pick a name and request that that database be opened. But a new database is completely empty, and it is useless unless you add one or more object stores (and possibly some indexes as well) to it. The only way to create object stores and indexes is within the onsuccess event handler of the request object returned by a call to the setVersion() method of the database object. Calling setVersion() allows you to specify a version number for the database—in typical usage, you update the version number each time you alter the structure of the database. More importantly, however, setVersion() implicitly begins a special kind of transaction that enables you to call the createObjectStore() method of the database object and the createIndex() method of an object store.

With this high-level overview of IndexedDB in mind, you should now be able to understand Example 22-15. That example uses IndexedDB to create and query a database that maps US postal codes (zipcodes) to US cities. It demonstrates many, but not all, of the basic features of IndexedDB. At the time of this writing, the example works in Firefox 4 and Chrome 11, but because the specification is still in flux and implementations are still quite preliminary, there is a chance that it won’t work exactly as written when you read this. Nevertheless, the overall structure of the example should still be useful to you. Example 22-15 is long, but it has lots of comments that make it easy to understand.

Example 22-15. A IndexedDB database of US postal codes

<!DOCTYPE html> <html> <head> <title>Zipcode Database</title> <script> // IndexedDB implementations still use API prefixes var indexedDB = window.indexedDB || // Use the standard DB API window.mozIndexedDB || // Or Firefox's early version of it window.webkitIndexedDB; // Or Chrome's early version // Firefox does not prefix these two: var IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction; var IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange; // We'll use this function to log any database errors that occur function logerr(e) { console.log("IndexedDB error" + e.code + ": " + e.message); } // This function asynchronously obtains the database object (creating and // initializing the database if necessary) and passes it to the function f(). function withDB(f) { var request = indexedDB.open("zipcodes"); // Request the zipcode database request.onerror = logerr; // Log any errors request.onsuccess = function() { // Or call this when done var db = request.result; // The result of the request is the database // You can always open a database, even if it doesn't exist. // We check the version to find out whether the DB has been created and // initialized yet. If not, we have to go do that. But if the db is // already set up, we just pass it to the callback function f(). if (db.version === "1") f(db); // If db is inited, pass it to f() else initdb(db,f); // Otherwise initialize it first } } // Given a zip code, find out what city it belongs to and asynchronously // pass the name of that city to the specified callback function. function lookupCity(zip, callback) { withDB(function(db) { // Create a transaction object for this query var transaction = db.transaction(["zipcodes"], // Object stores we need IDBTransaction.READ_ONLY, // No updates 0); // No timeout // Get the object store from the transaction var objects = transaction.objectStore("zipcodes"); // Now request the object that matches the specified zipcode key. // The lines above were synchronous, but this one is async var request = objects.get(zip); request.onerror = logerr; // Log any errors that occur request.onsuccess = function() { // Pass the result to this function // The result object is now in the request.result var object = request.result; if (object) // If we found a match, pass city and state to callback callback(object.city + ", " + object.state); else // Otherwise, tell the callback that we failed callback("Unknown zip code"); } }); } // Given the name of a city find all zipcodes for all cities (in any state) // with that name (case-sensitive). Asynchronously pass the results, one at // a time, to the specified callback function function lookupZipcodes(city, callback) { withDB(function(db) { // As above, we create a transaction and get the object store var transaction = db.transaction(["zipcodes"], IDBTransaction.READ_ONLY, 0); var store = transaction.objectStore("zipcodes"); // This time we get the city index of the object store var index = store.index("cities"); // This query is likely to have many results, so we have to use a // cursor object to retrieve them all. To create a cursor, we need // a range object that represents the range of keys var range = new IDBKeyRange.only(city); // A range with only() one key // Everything above has been synchronous. // Now we request a cursor, which will be returned asynchronously. var request = index.openCursor(range); // Request the cursor request.onerror = logerr; // Log errors request.onsuccess = function() { // Pass cursor to this function // This event handler will be invoked multiple times, once // for each record that matches the query, and then once more // with a null cursor to indicate that we're done. var cursor = request.result // The cursor is in request.result if (!cursor) return; // No cursor means no more results var object = cursor.value // Get the matching record callback(object); // Pass it to the callback cursor.continue(); // Ask for the next matching record }; }); } // This function is used by an onchange callback in the document below // It makes a DB request and displays the result function displayCity(zip) { lookupCity(zip, function(s) { document.getElementById('city').value = s; }); } // This is another onchange callback used in the document below. // It makes a DB request and displays the results function displayZipcodes(city) { var output = document.getElementById("zipcodes"); output.innerHTML = "Matching zipcodes:"; lookupZipcodes(city, function(o) { var div = document.createElement("div"); var text = o.zipcode + ": " + o.city + ", " + o.state; div.appendChild(document.createTextNode(text)); output.appendChild(div); }); } // Set up the structure of the database and populate it with data, then pass // the database to the function f(). withDB() calls this function if the // database has not been initialized yet. This is the trickiest part of the // program, so we've saved it for last. function initdb(db, f) { // Downloading zipcode data and storing it in the database can take // a while the first time a user runs this application. So we have to // provide notification while that is going on. var statusline = document.createElement("div"); statusline.style.cssText = "position:fixed; left:0px; top:0px; width:100%;" + "color:white; background-color: black; font: bold 18pt sans-serif;" + "padding: 10px; "; document.body.appendChild(statusline); function status(msg) { statusline.innerHTML = msg.toString(); }; status("Initializing zipcode database"); // The only time you can define or alter the structure of an IndexedDB // database is in the onsucess handler of a setVersion request. var request = db.setVersion("1"); // Try to update the DB version request.onerror = status; // Display status on fail request.onsuccess = function() { // Otherwise call this function // Our zipcode database includes only one object store. // It will hold objects that look like this: { // zipcode: "02134", // send it to Zoom! :-) // city: "Allston", // state: "MA", // latitude: "42.355147", // longitude: "-71.13164" // } // // We'll use the "zipcode" property as the database key // And we'll also create an index using the city name // Create the object store, specifying a name for the store and // an options object that includes the "key path" specifying the // property name of the key field for this store. (If we omit the // key path, IndexedDB will define its own unique integer key.) var store = db.createObjectStore("zipcodes", // store name { keyPath: "zipcode" }); // Now index the object store by city name as well as by zipcode. // With this method the key path string is passed directly as a // required argument rather than as part of an options object. store.createIndex("cities", "city"); // Now we need to download our zipcode data, parse it into objects // and store those objects in object store we created above. // // Our file of raw data contains lines formatted like this: // // 02130,Jamaica Plain,MA,42.309998,-71.11171 // 02131,Roslindale,MA,42.284678,-71.13052 // 02132,West Roxbury,MA,42.279432,-71.1598 // 02133,Boston,MA,42.338947,-70.919635 // 02134,Allston,MA,42.355147,-71.13164 // // Surprisingly, the US Postal Service does not make this data freely // available, so we use out-of-date census-based zipcode data from: // http://mappinghacks.com/2008/04/28/civicspace-zip-code-database/ // We use XMLHttpRequest to download the data. But use the new XHR2 // onload and onprogress events to process it as it arrives var xhr = new XMLHttpRequest(); // An XHR to download the data xhr.open("GET", "zipcodes.csv"); // HTTP GET for this URL xhr.send(); // Start right away xhr.onerror = status; // Display any error codes var lastChar = 0, numlines = 0; // How much have we already processed? // Handle the database file in chunks as it arrives xhr.onprogress = xhr.onload = function(e) { // Two handlers in one! // We'll process the chunk between lastChar and the last newline // that we've received. (We need to look for newlines so we don't // process partial records) var lastNewline = xhr.responseText.lastIndexOf("\n"); if (lastNewline > lastChar) { var chunk = xhr.responseText.substring(lastChar, lastNewline) lastChar = lastNewline + 1; // Where to start next time // Now break the new chunk of data into individual lines var lines = chunk.split("\n"); numlines += lines.length; // In order to insert zipcode data into the database we need a // transaction object. All the database insertions we make // using this object will be commited to the database when this // function returns and the browser goes back to the event // loop. To create our transaction object, we need to specify // which object stores we'll be using (we only have one) and we // need to tell it that we'll be doing writes to the database, // not just reads: var transaction = db.transaction(["zipcodes"], // object stores IDBTransaction.READ_WRITE); // Get our object store from the transaction var store = transaction.objectStore("zipcodes"); // Now loop through the lines of the zipcode file, create // objects for them, and add them to the object store. for(var i = 0; i < lines.length; i++) { var fields = lines[i].split(","); // Comma-separated values var record = { // This is the object we'll store zipcode: fields[0], // All properties are string city: fields[1], state: fields[2], latitude: fields[3], longitude: fields[4] }; // The best part about the IndexedDB API is that object // stores are *really* simple. Here's how we add a record: store.put(record); // Or use add() to avoid overwriting } status("Initializing zipcode database: loaded " + numlines + " records."); } if (e.type == "load") { // If this was the final load event, then we've sent all our // zipcode data to the database. But since we've just blasted // it with some 40,000 records, it may still be processing. // So we'll make a simple query. When it succeeds, we know // that the database is ready to go, and we can then remove // the status line and finally call the function f() that was // passed to withDB() so long ago lookupCity("02134", function(s) { // Allston, MA document.body.removeChild(statusline); withDB(f); }); } } } } </script> </head> <body> <p>Enter a zip code to find its city:</p> Zipcode: <input onchange="displayCity(this.value)"></input> City: <output id="city"></output> </div> <div> <p>Enter a city name (case sensitive, without state) to find cities and their zipcodes:</p> City: <input onchange="displayZipcodes(this.value)"></input> <div id="zipcodes"></div> </div> <p><i>This example is only known to work in Firefox 4 and Chrome 11.</i></p> <p><i>Your first query may take a very long time to complete.</i></p> <p><i>You may need to start Chrome with --unlimited-quota-for-indexeddb</i></p> </body> </html>

Web Sockets

Chapter 18 showed how client-side JavaScript code can communicate over the network. The examples in that chapter all used HTTP, which means that they were all constrained by the fundamental nature of the HTTP: it is a stateless protocol that consists of client requests and server responses. HTTP is actually a fairly specialized network protocol. More general network connections over the Internet (or over local intranets) often involve longer-lived connections and bidirectional message exchange over TCP sockets. It is not safe to give untrusted client-side JavaScript code access to low-level TCP sockets, but the WebSocket API defines a secure alternative: it allows client-side code to create bidirectional socket-type connections to servers that support the WebSocket protocol. This makes it much easier to perform certain kinds of networking tasks.

The WebSocket Protocol

In order to use WebSockets from JavaScript, you only need to understand the client-side WebSocket API described here. There is no equivalent server-side API for writing WebSocket servers, but this section does include a simple server example that uses Node (Asynchronous I/O with Node) along with a third-party WebSocket server library. The client and server communicate over a long-lived TCP socket following rules defined by the WebSocket protocol. The details of the protocol are not relevant here, but it is worth noting that the WebSocket protocol is carefully designed so that web servers can easily handle both HTTP and WebSocket connections over the same port.

WebSockets enjoy wide support among web browser vendors. An early draft version of the WebSocket protocol was found to have an important security hole, however, and at the time of this writing, some browsers have disabled their WebSocket support until a secure version of the protocol has been standardized. In Firefox 4, for example, you may need to explicitly enable WebSockets by visiting the about:config page and setting the configuration variable「network.websocket.override-security-block」to true.

