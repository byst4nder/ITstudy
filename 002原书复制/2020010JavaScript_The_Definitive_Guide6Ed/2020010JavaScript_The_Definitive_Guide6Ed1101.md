Some events are not triggered directly by user activity, but by network or browser activity, and indicate some kind of lifecycle or state-related change. The load event, fired on the Window object when the document is fully loaded, is probably the most commonly used of these events. The DOMContentLoaded event (discussed in Client-Side JavaScript Timeline) is another such event. The HTML5 history management mechanism (History Management) fires the popstate event in response to the browser’s Back button. The HTML5 offline web application API (Application Storage and Offline Webapps) includes online and offline events. Chapter 18 shows how to use a readystatechange event to be notified when data requested from a server is ready. Similarly, the new API for reading user-selected local files (Reading Blobs) uses events like「loadstart」,「progress」, and「loadend」for asynchronous notification of I/O progress.

API-specific events

A number of web APIs defined by HTML5 and related specifications include their own event types. The drag-and-drop API (Drag and Drop Events) defines events such as「dragstart」,「dragenter」,「dragover」, and「drop」. Applications that want to define custom drag sources or drop targets must handle some of these events. The HTML5 <video> and <audio> elements (Scripting Audio and Video) define a long list of associated event types such as「waiting」,「playing」,「seeking」,「volumechange」, and so on. These events are usually only of interest to web apps that want to define custom controls for video or audio playback.

Timers and error handlers

Timers and error handlers (both of which are described in Chapter 14) are part of client-side JavaScript’s asynchronous programming model and are similar to events. Although timers and error handlers are not discussed in this chapter, it is useful to think of them as related to event handling, and you may find it interesting to reread Timers and Error Handling in the context of this chapter.

Legacy Event Types

The events you’ll use most often in your web apps are generally the ones that have been around the longest and are universally supported: events for dealing with the mouse, the keyboard, HTML forms, and the Window object. The sections below explain many important details about these kinds of events.

Form events

Forms and hyperlinks were the first scriptable elements in a web page, way back in the early days of the Web and of JavaScript. This means that form events are some of the most stable and well-supported of all event types. <form> elements fire submit events when the form is submitted and reset events when the form is reset. Button-like form elements (including radio buttons and checkboxes) fire click events when the user interacts with them. Form elements that maintain some kind of state generally fire change events when the user changes their state by entering text, selecting an item, or checking a box. For text input fields, a change event is not fired until the user has finished interacting with a form element and has tabbed or clicked to move focus to another element. Form elements respond to keyboard focus changes by firing focus and blur events when they gain and lose the focus.

These form-related events are all covered in more detail in Form and Element Event Handlers. A few more notes are in order here, however.

The submit and reset events have default actions that can be canceled by event handlers, and some click events do, too. The focus and blur events do not bubble, but all the other form events do. IE defines focusin and focusout events that do bubble as a useful alternative to focus and blur. The jQuery library (see Chapter 19) emulates focusin and focusout events for browsers that do not support them, and the DOM Level 3 Events specification is standardizing them as well.

Finally, note that browsers other than IE trigger an input event on <textarea> and other text-input form elements whenever the user enters text (via the keyboard or cut-and-paste) into the element. Unlike the change event, these input events are triggered for each insertion. Unfortunately, the event object of an input event does not specify what text has been input. (The new textinput event described later will be a useful alternative to this event.)

Window events

Window events represent occurrences related to the browser window itself, rather than any specific document content displayed inside the window. (For some of these events, however, an event with the same name can be fired on document elements.)

The load event is the most important of these events: it is fired when a document and all of its external resources (such as images) are fully loaded and displayed to the user. The load event was discussed throughout Chapter 13. DOMContentLoaded and readystatechange are alternatives to the load event: they are triggered sooner, when the document and its elements are ready to manipulate, but before external resources are fully loaded. Document Load Events has examples of these document load-related events.

The unload event is the opposite of load: it is triggered when the user is navigating away from a document. An unload event handler might be used to save the user’s state, but it cannot be used to cancel navigation. The beforeunload event is similar to unload but gives you the opportunity to ask the user to confirm that they really want to navigate away from your web page. If a handler for beforeunload returns a string, that string will be displayed to the user in a confirmation dialog before the new page is loaded, and the user will have the opportunity to cancel her navigation and remain at your page.

The onerror property of the Window object is something like an event handler, and it is triggered in response to JavaScript errors. It isn’t a true event handler, however, because it is invoked with different arguments. See Error Handling for details.

Individual document elements, such as <img> elements, can also register handlers for load and error events. These are triggered when an external resource (the image, for example) is fully loaded, or when an error occurs that prevents it from loading. Some browsers also support (and HTML5 standardizes) an abort event, which is triggered when an image (or other network resource) fails to load because the user stopped the loading process.

The focus and blur events described above for form elements are also used as Window events: they are triggered on a window when that browser window receives or loses keyboard focus from the operating system.

Finally, the resize and scroll events are fired on a Window when the user resizes or scrolls the browser window. Scroll events can also be fired on any scrollable document element, such as those with the CSS overflow property (Partial Visibility: overflow and clip) set. The event object passed to resize and scroll event handlers is just an ordinary Event object and does not have properties that specify how much resizing or scrolling occurred—you can determine the new window size and scrollbar position using the techniques shown in Document and Element Geometry and Scrolling.

Mouse events

Mouse events are generated when the user moves or clicks the mouse over a document. These events are triggered on the most deeply nested element that the mouse pointer is over, but they bubble up through the document. The event object passed to mouse event handlers has properties set that describe the position and button state of the mouse and also specify whether any modifier keys were held down when the event occurred. The clientX and clientY properties specify the position of the mouse in window coordinates. The button and which properties specify which mouse button (if any) was pressed. (See the Event reference page, however, because these properties are difficult to use portably.) The altKey, ctrlKey, metaKey, and shiftKey properties are set to true when the corresponding keyboard modifier keys are held down. And for click events, the detail property specifies whether this was a single, double, or triple click.

The mousemove event is triggered any time the user moves or drags the mouse. These events occur frequently, so mousemove handlers must not trigger computationally intensive tasks. The mousedown and mouseup events are triggered when the user presses and releases a mouse button. By registering a mousedown handler that registers a mousemove handler, you can detect and respond to mouse drags. Doing this properly involves being able to capture mouse events so that you continue to receive mousemove events even when the mouse has moved out of the element it started in. Mouse Events includes an example of handling drags.

After a mousedown and mouseup event sequence, the browser also triggers a click event. The click event was described above as a device-independent form event, but it is actually triggered on any document element, not just form elements, and it is passed an event object with all of the extra mouse-related fields described above. If the user clicks a mouse button twice in a row (within a sufficiently short amount of time), the second click event will be followed by a dblclick event. Browsers often display a context menu when the right mouse button is clicked. They generally fire a contextmenu event before displaying the menu, and if you cancel the event, you can prevent the display of the menu. This is also an easy way to be notified of right mouse button clicks.

When the user moves the mouse so that it goes over a new element, the browser fires a mouseover event on that element. When the mouse moves so that it is no longer over an element, the browser fires a mouseout event on that element. For these events, the event object will have a relatedTarget property that specifies the other element involved in the transition. (See the Event reference page for the IE equivalent of the related Target property.) mouseover and mouseout events bubble like all of the mouse events described here. This is often inconvenient, because when a mouseout handler is triggered, you have to check whether the mouse actually left the element you are interested in or if it merely transitioned from one child of the element to another. Because of this, IE supports nonbubbling versions of these events known as mouseenter and mouseleave. jQuery emulates support for these events in browsers other than IE (see Chapter 19), and the DOM Level 3 Events specification standardizes them.

When the user rotates the mouse wheel, browsers trigger a mousewheel event (or, in Firefox, a DOMMouseScroll event). The event object passed with these events includes properties that specify how much, and in which direction, the wheel was rotated. The DOM Level 3 Events specification is standardizing a more general multidimensional wheel event that, if implemented, will supersede both mousewheel and DOMMouseScroll. Mousewheel Events includes a mousewheel event example.

Key events

When the web browser has keyboard focus, it generates events each time the user presses or releases a key on the keyboard. Keyboard shortcuts that have meaning to the operating system or to the browser itself are often「eaten」by the OS or browser and may not be visible to JavaScript event handlers, however. Keyboard events are triggered on whatever document element has keyboard focus, and they bubble up to the document and window. If no element has the focus, the events are triggered directly on the document. Keyboard event handlers are passed an event object with a keyCode field that specifies what key was pressed or released. In addition to keyCode, the event object for key events also has altKey, ctrlKey, metaKey, and shiftKey that describe the state of the keyboard modifier keys.

The keydown and keyup events are low-level keyboard events: they are triggered whenever a key (even a modifier key) is pressed or released. When a keydown event generates a printable character, an additional keypress event is triggered after the keydown but before the keyup. (In the case of a key that is held down until it repeats, there may be many keypress events before the keyup event.) The keypress event is a higher-level text event, and its event object specifies the character that was generated, not the key that was pressed.

The keydown, keyup, and keypress events are supported by all browsers, but there are some interoperability problems because the values of the keyCode property of the event object have never been standardized. The DOM Level 3 Events specification, described below, attempts to addresses these interoperability problems, but has not yet been implemented. Keyboard Events includes an example of handling keydown events and Text Events includes an example of processing keypress events.

DOM Events

The DOM Level 3 Events specification has been under development by the W3C for about a decade. At the time of this writing, it has undergone substantial revision to bring it in line with current browser reality and it is finally in the「last call working draft」stage of standardization. It standardizes many of the legacy events described above and adds some new ones described here. These new event types are not yet widely supported, but browser vendors are expected to implement them once the standard is final.

As noted above, the DOM Level 3 Events specification standardizes the focusin and focusout events as bubbling alternatives to the focus and blur events and standardizes the mouseenter and mouseleave events as nonbubbling alternatives to mouseover and mouseout. This version of the standard also deprecates a number of event types that were defined by Level 2 but never widely implemented. Browsers are still allowed to generate events like DOMActivate, DOMFocusIn, and DOMNodeInserted, but these are no longer required, and they are not documented in this book.[39]

What is new in the DOM Level 3 Events specification is standardized support for two-dimensional mouse wheels via the wheel event and better support for text input events with a textinput event and with a new KeyboardEvent object that is passed as the argument to handlers for keydown, keyup, and keypress events.

A handler for a wheel event receives an event object with all the usual mouse event properties, and also deltaX, deltaY, and deltaZ properties that report rotation around three different mouse wheel axes. (Most mouse wheels are one or two dimensional and do not use deltaZ.) See Mousewheel Events for more on mousewheel events.

DOM Level 3 Events defines the keypress event described above, but deprecates it in favor of a new event named textinput. Rather than a hard-to-use numeric keyCode value, the event object passed to a textinput event handler has a data property that specifies the string of text that was entered. The textinput event is not a keyboard-specific event: it is triggered whenever text input occurs, whether via the keyboard, cut-and-paste, drag-and-drop, and so on. The specification defines an inputMethod property on the event object and a set of constants representing different kinds of text input (keyboard, paste or drop, handwriting or voice recognition, and so on). At the time of this writing, Safari and Chrome support a version of this event using the mixed-case name text Input . Its event object includes the data property but not the inputMethod property. Text Events includes an example that makes use of this textInput event.

This new DOM standard also simplifies keydown, keyup, and keypress events by adding new key and char properties to the event object. Both of these properties are strings. For key events that generate printable characters, key and char will be equal to the generated text. For control keys, the key property will be a string like「Enter」,「Delete」, or「Left」that identifies the key. The char property will either be null, or, for control keys like Tab that have a character code, it will be the string generated by the key. At the time of this writing, no browsers support these key and char properties, but Example 17-8 will use the key property if and when it is implemented.

HTML5 Events

HTML5 and related standards define a host of new APIs for web applications (see Chapter 22). Many of these APIs define events. This section lists and briefly describes these HTML5 and web application events. Some of these events are ready to be used now and are explained in more detail elsewhere in the book. Others are not yet widely implemented and are not documented in any detail.

One of the widely advertised features of HTML is inclusion of <audio> and <video> elements for playing sound and video. These elements have a long list of events that they trigger to send notifications about network events, data buffering status, and playback state:

canplay loadeddata playing stalled canplaythrough loadedmetadata progress suspend durationchange loadstart ratechange timeupdate emptied pause seeked volumechange ended play seeking waiting

These media events are passed an ordinary event object with no special properties. The target property identifies the <audio> or <video> element, however, and that element has many relevant properties and methods. See Scripting Audio and Video for more details on these elements, their properties, and their events.

The HTML5 drag-and-drop API allows JavaScript applications to participate in OS-based drag-and-drop operations, transferring data between web applications and native applications. The API defines the following seven event types:

dragstart drag dragend dragenter dragover dragleave drop

These drag-and-drop events are triggered with an event object like those sent with mouse events. One additional property, dataTransfer, holds a DataTransfer object that contains information about the data being transferred and the formats in which it is available. The HTML5 drag-and-drop API is explained and demonstrated in Drag and Drop Events.

HTML5 defines a history management mechanism (History Management) that allows web applications to interact with the browser’s Back and Forward buttons. This mechanism involves events named hashchange and popstate. These events are lifecycle notification events like load and unload and are fired at the Window object rather than any individual document element.

HTML5 defines a lot of new features for HTML forms. In addition to standardizing the form input event described earlier, HTML5 also defines a form validation mechanism, which includes an invalid event fired on form elements that have failed validation. Browser vendors other than Opera have been slow to implement HTML5’s new form features and events, however, and this book does not cover them.

HTML5 includes support for offline web applications (see Application Storage and Offline Webapps) that can be installed locally in an application cache so that they can run even when the browser is offline (as when a mobile device is out of network range). The two most important events associated with this are the offline and online events: they are triggered on the Window object whenever the browser loses or gains a network connection. A number of additional events are defined to provide notification of application download progress and application cache updates:

cached checking downloading error noupdate obsolete progress updateready

A number of new web application APIs use a message event for asynchronous communication. The Cross-Document Messaging API (Cross-Origin Messaging) allows scripts in a document from one server to exchange messages with scripts in a document from another server. This works around the limitations of the same-origin policy (The Same-Origin Policy) in a secure way. Each message that is sent triggers a message event on the Window of the receiving document. The event object passed to the handler includes a data property that holds the content of the message as well as source and origin policies that identify the sender of the message. The message event is used in similar ways for communication with Web Workers (Web Workers) and for network communication via Server-Sent Events (Comet with Server-Sent Events) and WebSockets (Web Sockets).

HTML5 and related standards define some events that are triggered on objects other than windows, documents, and document elements. Version 2 of the XMLHttpRequest specification, as well as the File API specification, define a series of events that track the progress of asynchronous I/O. They trigger events on an XMLHttpRequest or FileReader object. Each read operation begins with a loadstart event, followed by progress events and a loadend event. Additionally, each operation ends with a load, error, or abort event just before the final loadend event. See HTTP Progress Events and Reading Blobs for details.

Finally, HTML5 and related standards define a few miscellaneous event types. The Web Storage (localStorage and sessionStorage) API defines a storage event (on the Window object) that provides notification of changes to stored data. HTML5 also standardizes the beforeprint and afterprint events that were originally introduced by Microsoft in IE. As their names imply, these events are triggered on a Window immediately before and immediately after its document is printed and provide an opportunity to add or remove content such as the date and time that the document was printed. (These events should not be used to change the presentation of a document for printing because CSS media types already exist for that purpose.)

Touchscreen and Mobile Events

The widespread adoption of powerful mobile devices, particularly those with touchscreens, has required the creation of new categories of events. In many cases, touchscreen events are mapped to traditional event types such as click and scroll. But not every interaction with a touchscreen UI emulates a mouse, and not all touches can be treated as mouse events. This section briefly explains the gesture and touch events generated by Safari when running on Apple’s iPhone and iPad devices and also covers the orientationchange event generated when the user rotates the device. At the time of this writing, there are no standards for these events, but the W3C has begun work on a「Touch Events Specification」that uses Apple’s touch event as a starting point. These events are not documented in the reference section of this book, but you can find more information at the Apple Developer Center.

Safari generates gesture events for two-finger scaling and rotation gestures. The gesturestart event is fired when the gesture begins and gestureend is fired when it ends. Between these two events are a sequence of gesturechange events that track the progress of the gesture. The event object sent with these events has numeric scale and rotation properties. The scale property is the ratio of the current distance between the two fingers to the initial distance between the fingers. A「pinch close」gesture has a scale less than 1.0, and a「pinch open」gesture has a scale greater than 1.0. The rotation property is the angle of finger rotation since the start of the event. It is reported in degrees, with positive values indicating clockwise rotation.

Gesture events are high-level events that notify you of a gesture that has already been interpreted. If you want to implement your own custom gestures, you can listen for low-level touch events. When a finger touches the screen a touchstart event is triggered. When the finger moves, a touchmove event is triggered. And when the finger is lifted from the screen, a touchend event is triggered. Unlike mouse events, touch events do not directly report the coordinates of the touch. Instead, the object sent with a touch event has a changedTouches property. This property is an array-like object whose elements each describe the position of a touch.

The orientationchanged event is triggered on the Window object by devices that allow the user to rotate the screen from portrait to landscape mode. The object passed with an orientationchanged event is not useful itself. In mobile Safari, however, the orientation property of the Window object gives the current orientation as one of the numbers 0, 90, 180, or -90.

* * *

[37] Some sources, including the HTML5 specification, make a technical distinction between handlers and listeners, based on the way in which they are registered. In this book we treat the two terms as synonyms.

[38] Standards define a hierarchy of event object interfaces for different types of events. The Event interface describes「plain」events with no extra details. The MouseEvent subinterface describes the additional fields available in the event objects passed with mouse events, and the KeyEvent subinterface describes the fields you can use with keyboard events, for example. In this book, the reference section collapses all those common event interfaces into a single Event reference page.

[39] The only event in common use with「DOM」in its name is DOMContentLoaded. This event was introduced by Mozilla and was never part of the DOM Events standard.

Registering Event Handlers

There are two basic ways to register event handlers. The first, from the early days of the Web, is to set a property on the object or document element that is the event target. The second, newer and more general, technique is to pass the handler to a method of the object or element. To complicate matters, there are two versions of each technique. You can set an event handler property in JavaScript code, or for document elements, you can set the corresponding attribute directly in HTML. For handler registration by method invocation, there is a standard method, named addEventListener(), that is supported by all browsers except IE8 and before, and a different method, named attach Event() , for all versions of IE before IE9.

Setting Event Handler Properties

The simplest way to register an event handler is by setting a property of the event target to the desired event handler function. By convention, event handler properties have names that consist of the word「on」followed by the event name: onclick, onchange, onload, onmouseover, and so on. Note that these property names are case sensitive and are written in all lowercase, even when the event type (such as「readystatechange」consists of multiple words. Here are two example event handler registrations:

// Set the onload property of the Window object to a function. // The function is the event handler: it is invoked when the document loads. window.onload = function() { // Look up a <form> element var elt = document.getElementById("shipping_address"); // Register an event handler function that will be invoked right // before the form is submitted. elt.onsubmit = function() { return validate(this); } }

This event handler registration technique works in all browsers for all commonly used event types. In general, all widely implemented web APIs that define events allow handlers to be registered by setting event handler properties.

The shortcoming of event handler properties is that they are designed around the assumption that event targets will have at most one handler for each type of event. If you are writing library code for use in arbitrary documents, it is better to register event handlers using a technique (such as addEventListener()) that will not modify or overwrite any previously registered handlers.

Setting Event Handler Attributes

The event handler properties of a document element can also be set as attributes on the corresponding HTML tag. If you do this, the attribute value should be a string of JavaScript code. That code should be the body of the event handler function, not a complete function declaration. That is, your HTML event handler code should not be surrounded by curly braces and prefixed with the function keyword. For example:

<button onclick="alert('Thank you');">Click Here</button>

If an HTML event handler attribute contains multiple JavaScript statements, you must remember to separate those statements with semicolons or to break the attribute value across multiple lines.

Some event types are directed at the browser as a whole, rather than at any particular document element. In JavaScript, handlers for these events are registered on the Window object. In HTML, we place them on the <body> tag, but the browser registers them on the Window. The following is the complete list of such event handlers as defined by the draft HTML5 specification:

onafterprint onfocus ononline onresize onbeforeprint onhashchange onpagehide onstorage onbeforeunload onload onpageshow onundo onblur onmessage onpopstate onunload onerror onoffline onredo

When you specify a string of JavaScript code as the value of an HTML event handler attribute, the browser converts your string into a function that looks something like this:

function(event) { with(document) { with(this.form || {}) { with(this) { /* your code here */ } } } }

If the browser supports ES5, the function is defined in non-strict mode (see「use strict」). We’ll see more about the event argument and the with statements when we consider event handler invocation in Event Handler Invocation.

A common style in client-side programming involves keeping HTML content separate from JavaScript behavior. Programmers who follow this discipline shun (or at least avoid) HTML event handler attributes, since they directly mix JavaScript and HTML.

addEventListener()

In the standard event model supported by all browsers other than IE8 and earlier, any object that can be an event target—this includes the Window and Document objects and all document Elements—defines a method named addEventListener() that you can use to register an event handler for that target. addEventListener() takes three arguments. The first is the event type for which the handler is being registered. The event type (or name) is a string and it should not include the「on」prefix that is used when setting event handler properties. The second argument to addEventListener() is the function that should be invoked when the specified type of event occurs. The final argument to addEventListener() is a boolean value. Normally, you’ll pass false for this argument. If you pass true instead, your function is registered as a capturing event handler and is invoked at a different phase of event dispatch. We’ll cover event capturing in Event Propagation. You ought to be able to omit the third argument instead of passing false, and the specification may eventually change to allow this, but at the time of this writing, omitting that argument is an error in some current browsers.

The code below registers two handlers for the click event on a <button> element. Note the differences between the two techniques used:

<button id="mybutton">Click me</button> <script> var b = document.getElementById("mybutton"); b.onclick = function() { alert("Thanks for clicking me!"); }; b.addEventListener("click", function() { alert("Thanks again!"); }, false); </script>

Calling addEventListener() with「click」as its first argument does not affect the value of the onclick property. In the code above, a button click will generate two alert() dialog boxes. More importantly, you can call addEventListener() multiple times to register more than one handler function for the same event type on the same object. When an event occurs on an object, all of the handlers registered for that type of event are invoked, in the order in which they were registered. Invoking addEventListener() more than once on the same object with the same arguments has no effect—the handler function remains registered only once, and the repeated invocation does not alter the order in which handlers are invoked.

addEventListener() is paired with a removeEventListener() method that expects the same three arguments but removes an event handler function from an object rather than adding it. It is often useful to temporarily register an event handler and then remove it soon afterward. For example, when you get a mousedown event, you might register temporary capturing event handlers for mousemove and mouseup events so that you can see if the user drags the mouse. You’d then deregister these handlers when the mouseup event arrives. In such a situation, your event handler removal code might look like this:

document.removeEventListener("mousemove", handleMouseMove, true); document.removeEventListener("mouseup", handleMouseUp, true);

attachEvent()

Internet Explorer, prior to IE9, does not support addEventListener() and remove Event Listener() . In IE5 and later, it defines similar methods attachEvent() and detachEvent().

The attachEvent() and detachEvent() methods work like addEventListener() and removeEventListener(), with the following exceptions:

Since the IE event model does not support event capturing, attachEvent() and detachEvent() expect only two arguments: the event type and the handler function.

The first argument to the IE methods is an event handler property name, with the「on」prefix, rather than the unprefixed event type. For example, pass「onclick」to attachEvent() where you would pass「click」to addEventListener().

attachEvent() allows the same event handler function to be registered more than once. When an event of the specified type occurs, the registered function will be invoked as many times as it was registered.

It is common to see event handler registration code that uses addEventListener() in browsers that support it and otherwise uses attachEvent():

var b = document.getElementById("mybutton"); var handler = function() { alert("Thanks!"); }; if (b.addEventListener) b.addEventListener("click", handler, false); else if (b.attachEvent) b.attachEvent("onclick", handler);

Event Handler Invocation

Once you’ve registered an event handler, the web browser will invoke it automatically when an event of the specified type occurs on the specified object. This section describes event handler invocation in detail, explaining event handler arguments, the invocation context (the this value), the invocation scope, and the meaning of the return value of an event handler. Unfortunately, some of these details are different for IE8 and before than for other browsers.

In addition to describing how individual handlers are invoked, this section also explains how events propagate: how a single event can trigger the invocation of multiple handlers on the original event target and also on containing elements of the document.

Event Handler Argument

Event handlers are normally (there is one exception, described below) invoked with an event object as their single argument. The properties of the event object provide details about the event. The type property, for example, specifies the type of the event that occurred. Types of Events mentioned a number of other event object properties for various event types.

In IE8 and before, event handlers registered by setting a property are not passed an event object when they are invoked. Instead, the event object is available through the global variable window.event. For portability, you can write event handlers like this, so that they use the window.event if no argument is supplied:

function handler(event) { event = event || window.event; // Handler code goes here }

Event handlers registered with attachEvent() are passed an event object, but they can also use window.event.

Recall from Setting Event Handler Attributes that when you register an event handler by setting an HTML attribute, the browser converts your string of JavaScript code into a function. Browsers other than IE construct a function with a single argument named event. IE constructs a function that expects no argument. If you use the identifier event in such a function, you are referring to window.event. In either case, HTML event handlers can refer to the event object as event.

Event Handler Context

When you register an event handler by setting a property, it looks as if you are defining a new method on the document element:

e.onclick = function() { /* handler code */ };

It isn’t surprising, therefore, that event handlers are invoked (with one IE-related exception, described below) as methods of the object on which they are defined. That is, within the body of an event handler, the this keyword refers to the event target.

Handlers are invoked with the target as their this value even when registered using addEventListener(). Unfortunately, however, this is not true for attachEvent(): handlers registered with attachEvent() are invoked as functions, and their this value is the global (Window) object. You can work around this with code like this:

/* * Register the specified handler function to handle events of the specified * type on the specified target. Ensure that the handler will always be * invoked as a method of the target. */ function addEvent(target, type, handler) { if (target.addEventListener) target.addEventListener(type, handler, false); else target.attachEvent("on" + type, function(event) { // Invoke the handler as a method of target, // passing on the event object return handler.call(target, event); }); }

Note that event handlers registered using this method cannot be removed, since the wrapper function passed to attachEvent() is not retained anywhere to be passed to detachEvent().

Event Handler Scope

Like all JavaScript functions, event handlers are lexically scoped. They are executed in the scope in which they are defined, not the scope from which they are invoked, and they can access any local variables from that scope. (This is demonstrated in the add Event() function above, for example.)

Event handlers registered as HTML attributes are a special case, however. They are converted into top-level functions that have access to global variables but not to any local variables. But, for historical reasons, they run with a modified scope chain. Event handlers defined by HTML attributes can use the properties of the target object, the containing <form> object (if there is one), and the Document object as if they are local variables. Setting Event Handler Attributes shows how an event handler function is created from an HTML event handler attribute, and the code there approximates this modified scope chain using with statements.

HTML attributes are not natural places to include long strings of code, and this modified scope chain allows helpful shortcuts. You can use tagName instead of this.tagName. You can use getElementById instead of document.getElementById. And, for document elements that are inside a <form>, you can refer to any other form element by ID, using zipcode, for example, instead of this.form.zipcode.

On the other hand, the modified scope chain of HTML event handlers is a source of pitfalls, since the properties of each of the objects in the chain shadow any properties of the same name in the global object. The Document object defines a (rarely used) open() method, for example, so an HTML event handler that wants to invoke the open() method of the Window object must explicitly write window.open instead of open. There is a similar (but more pernicious) problem with forms, because the names and IDs of form elements define properties on the containing form element (see Selecting Forms and Form Elements). So if a form contains an element with the ID「location」, for example, all HTML event handlers within that form must use window.location instead of location if they want to refer to the window’s Location object.

Handler Return Value

The return value of an event handler registered by setting an object property or an HTML attribute is sometimes significant. In general, a return value of false tells the browser that it should not perform the default action associated with the event. The onclick handler of a Submit button in a form, for example, can return false to prevent the browser from submitting the form. (This is useful if the user’s input fails client-side validation.) Similarly, an onkeypress handler on an input field can filter keyboard input by returning false if the user types an inappropriate character. (Example 17-6 filters keyboard input in this way.)

The return value of the onbeforeunload handler of the Window object is also significant. This event is triggered when the browser is about to navigate to a new page. If this event handler returns a string, it will be displayed in a modal dialog box that asks the user to confirm that she wants to leave the page.

It is important to understand that event handler return values are significant only for handlers registered as properties. We’ll see below that event handlers registered with addEventListener() or attachEvent() must instead call the preventDefault() method or set the returnValue property of the event object.

Invocation Order

A document element or other object may have more than one event handler registered for a particular type of event. When an appropriate event occurs, the browser must invoke all of the handlers, following these rules of invocation order:

Handlers registered by setting an object property or HTML attribute, if any, are always invoked first.

Handlers registered with addEventListener() are invoked in the order in which they were registered.[40]

Handlers registered with attachEvent() may be invoked in any order and your code should not depend on sequential invocation.

Event Propagation

When the target of an event is the Window object, or some other standalone object (such as an XMLHttpRequest), the browser responds to an event simply by invoking the appropriate handlers on that one object. When the event target is a Document or document Element, however, the situation is more complicated.

After the event handlers registered on the target element are invoked, most events「bubble」up the DOM tree. The event handlers of the target’s parent are invoked. Then the handlers registered on the target’s grandparent are invoked. This continues up to the Document object, and then beyond to the Window object. Event bubbling provides an alternative to registering handlers on lots of individual document elements: instead you can register a single handler on a common ancestor element and handle events there. You might register an「change」handler on a <form> element, for example, instead of registering a「change」handler for every element in the form.

Most events that occur on document elements bubble. Notable exceptions are the focus, blur, and scroll events. The load event on document elements bubbles, but it stops bubbling at the Document object and does not propagate on to the Window object. The load event of the Window object is triggered only when the entire document has loaded.

Event bubbling is the third「phase」of event propagation. The invocation of the event handlers of the target object itself is the second phase. The first phase, which occurs even before the target handlers are invoked, is called the「capturing」phase. Recall that addEventListener() takes a boolean value as its third argument. If that argument is true, the event handler is registered as a capturing event handler for invocation during this first phase of event propagation. Event bubbling is universally supported: it works in all browsers including IE, and it works for all handlers, regardless of how they are registered (unless they are registered as capturing event handlers). Event capturing, by contrast, only works with event handlers registered with add Event Listener() when the third argument is true. This means that event capturing is not available in IE prior to IE9, and is not, at the time of this writing, a commonly used technique.

The capturing phase of event propagation is like the bubbling phase in reverse. The capturing handlers of the Window object are invoked first, then the capturing handlers of the Document object, then of the body object, and so on down the DOM tree until the capturing event handlers of the parent of the event target are invoked. Capturing event handlers registered on the event target itself are not invoked.

Event capturing provides an opportunity to peek at events before they are delivered to their target. A capturing event handler can be used for debugging, or it can be used along with the event cancellation technique described below to filter events so that the target event handlers are never actually invoked. One common use for event capturing is handling mouse drags, where mouse motion events need to be handled by the object being dragged, not the document elements over which it is dragged. See Example 17-2 for an example.

Event Cancellation

Handler Return Value explained that the return value of event handlers registered as properties can be used to cancel the browser’s default action for the event. In browsers that support addEventListener(), you can also cancel the default action for an event by invoking the preventDefault() method of the event object. In IE prior to IE9, however, you do the same by setting the returnValue property of the event object to false. The following code shows a dummy event handler that uses all three cancellation techniques:

function cancelHandler(event) { var event = event || window.event; // For IE /* Do something to handle the event here */ // Now cancel the default action associated with the event if (event.preventDefault) event.preventDefault(); // Standard technique if (event.returnValue) event.returnValue = false; // IE return false; // For handlers registered as object properties }

The current DOM Events module draft defines a property of the Event object named defaultPrevented. It is not yet widely supported, but the intent is that this property will normally be false but will become true if preventDefault() is called.[41]

Canceling the default action associated with an event is only one kind of event cancellation. We can also cancel the propagation of events. In browsers that support add Event Listener(), the event object has a stopPropagation() method that you can invoke to prevent the continued propagation of the event. If there are other handlers defined on the same object, the rest of those handlers will still be invoked, but no event handlers on any other object will be invoked after stopPropagation() is called. The stop Propagation() method can be called at any time during event propagation. It works during the capturing phase, at the event target itself, and during the bubbling phase.

Prior to IE9, IE does not support the stopPropagation() method. Instead, the IE event object has a property named cancelBubble. Set this property to true to prevent any further propagation. (IE8 and before do not support the capturing phase of event propagation, so bubbling is the only kind of propagation to be canceled.)

The current draft DOM Events specification defines another method on the Event object, named stopImmediatePropagation(). Like stopPropagation(), this method prevents the propagation of the event to any other objects. But it also prevents the invocation of any other event handlers registered on the same object. At the time of this writing, some browsers support stopImmediatePropagation() and some do not. Some utility libraries, like jQuery and YUI, define stopImmediatePropagation() in a cross-platform way.

* * *

[40] The DOM Level 2 standard leaves the invocation order undefined, but current browsers all invoke the handlers in registration order and the current DOM Level 3 draft standardizes this behavior.

[41] The jQuery (see Chapter 19) event object has a defaultPrevented() method instead of a property.

Document Load Events

Now that we’ve covered the fundamentals of JavaScript event handling, we’ll start looking in more detail at specific categories of events. We begin, in this section, with document load events.

Most web applications need notification from the web browser to tell them when the document has been loaded and is ready to be manipulated. The load event on the Window object serves this purpose and was discussed in detail in Chapter 13, which included an onLoad() utility function in Example 13-5. The load event does not fire until a document and all of its images are fully loaded. It is usually safe, however, to start running your scripts after the document is fully parsed but before images are downloaded. You can improve the startup time of your web applications if you trigger your scripts on events other than「load」.

The DOMContentLoaded event is fired when the document has been loaded and parsed and any deferred scripts have been executed. Images and async scripts may still be loading, but the document is ready to be manipulated. (Deferred and async scripts are explained in Synchronous, Asynchronous, and Deferred Scripts.) This event was introduced by Firefox, and it has been adopted by all other browser vendors, including Microsoft in IE9. Despite the「DOM」in its name, it is not part of the DOM Level 3 event standard, but it is standardized by HTML5.

As described in Client-Side JavaScript Timeline, the document.readyState property changes as the document loads. In IE, each change in state is accompanied by a readystatechange event on the Document object, and it is possible to use this event to determine when IE reaches the「complete」state. HTML5 standardizes the readystatechange event, but fires it immediately before the load event, so it is not clear that much advantage is gained by listening for「readystatechange」instead of「load」.

Example 17-1 defines a whenReady() function that is much like the onLoad() function of Example 13-5. Functions passed to whenReady() will be invoked (as methods of the Document object) when the document is ready to be manipulated. Unlike the earlier onLoad() function, whenReady() listens for DOMContentLoaded and readystatechange events, and uses load events only as backup for older browsers that do not support the earlier events. Some of the examples that follow (in this and subsequent chapters) use this whenReady() function.

Example 17-1. Invoking functions when the document is ready

/* * Pass a function to whenReady() and it will be invoked (as a method of the * document) when the document is parsed and ready for manipulation. Registered * functions are triggered by the first DOMContentLoaded, readystatechange, or * load event that occurs. Once the document is ready and all functions have * been invoked, any functions passed to whenReady() will be invoked * immediately. */ var whenReady = (function() { // This function returns the whenReady() function var funcs = []; // The functions to run when we get an event var ready = false; // Switches to true when the handler is triggered // The event handler invoked when the document becomes ready function handler(e) { // If we've already run once, just return if (ready) return; // If this was a readystatechange event where the state changed to // something other than "complete", then we're not ready yet if (e.type === "readystatechange" && document.readyState !== "complete") return; // Run all registered functions. // Note that we look up funcs.length each time, in case calling // one of these functions causes more functions to be registered. for(var i = 0; i < funcs.length; i++) funcs[i].call(document); // Now set the ready flag to true and forget the functions ready = true; funcs = null; } // Register the handler for any event we might receive if (document.addEventListener) { document.addEventListener("DOMContentLoaded", handler, false); document.addEventListener("readystatechange", handler, false); window.addEventListener("load", handler, false); } else if (document.attachEvent) { document.attachEvent("onreadystatechange", handler); window.attachEvent("onload", handler); } // Return the whenReady function return function whenReady(f) { if (ready) f.call(document); // If already ready, just run it else funcs.push(f); // Otherwise, queue it for later. } }());

Mouse Events

There are quite a few mouse-related events. Table 17-1 lists them all. All mouse events except「mouseenter」and「mouseleave」bubble. Click events on links and Submit buttons have default actions that can be prevented. You may be able to cancel a context menu event to prevent the display of a context menu, but some browsers have configuration options that make context menus noncancelable.

Table 17-1. Mouse events

TypeDescription

click A higher-level event fired when the user presses and releases a mouse button or otherwise「activates」an element.

contextmenu A cancelable event fired when a contextmenu is about to be popped up. Current browsers display context menus on right mouse clicks, so this event can also be used like the click event.

dblclick Fired when the user double-clicks the mouse

mousedown Fired when the user presses a mouse button

mouseup Fired when the user releases a mouse button

mousemove Fired when the user moves the mouse.

mouseover Fired when the mouse enters an element. relatedTarget (or fromElement in IE); specifies what element the mouse is coming from.

mouseout Fired when the mouse leaves an element. relatedTarget (or toElement in IE); specifies what element the mouse is going to.

mouseenter Like「mouseover」, but does not bubble. Introduced by IE and standardized in HTML5 but not yet widely implemented.

mouseleave Like「mouseout」, but does not bubble. Introduced by IE and standardized in HTML5 but not yet widely implemented.

The object passed to mouse event handlers has clientX and clientY properties that specify the coordinates of the mouse pointer relative to the containing window. Add the window’s scroll offsets (see Example 15-8) to convert this position to document coordinates.

The altKey, ctrlKey, metaKey, and shiftKey properties specify whether various keyboard modifier keys were held down when the event occurred: this allows you to distinguish an ordinary click from a Shift-click, for example.

The button property specifies which mouse button, if any, was held down when the event occurred. Different browsers assign different values to this property, however, so it is difficult to use portably. See the Event reference page for details. Some browsers only fire click events for left button clicks. You should use mousedown and mouseup if you need to detect clicks of other buttons. The contextmenu event usually signals a right-button click, but as noted above, it may be impossible to prevent the appearance of a context menu when this event occurs.

The event object for mouse events has a few other mouse-specific properties, but they are not as commonly used as these. See the Event reference page for a list.

Example 17-2 shows a JavaScript function, drag(), that, when invoked from a mousedown event handler, allows an absolutely positioned document element to be dragged by the user. drag() works with both the DOM and IE event models.

drag() takes two arguments. The first is the element that is to be dragged. This may be the element on which the mousedown event occurred or a containing element (e.g., you might allow the user to drag on an element that looks like a titlebar to move the containing element that looks like a window). In either case, however, it must be a document element that is absolutely positioned using the CSS position attribute. The second argument is the event object from the triggering mousedown event. Here’s a simple example that uses drag(). It defines an <img> that the user can drag if the Shift key is held down:

<img src="draggable.gif" style="position:absolute; left:100px; top:100px;" onmousedown="if (event.shiftKey) drag(this, event);">

The drag() function converts the position of the mousedown event to document coordinates in order to compute the distance between the mouse pointer and the upper-left corner of the element being moved. It uses getScrollOffsets() from Example 15-8 to help with the coordinate conversion. Next, drag() registers event handlers for the mousemove and mouseup events that follow the mousedown event. The mousemove handler is responsible for moving the document element, and the mouseup handler is responsible for deregistering itself and the mousemove handler.

It is important to note that the mousemove and mouseup handlers are registered as capturing event handlers. This is because the user may move the mouse faster than the document element can follow it, and if that happens, some of the mousemove events occur outside the original target element. Without capturing, those events will not be dispatched to the correct handlers. The IE event model does not support event capturing the way the standard event model does, but it does have a special-purpose setCapture() method for capturing mouse events in cases just like this. The example code shows how it works.

Finally, note that the moveHandler() and upHandler() functions are defined within drag(). Because they are defined in this nested scope, they can use the arguments and local variables of drag(), which considerably simplifies their implementation.

Example 17-2. Dragging document elements

/** * Drag.js: drag absolutely positioned HTML elements. * * This module defines a single drag() function that is designed to be called * from an onmousedown event handler. Subsequent mousemove events will * move the specified element. A mouseup event will terminate the drag. * This implementation works with both the standard and IE event models. * It requires the getScrollOffsets() function from elsewhere in this book. * * Arguments: * * elementToDrag: the element that received the mousedown event or * some containing element. It must be absolutely positioned. Its * style.left and style.top values will be changed based on the user's * drag. * * event: the Event object for the mousedown event. **/ function drag(elementToDrag, event) { // The initial mouse position, converted to document coordinates var scroll = getScrollOffsets(); // A utility function from elsewhere var startX = event.clientX + scroll.x; var startY = event.clientY + scroll.y; // The original position (in document coordinates) of the element // that is going to be dragged. Since elementToDrag is absolutely // positioned, we assume that its offsetParent is the document body. var origX = elementToDrag.offsetLeft; var origY = elementToDrag.offsetTop; // Compute the distance between the mouse down event and the upper-left // corner of the element. We'll maintain this distance as the mouse moves. var deltaX = startX - origX; var deltaY = startY - origY; // Register the event handlers that will respond to the mousemove events // and the mouseup event that follow this mousedown event. if (document.addEventListener) { // Standard event model // Register capturing event handlers on the document document.addEventListener("mousemove", moveHandler, true); document.addEventListener("mouseup", upHandler, true); } else if (document.attachEvent) { // IE Event Model for IE5-8 // In the IE event model, we capture events by calling // setCapture() on the element to capture them. elementToDrag.setCapture(); elementToDrag.attachEvent("onmousemove", moveHandler); elementToDrag.attachEvent("onmouseup", upHandler); // Treat loss of mouse capture as a mouseup event. elementToDrag.attachEvent("onlosecapture", upHandler); } // We've handled this event. Don't let anybody else see it. if (event.stopPropagation) event.stopPropagation(); // Standard model else event.cancelBubble = true; // IE // Now prevent any default action. if (event.preventDefault) event.preventDefault(); // Standard model else event.returnValue = false; // IE /** * This is the handler that captures mousemove events when an element * is being dragged. It is responsible for moving the element. **/ function moveHandler(e) { if (!e) e = window.event; // IE event Model // Move the element to the current mouse position, adjusted by the // position of the scrollbars and the offset of the initial click. var scroll = getScrollOffsets(); elementToDrag.style.left = (e.clientX + scroll.x - deltaX) + "px"; elementToDrag.style.top = (e.clientY + scroll.y - deltaY) + "px"; // And don't let anyone else see this event. if (e.stopPropagation) e.stopPropagation(); // Standard else e.cancelBubble = true; // IE } /** * This is the handler that captures the final mouseup event that * occurs at the end of a drag. **/ function upHandler(e) { if (!e) e = window.event; // IE Event Model // Unregister the capturing event handlers. if (document.removeEventListener) { // DOM event model document.removeEventListener("mouseup", upHandler, true); document.removeEventListener("mousemove", moveHandler, true); } else if (document.detachEvent) { // IE 5+ Event Model elementToDrag.detachEvent("onlosecapture", upHandler); elementToDrag.detachEvent("onmouseup", upHandler); elementToDrag.detachEvent("onmousemove", moveHandler); elementToDrag.releaseCapture(); } // And don't let the event propagate any further. if (e.stopPropagation) e.stopPropagation(); // Standard model else e.cancelBubble = true; // IE } }

The following code shows how you can use drag() in an HTML file (it’s a simplified version of Example 16-2, with the addition of dragging):

<script src="getScrollOffsets.js"></script> <!-- drag() requires this --> <script src="Drag.js"></script> <!-- defines drag() --> <!-- The element to be dragged --> <div style="position:absolute; left:100px; top:100px; width:250px; background-color: white; border: solid black;"> <!-- The "titlebar" to drag it with. Note the onmousedown attribute. --> <div style="background-color: gray; border-bottom: dotted black; padding: 3px; font-family: sans-serif; font-weight: bold;" onmousedown="drag(this.parentNode, event);"> Drag Me <!-- The content of the titlebar --> </div> <!-- Content of the draggable element --> <p>This is a test. Testing, testing, testing.</p><p>Test</p><p>Test</p> </div>

The key here is the onmousedown attribute of the inner <div> element. Note that it uses this.parentNode to specify that the entire container element is to be dragged.

Mousewheel Events

All modern browsers support mouse wheels and fire events when the user rotates the mousewheel. Browsers often use the mousewheel to scroll the document or to zoom in or out, but you can cancel the mousewheel event to prevent those default actions.

There are a number of interoperability issues that affect mousewheel events, but it is possible to write code that works on all platforms. At the time of this writing, all browsers but Firefox support an event named「mousewheel」. Firefox uses「DOMMouseScroll」instead. And the DOM Level 3 Events draft proposes an event named「wheel」instead of「mousewheel」. In addition to the differences in event names, the objects passed to these various events use different property names to specify the amount of wheel rotation that occurred. Finally, note that there are fundamental hardware distinctions between mouse wheels as well. Some allow 1-dimensional rotation forward and back and some (particularly on Macs) also allow rotation left and right (on these mice the「wheel」is really a trackball). The DOM Level 3 standard even includes support for 3-dimensional mouse「wheels」that can report clockwise or counter-clockwise rotation in addition to forward/back and left/right.

The event object passed to a「mousewheel」handler has a wheelDelta property that specifies how far the user turned the wheel. One mousewheel「click」away from the user is generally a delta of 120 and one click toward the user is -120. In Safari and Chrome, to support Apple’s mice that include a two-dimensional trackball instead of a one-dimensional mousewheel, the event object has wheelDeltaX and wheelDeltaY properties in addition to wheelDelta, and wheelDelta and wheelDeltaY are always the same value.

In Firefox you can the nonstandard DOMMouseScroll event instead of mousewheel and use the detail property of the event object instead of wheelDelta. The scaling and sign of this detail property is different than wheelDelta, however: multiply detail by -40 to compute the equivalent wheelDelta value.

At the time of this writing, the DOM Level 3 Events draft standard defines a wheel event as the standardized version of mousewheel and DOMMouseScroll. The object passed to a wheel event handler will have deltaX, deltaY, and deltaZ properties to specify rotation in three dimensions. You must multiply these values by -120 to match the value and sign of a mousewheel event.

For all of these event types, the event object is like a mouse event object: it includes mouse pointer coordinates and the state of the keyboard modifier keys.

Example 17-3 demonstrates how to work with mouse wheel events and how to do so interoperably across platforms. It defines a function named enclose() that wraps a「frame」or「viewport」of the specified size around a larger content element (such as an image) and defines a mouse wheel event handler that allows the user to pan the content element within the viewport and also to resize the viewport. You might use this enclose() function with code like this:

<script src="whenReady.js"></script> <script src="Enclose.js"></script> <script> whenReady(function() { enclose(document.getElementById("content"),400,200,-200,-300); }); </script> <style>div.enclosure { border: solid black 10px; margin: 10px; }</style> <img id="content" src="testimage.jpg"/>

In order to work correctly in all common browsers, Example 17-3 must perform some browser testing (Browser Testing). The example anticipates the DOM Level 3 Events specification and includes code to use the wheel event when browsers implement it.[42] It also includes some future-proofing to stop using the DOMMouseScroll event when Firefox starts firing wheel or mousewheel. Note that Example 17-3 is also a practical example of the element geometry and CSS positioning techniques explained in Document and Element Geometry and Scrolling and Positioning Elements with CSS.

Example 17-3. Handling mousewheel events

// Enclose the content element in a frame or viewport of the specified width // and height (minimum 50x50). The optional contentX and contentY arguments // specify the initial offset of the content relative to the frame. (If // specified, they must be <= 0.) The frame has mousewheel event handlers that // allow the user to pan the element, and to shrink or enlarge the frame. function enclose(content, framewidth, frameheight, contentX, contentY) { // These arguments aren't just the initial values: they maintain the // current state and are used and modified by the mousewheel handler. framewidth = Math.max(framewidth, 50); frameheight = Math.max(frameheight, 50); contentX = Math.min(contentX, 0) || 0; contentY = Math.min(contentY, 0) || 0; // Create the frame element and set a CSS classname and styles var frame = document.createElement("div"); frame.className = "enclosure"; // So we can define styles in a stylesheet frame.style.width = framewidth + "px"; // Set the frame size. frame.style.height = frameheight + "px"; frame.style.overflow = "hidden"; // No scrollbars, no overflow frame.style.boxSizing = "border-box"; // Border-box simplifies the frame.style.webkitBoxSizing = "border-box"; // calculations for resizing frame.style.MozBoxSizing = "border-box"; // the frame. // Put the frame in the document and move the content elt into the frame. content.parentNode.insertBefore(frame, content); frame.appendChild(content); // Position the element relative to the frame content.style.position = "relative"; content.style.left = contentX + "px"; content.style.top = contentY + "px"; // We'll need to work around some browser-specific quirks below var isMacWebkit = (navigator.userAgent.indexOf("Macintosh") !== -1 && navigator.userAgent.indexOf("WebKit") !== -1); var isFirefox = (navigator.userAgent.indexOf("Gecko") !== -1); // Register mousewheel event handlers. frame.onwheel = wheelHandler; // Future browsers frame.onmousewheel = wheelHandler; // Most current browsers if (isFirefox) // Firefox only frame.addEventListener("DOMMouseScroll", wheelHandler, false); function wheelHandler(event) { var e = event || window.event; // Standard or IE event object // Extract the amount of rotation from the event object, looking // for properties of a wheel event object, a mousewheel event object // (in both its 2D and 1D forms), and the Firefox DOMMouseScroll event. // Scale the deltas so that one "click" toward the screen is 30 pixels. // If future browsers fire both "wheel" and "mousewheel" for the same // event, we'll end up double-counting it here. Hopefully, however, // cancelling the wheel event will prevent generation of mousewheel. var deltaX = e.deltaX*-30 || // wheel event e.wheelDeltaX/4 || // mousewheel 0; // property not defined var deltaY = e.deltaY*-30 || // wheel event e.wheelDeltaY/4 || // mousewheel event in Webkit (e.wheelDeltaY===undefined && // if there is no 2D property then e.wheelDelta/4) || // use the 1D wheel property e.detail*-10 || // Firefox DOMMouseScroll event 0; // property not defined // Most browsers generate one event with delta 120 per mousewheel click. // On Macs, however, the mousewheels seem to be velocity-sensitive and // the delta values are often larger multiples of 120, at // least with the Apple Mouse. Use browser-testing to defeat this. if (isMacWebkit) { deltaX /= 30; deltaY /= 30; } // If we ever get a mousewheel or wheel event in (a future version of) // Firefox, then we don't need DOMMouseScroll anymore. if (isFirefox && e.type !== "DOMMouseScroll") frame.removeEventListener("DOMMouseScroll", wheelHandler, false); // Get the current dimensions of the content element var contentbox = content.getBoundingClientRect(); var contentwidth = contentbox.right - contentbox.left; var contentheight = contentbox.bottom - contentbox.top; if (e.altKey) { // If Alt key is held down, resize the frame if (deltaX) { framewidth -= deltaX; // New width, but not bigger than the framewidth = Math.min(framwidth, contentwidth); // content framewidth = Math.max(framewidth,50); // and no less than 50. frame.style.width = framewidth + "px"; // Set it on frame } if (deltaY) { frameheight -= deltaY; // Do the same for the frame height frameheight = Math.min(frameheight, contentheight); frameheight = Math.max(frameheight-deltaY, 50); frame.style.height = frameheight + "px"; } } else { // Without the Alt modifier, pan the content within the frame if (deltaX) { // Don't scroll more than this var minoffset = Math.min(framewidth-contentwidth, 0); // Add deltaX to contentX, but don't go lower than minoffset contentX = Math.max(contentX + deltaX, minoffset); contentX = Math.min(contentX, 0); // or higher than 0 content.style.left = contentX + "px"; // Set new offset } if (deltaY) { var minoffset = Math.min(frameheight - contentheight, 0); // Add deltaY to contentY, but don't go lower than minoffset contentY = Math.max(contentY + deltaY, minoffset); contentY = Math.min(contentY, 0); // Or higher than 0 content.style.top = contentY + "px"; // Set the new offset. } } // Don't let this event bubble. Prevent any default action. // This stops the browser from using the mousewheel event to scroll // the document. Hopefully calling preventDefault() on a wheel event // will also prevent the generation of a mousewheel event for the // same rotation. if (e.preventDefault) e.preventDefault(); if (e.stopPropagation) e.stopPropagation(); e.cancelBubble = true; // IE events e.returnValue = false; // IE events return false; } }

* * *

[42] This is risky: if future implementations do not match the draft specification current as I write this, this will backfire and the example will break.

Drag and Drop Events

Example 17-2 showed how to respond to mouse drags within an application. It is possible to use techniques like that to allow elements to be dragged and「dropped」within a web page, but true「drag-and-drop」is something else. Drag-and-drop (or DnD) is a user interface for transferring data between a「drag source」and「drop target」that may be in the same application or in different applications. DnD is a complex human/computer interaction, and APIs for implementing DnD are always complicated:

They have to tie into the underlying OS so that they can work between unrelated applications.

They must accommodate「move」,「copy」, and「link」data-transfer operations, allow the drag source and drop target to restrict the set of allowed operations, and then allow the user to choose (usually using keyboard modifiers) among the permitted set.

They must provide a way for a drag source to specify the icon or image to be dragged.

They must provide event-based notification to both the drag source and the drop target of the progress of the DnD interaction.

Microsoft introduced a DnD API into early versions of IE. It was not a well-designed or well-documented API, but other browsers have attempted to replicate it, and HTML5 standardizes something like the IE API and then adds new features that make the API much easier to use. This new easy-to-use DnD API is not implemented at the time of this writing, so this section covers the IE API, as blessed by the HTML5 standard.

The IE DnD API is tricky to use and implementation differences in current browsers make it impossible to use some of the more sophisticated parts of the API interoperably, but it does allow web applications to participate in interapplication DnD like regular desktop applications can. Browsers have always been able to perform simple DnD. If you select text in a web browser, it is easy to drag that text into a word processor. And if you select a URL in a word processor, you can drag it to the browser to make the browser visit the URL. What this section demonstrates is how to create custom drag sources that transfer data other than their textual content and custom drop targets that respond to dropped data in some way other than simply displaying it.

DnD is always event-based and the JavaScript API involves two sets of events: one set that is fired on the drag source and another set that is fired on the drop target. All DnD event handlers are passed an event object that is like a mouse event object, with the addition of a dataTransfer property. This property refers to a DataTransfer object that defines the methods and properties of the DnD API.

Drag source events are relatively simple and we’ll begin with them. Any document element that has the HTML draggable attribute is a drag source. When the user begins a mouse drag over a drag source, the browser does not select the element content: instead, it fires a dragstart event on the element. Your handler for that event should call dataTransfer.setData() to specify the data (and the type of that data) that the drag source is making available. (When the new HTML5 API is implemented, you might call dataTransfer.items.add() instead.) Your handler may also want to set data Transfer. effectAllowed to specify which of the「move」,「copy」, and「link」transfer operations are supported and it might want to call dataTransfer.setDragImage() or dataTransfer.addElement() (in browsers that support those methods) to specify an image or document element to be used as the visual representation of the drag.

While the drag progresses, the browser fires drag events on the drag source. You can listen for these events if you want to update the drag image or alter the data being offered, but it is not generally necessary to register「drag」handlers.

When a drop occurs, the dragend event is fired. If your drag source supports a「move」operation, it should check dataTransfer.dropEffect to see if a move operation was actually performed. If so, the data has been transferred elsewhere, and you should delete it from the drag source.

The dragstart event is the only one you need to implement simple custom drag sources. Example 17-4 is an example. It displays the current time in「hh:mm」format in a <span> element and updates the time once a minute. If this was all the example did, the user could select the text displayed in the clock and then drag the time. But the JavaScript code in this example makes the clock into a custom drag source by setting the draggable property of this clock element to true and defining an ondragstart event handler function. The event handler uses dataTransfer.setData() to specify a complete timestamp string (including the date, seconds, and timezone information) as the data to be dragged. It also calls dataTransfer.setDragIcon() to specify an image (a clock icon) to be dragged.

Example 17-4. A custom drag source

<script src="whenReady.js"></script> <script> whenReady(function() { var clock = document.getElementById("clock"); // The clock element var icon = new Image(); // An image to drag icon.src = "clock-icon.png"; // Image URL // Display the time once every minute function displayTime() { var now = new Date(); // Get current time var hrs = now.getHours(), mins = now.getMinutes(); if (mins < 10) mins = "0" + mins; clock.innerHTML = hrs + ":" + mins; // Display current time setTimeout(displayTime, 60000); // Run again in 1 minute } displayTime(); // Make the clock draggable // We can also do this with an HTML attribute: <span draggable="true">... clock.draggable = true; // Set up drag event handlers clock.ondragstart = function(event) { var event = event || window.event; // For IE compatability // The dataTransfer property is key to the drag-and-drop API var dt = event.dataTransfer; // Tell the browser what is being dragged. // The Date() constructor used as a function returns a timestamp string dt.setData("Text", Date() + "\n"); // Tell the browser to drag our icon to represent the timestamp, in // browsers that support that. Without this line, the browser may // use an image of the clock text as the value to drag. if (dt.setDragImage) dt.setDragImage(icon, 0, 0); }; }); </script> <style> #clock { /* Make the clock look nice */ font: bold 24pt sans; background: #ddf; padding: 10px; border: solid black 2px; border-radius: 10px; } </style> <h1>Drag timestamps from the clock</h1> <span id="clock"></span> <!-- The time is displayed here --> <textarea cols=60 rows=20></textarea> <!-- You can drop timestamps here -->

Drop targets are trickier than drag sources. Any document element can be a drop target: there is no need to set an HTML attribute as there is for drag sources; you simply need to define appropriate event listeners. (With the new HTML5 DnD API, however, you will be able to define a dropzone attribute on the drop target instead of defining some of the event handlers described below.) There are four events that are fired at drop targets. When a dragged object enters a document element, the browser fires a dragenter event on that element. Your drop target should use the dataTransfer.types property to determine whether the dragged object has data available in a format that it can understand. (You might also want to check dataTransfer.effectAllowed to ensure that the drag source and your drop target can agree on one of the move, copy, and link operations.) If these checks succeed, your drop target must let both the user and the browser know that it is interested in a drop. You can give this feedback to the user by changing its border or background color. Surprisingly, a drop target tells the browser that it is interested in a drop by canceling the event.

If an element does not cancel the dragenter event the browser sends it, the browser will not treat it as a drop target for this drag and will not send it any more events. But if a drop target does cancel the dragenter event, the browser will send dragover events as the user continues to drag the object over that target. Surprisingly (again) a drop target must listen for and cancel all of these events to indicate its continued interest in the drop. If the drop target wants to specify that it only allows move, copy, or link operations, it should use this dragover event handler to set dataTransfer.dropEffect.

If the user moves the dragged object off of a drop target that has indicated interest by canceling events, then the dragleave event will be fired on the drop target. The handler for this event should restore the element’s border or background color or undo any other visual feedback performed in response to the dragenter event. Unfortunately, both the dragenter and dragleave events bubble and if a drop target has elements nested within it, it is difficult to know whether a dragleave event means that the drag has left the drop target for an event outside of the target or for an event inside the target.

Finally, if the user drops an object on a drop target, the drop event is fired on the drop target. The handler for this event should use the dataTransfer.getData() to obtain the data that was transferred and do something appropriate with it. Alternatively, if the user dropped one or more files on the drop target, the dataTransfer.files property will be an array-like object of File objects. (See Example 18-11 for a demonstration.) With the new HTML5 API, drop event handlers will be able to loop through the elements of dataTransfer.items[] to examine both files and nonfile data.

Example 17-5 demonstrates how to make <ul> elements into drop targets and how to make the <li> elements within them into drag sources. The example is a piece of unobtrusive JavaScript that looks for <ul> elements with a class attribute that includes「dnd」and registers DnD event handlers on any such lists it finds. The event handlers make the list itself into a drop target: any text you drop onto the list is turned into a new list item and is inserted at the end of the list. The event handlers also listen for drags on the items within the list and make the text of each list item available for transfer. The drag source handlers allow「copy」and「move」operations and delete list items that are dropped in move operations. (Note, however, that not all browsers support move operations interoperably.)

Example 17-5. A list as drop target and drag source

/* * The DnD API is quite complicated, and browsers are not fully interoperable. * This example gets the basics right, but each browser is a little different * and each one seems to have its own unique bugs. This code does not attempt * browser-specific workarounds. */ whenReady(function() { // Run this function when the document is ready // Find all <ul class='dnd'> elements and call the dnd() function on them var lists = document.getElementsByTagName("ul"); var regexp = /\bdnd\b/; for(var i = 0; i < lists.length; i++) if (regexp.test(lists[i].className)) dnd(lists[i]); // Add drag-and-drop handlers to a list element function dnd(list) { var original_class = list.className; // Remember original CSS class var entered = 0; // Track enters and leaves // This handler is invoked when a drag first enters the list. It checks // that the drag contains data in a format it can process and, if so, // returns false to indicate interest in a drop. In that case, it also // highlights the drop target to let the user know of that interest. list.ondragenter = function(e) { e = e || window.event; // Standard or IE event var from = e.relatedTarget; // dragenter and dragleave events bubble, which makes it tricky to // know when to highlight or unhighlight the element in a case like // this where the <ul> element has <li> children. In browsers that // define relatedTarget we can track that. // Otherwise, we count enter/leave pairs // If we entered from outside the list or if // this is the first entrance then we need to do some stuff entered++; if ((from && !ischild(from, list)) || entered == 1) { // All the DnD info is in this dataTransfer object var dt = e.dataTransfer; // The dt.types object lists the types or formats that the data // being dragged is available in. HTML5 says the type has a // contains() method. In some browsers it is an array with an // indexOf method. In IE8 and before, it simply doesn't exist. var types = dt.types; // What formats data is available in // If we don't have any type data or if data is // available in plain text format, then highlight the // list to let the user know we're listening for drop // and return false to let the browser know. if (!types || // IE (types.contains && types.contains("text/plain")) || //HTML5 (types.indexOf && types.indexOf("text/plain")!=-1)) //Webkit { list.className = original_class + " droppable"; return false; } // If we don't recognize the data type, we don't want a drop return; // without canceling } return false; // If not the first enter, we're still interested }; // This handler is invoked as the mouse moves over the list. // We have to define this handler and return false or the drag // will be canceled. list.ondragover = function(e) { return false; }; // This handler is invoked when the drag moves out of the list // or out of one of its children. If we are actually leaving the list // (not just going from one list item to another), then unhighlight it. list.ondragleave = function(e) { e = e || window.event; var to = e.relatedTarget; // If we're leaving for something outside the list or if this leave // balances out the enters, then unhighlight the list entered--; if ((to && !ischild(to,list)) || entered <= 0) { list.className = original_class; entered = 0; } return false; }; // This handler is invoked when a drop actually happens. // We take the dropped text and make it into a new <li> element list.ondrop = function(e) { e = e || window.event; // Get the event // Get the data that was dropped in plain text format. // "Text" is a nickname for "text/plain". // IE does not support "text/plain", so we use "Text" here. var dt = e.dataTransfer; // dataTransfer object var text = dt.getData("Text"); // Get dropped data as plain text. // If we got some text, turn it into a new item at list end. if (text) { var item = document.createElement("li"); // Create new <li> item.draggable = true; // Make it draggable item.appendChild(document.createTextNode(text)); // Add text list.appendChild(item); // Add it to the list // Restore the list's original style and reset the entered count list.className = original_class; entered = 0; return false; } }; // Make all items that were originally in the list draggable var items = list.getElementsByTagName("li"); for(var i = 0; i < items.length; i++) items[i].draggable = true; // And register event handlers for dragging list items. // Note that we put these handlers on the list and let events // bubble up from the items. // This handler is invoked when a drag is initiated within the list. list.ondragstart = function(e) { var e = e || window.event; var target = e.target || e.srcElement; // If it bubbled up from something other than a <li>, ignore it if (target.tagName !== "LI") return false; // Get the all-important dataTransfer object var dt = e.dataTransfer; // Tell it what data we have to drag and what format it is in dt.setData("Text", target.innerText || target.textContent); // Tell it we know how to allow copies or moves of the data dt.effectAllowed = "copyMove"; }; // This handler is invoked after a successful drop occurs list.ondragend = function(e) { e = e || window.event; var target = e.target || e.srcElement; // If the drop was a move, then delete the list item. // In IE8, this will be "none" unless you explicitly set it to // move in the ondrop handler above. But forcing it to "move" for // IE prevents other browsers from giving the user a choice of a // copy or move operation. if (e.dataTransfer.dropEffect === "move") target.parentNode.removeChild(target); } // This is the utility function we used in ondragenter and ondragleave. // Return true if a is a child of b. function ischild(a,b) { for(; a; a = a.parentNode) if (a === b) return true; return false; } } });

Text Events

Browsers have three legacy events for keyboard input. The keydown and keyup events are low-level events that are covered in the next section. The keypress event, however, is a higher-level event that signals that a printable character has been generated. The DOM Level 3 Events draft specification defines a more general textinput event triggered whenever the user inputs text regardless of the source (a keyboard, data transfer in the form of a paste or a drop, an Asian-language input method, or a voice or handwriting recognition system, for example). The textinput event is not supported at the time of this writing, but Webkit browsers support a very similar「textInput」(with a capital letter I) event.

The proposed textinput event and the currently implemented textInput event are passed a simple event object with a data property that holds the input text. (Another property, inputMethod, is proposed to specify the source of the input, but it has not yet been implemented.) For keyboard input, the data property will usually hold only a single character, but input from other sources may often include multiple characters.

The event object passed with keypress events is more confusing. A keypress event represents a single character of input. The event object specifies that character as a numeric Unicode codepoint, and you must use String.fromCharCode() to convert it to a string. In most browsers, the keyCode property of the event object specifies the codepoint of the input character. For historical reasons, however, Firefox uses the charCode property instead. Most browser only fire keypress events when a printable character is generated. Firefox, however, also fires「keypress」for nonprinting characters. To detect this case (so you can ignore the nonprinting characters), you can look for an event object with a charCode property that is defined but set to 0.

The textinput, textInput, and keypress events can be canceled to prevent the character from being input. This means you can use these events to filter input. You might want to prevent a user from entering letters into a field intended for numeric data, for example. Example 17-6 is an unobtrusive module of JavaScript code that allows exactly this sort of filtering. It looks for <input type=text> elements that have an additional (nonstandard) attribute named data-allowed-chars. The module registers handlers for textinput, textInput, and keypress events on any such text field to restrict input to characters that appear in the value of the allowed attribute. The initial comment at the top of Example 17-6 includes some sample HTML that uses the module.

Example 17-6. Filtering user input

/** * InputFilter.js: unobtrusive filtering of keystrokes for <input> elements * * This module finds all <input type="text"> elements in the document that * have an "data-allowed-chars" attribute. It registers keypress, textInput, and * textinput event handlers for any such element to restrict the user's input * so that only characters that appear in the value of the attribute may be * entered. If the <input> element also has an attribute named "data-messageid", * the value of that attribute is taken to be the id of another document * element. If the user types a character that is not allowed, the message * element is made visible. If the user types a character that is allowed, the * message element is hidden. This message id element is intended to offer * an explanation to the user of why her keystroke was rejected. It should * typically be styled with CSS so that it is initially invisible. * * Here is sample HTML that uses this module. * Zipcode: <input id="zip" type="text" * data-allowed-chars="0123456789" data-messageid="zipwarn"> * <span id="zipwarn" style="color:red;visibility:hidden">Digits only</span> * * This module is purely unobtrusive: it does not define any symbols in * the global namespace. */ whenReady(function () { // Run this function when the document is loaded // Find all <input> elements var inputelts = document.getElementsByTagName("input"); // Loop through them all for(var i = 0 ; i < inputelts.length; i++) { var elt = inputelts[i]; // Skip those that aren't text fields or that don't have // a data-allowed-chars attribute. if (elt.type != "text" || !elt.getAttribute("data-allowed-chars")) continue; // Register our event handler function on this input element // keypress is a legacy event handler that works everywhere. // textInput (mixed-case) is supported by Safari and Chrome in 2010. // textinput (lowercase) is the version in the DOM Level 3 Events draft. if (elt.addEventListener) { elt.addEventListener("keypress", filter, false); elt.addEventListener("textInput", filter, false); elt.addEventListener("textinput", filter, false); } else { // textinput not supported versions of IE w/o addEventListener() elt.attachEvent("onkeypress", filter); } } // This is the keypress and textInput handler that filters the user's input function filter(event) { // Get the event object and the target element target var e = event || window.event; // Standard or IE model var target = e.target || e.srcElement; // Standard or IE model var text = null; // The text that was entered // Get the character or text that was entered if (e.type === "textinput" || e.type === "textInput") text = e.data; else { // This was a legacy keypress event // Firefox uses charCode for printable key press events var code = e.charCode || e.keyCode; // If this keystroke is a function key of any kind, do not filter it if (code < 32 || // ASCII control character e.charCode == 0 || // Function key (Firefox only) e.ctrlKey || e.altKey) // Modifier key held down return; // Don't filter this event // Convert character code into a string var text = String.fromCharCode(code); } // Now look up information we need from this input element var allowed = target.getAttribute("data-allowed-chars"); // Legal chars var messageid = target.getAttribute("data-messageid"); // Message id if (messageid) // If there is a message id, get the element var messageElement = document.getElementById(messageid); // Loop through the characters of the input text for(var i = 0; i < text.length; i++) { var c = text.charAt(i); if (allowed.indexOf(c) == -1) { // Is this a disallowed character? // Display the message element, if there is one if (messageElement) messageElement.style.visibility = "visible"; // Cancel the default action so the text isn't inserted if (e.preventDefault) e.preventDefault(); if (e.returnValue) e.returnValue = false; return false; } } // If all the characters were legal, hide the message if there is one. if (messageElement) messageElement.style.visibility = "hidden"; } });

The keypress and textinput events are triggered before the newly input text is actually inserted into the focused document element, which is why handlers for these events can cancel the event and prevent the insertion of the text. Browsers also implement an input event type that is fired after text is inserted into an element. These events cannot be canceled, and they do not specify what the new text was in their event object, but they do provide notification that the textual content of an element has changed in some way. If you wanted to ensure that any text entered into an input field was in uppercase, for example, you might use the input event like this:

SURNAME: <input type="text" oninput="this.value = this.value.toUpperCase();">

HTML 5 standardizes the input event and it is supported by all modern browsers except IE. You can achieve a similar effect in IE by using the nonstandard propertychange event to detect changes to the value property of a text input element. Example 17-7 shows how you might force all input to uppercase in a cross-platform way.

Example 17-7. Using the propertychange event to detect text input

function forceToUpperCase(element) { if (typeof element === "string") element = document.getElementById(element); element.oninput = upcase; element.onpropertychange = upcaseOnPropertyChange; // Easy case: the handler for the input event function upcase(event) { this.value = this.value.toUpperCase(); } // Hard case: the handler for the propertychange event function upcaseOnPropertyChange(event) { var e = event || window.event; // If the value property changed if (e.propertyName === "value") { // Remove onpropertychange handler to avoid recursion this.onpropertychange = null; // Change the value to all uppercase this.value = this.value.toUpperCase(); // And restore the original propertychange handler this.onpropertychange = upcaseOnPropertyChange; } } }

Keyboard Events

The keydown and keyup events are fired when the user presses or releases a key on the keyboard. They are generated for modifier keys, function keys, and alphanumeric keys. If the user holds the key down long enough for it to begin repeating, there will be multiple keydown events before the keyup event arrives.

The event object associated with these events has a numeric keyCode property that specifies which key was pressed. For keys that generate printable characters, the keyCode is generally the Unicode encoding of the primary character that appears on the key. Letter keys always generate uppercase keyCode values, regardless of the state of the Shift key since that is what appears on the physical key. Similarly, number keys always generate keyCode values for the digit that appears on the key, even if you are holding down Shift in order to type a punctuation character. For nonprinting keys, the keyCode property will be some other value. These keyCode values have never been standardized, but reasonable cross-browser compatibility is possible, and Example 17-8 includes a mapping from keyCode values to function key names.

Like mouse event objects, key event objects have altKey, ctrlKey, metaKey, and shiftKey properties, which are set to true if the corresponding modifier key is held down when the event occurs.

The keydown and keyup events and the keyCode property have been in use for more than a decade but have never been standardized. The DOM Level 3 Events draft standard does standardize the keydown and keyup event types, but it does not attempt to standardize keyCode. Instead, it defines a new key property that contains the key name as a string. If the key corresponds to a printable character, the key property will just be that printable character. If the key is a function key, the key property will be a value like「F2」,「Home」, or「Left」.

The DOM Level 3 key property is not yet implemented in any browsers at the time of this writing. The Webkit-based browsers Safari and Chrome define a keyIdentifier property in the event object for these events, however. Like key, keyIdentifier is a string rather than a number and it has useful values like「Shift」and「Enter」for function keys. For printing keys, this property holds a less useful string representation of the Unicode encoding of the character. It is「U+0041」for the A key, for example.

Example 17-8 defines a Keymap class that maps keystroke identifiers such as「PageUp」,「Alt_Z」, and「ctrl+alt+shift+F5」to JavaScript functions that are invoked in response to those keystrokes. Pass key bindings to the Keymap() constructor in the form of a JavaScript object in which property names are keystroke identifiers and property values are handler functions. Add and remove bindings with the bind() and unbind() methods. Install a Keymap on an HTML element (often the Document object) with the install() method. Installing a keymap on an element registers a keydown event handler on that element. Each time a key is pressed, the handler checks to see if there is a function associated with that keystroke. If there is, it invokes it. The keydown handler uses the DOM Level 3 key property, if it is defined. If not, it looks for the Webkit keyIdentifier property and uses that. Otherwise, it falls back on the nonstandard keyCode property. Example 17-8 begins with a long comment that explains the module in more detail.

Example 17-8. A Keymap class for keyboard shortcuts

/* * Keymap.js: bind key events to handler functions. * * This module defines a Keymap class. An instance of this class represents a * mapping of key identifiers (defined below) to handler functions. A Keymap * can be installed on an HTML element to handle keydown events. When such an * event occurs, the Keymap uses its mapping to invoke the appropriate handler. * * When you create a Keymap, you can pass a JavaScript object that represents * the initial set of bindings for the Keymap. The property names of this object * are key identifers, and the property values are the handler functions. * After a Keymap has been created, you can add new bindings by passing a key * identifer and handler function to the bind() method. You can remove a * binding by passing a key identifier to the unbind() method. * * To make use of a Keymap, call its install() method, passing an HTML element, * such as the document object. install() adds an onkeydown event handler to * the specified object. When this handler is invoked, it determines the key * identifier of the pressed key and invokes the handler function, if any, * bound to that key identifier. A single Keymap may be installed on more than * one HTML element. * * Key Identifiers * * A key identifier is a case-insensitive string representation of a key plus * any modifier keys that are held down at the same time. The key name is * usually the (unshifted) text on the key. Legal key names include "A", "7", * "F2", "PageUp", "Left", "Backspace", and "Esc". * * See the Keymap.keyCodeToKeyName object in this module for a list of names. * These are a subset of the names defined by the DOM Level 3 standard and * this class will use the key property of the event object when implemented. * * A key identifier may also include modifier key prefixes. These prefixes are * Alt, Ctrl, Meta, and Shift. They are case-insensitive, and must be separated * from the key name and from each other with spaces or with an underscore, * hyphen, or +. For example: "SHIFT+A", "Alt_F2", "meta-v", and "ctrl alt left". * On Macs, Meta is the Command key and Alt is the Option key. Some browsers * map the Windows key to the Meta modifier. * * Handler Functions * * Handlers are invoked as methods of the document or document element on which * the keymap is installed and are passed two arguments: * 1) the event object for the keydown event * 2) the key identifier of the key that was pressed * The handler return value becomes the return value of the keydown handler. * If a handler function returns false, the keymap will stop bubbling and * cancel any default action associated with the keydown event. * * Limitations * * It is not possible to bind a handler function to all keys. The operating * system traps some key sequences (Alt-F4, for example). And the browser * itself may trap others (Ctrl-S, for example). This code is browser, OS, * and locale-dependent. Function keys and modified function keys work well, * and unmodified alphanumeric keys work well. The combination of Ctrl and Alt * with alphanumeric characters is less robust. * * Most punctuation characters that do not require the Shift key (`=[];',./\ * but not hyphen) on standard US keyboard layouts are supported. But they are * not particularly portable to other keyboard layouts and should be avoided. */ // This is the constructor function function Keymap(bindings) { this.map = {}; // Define the key identifier->handler map if (bindings) { // Copy initial bindings into it for(name in bindings) this.bind(name, bindings[name]); } } // Bind the specified key identifier to the specified handler function Keymap.prototype.bind = function(key, func) { this.map[Keymap.normalize(key)] = func; }; // Delete the binding for the specified key identifier Keymap.prototype.unbind = function(key) { delete this.map[Keymap.normalize(key)]; }; // Install this Keymap on the specified HTML element Keymap.prototype.install = function(element) { // This is the event-handler function var keymap = this; function handler(event) { return keymap.dispatch(event, element); } // Now install it if (element.addEventListener) element.addEventListener("keydown", handler, false); else if (element.attachEvent) element.attachEvent("onkeydown", handler); }; // This method dispatches key events based on the keymap bindings. Keymap.prototype.dispatch = function(event, element) { // We start off with no modifiers and no key name var modifiers = "" var keyname = null; // Build the modifier string in canonical lowercase alphabetical order. if (event.altKey) modifiers += "alt_"; if (event.ctrlKey) modifiers += "ctrl_"; if (event.metaKey) modifiers += "meta_"; if (event.shiftKey) modifiers += "shift_"; // The keyname is easy if the DOM Level 3 key property is implemented: if (event.key) keyname = event.key; // Use the keyIdentifier on Safari and Chrome for function key names else if (event.keyIdentifier && event.keyIdentifier.substring(0,2) !== "U+") keyname = event.keyIdentifier; // Otherwise, use the keyCode property and the code-to-name map below else keyname = Keymap.keyCodeToKeyName[event.keyCode]; // If we couldn't figure out a key name, just return and ignore the event. if (!keyname) return; // The canonical key id is modifiers plus lowercase key name var keyid = modifiers + keyname.toLowerCase(); // Now see if the key identifier is bound to anything var handler = this.map[keyid]; if (handler) { // If there is a handler for this key, handle it // Invoke the handler function var retval = handler.call(element, event, keyid); // If the handler returns false, cancel default and prevent bubbling if (retval === false) { if (event.stopPropagation) event.stopPropagation(); // DOM model else event.cancelBubble = true; // IE model if (event.preventDefault) event.preventDefault(); // DOM else event.returnValue = false; // IE } // Return whatever the handler returned return retval; } }; // Utility function to convert a key identifier to canonical form. // On non-Macintosh hardware, we could map "meta" to "ctrl" here, so that // Meta-C would be "Command-C" on the Mac and "Ctrl-C" everywhere else. Keymap.normalize = function(keyid) { keyid = keyid.toLowerCase(); // Everything lowercase var words = keyid.split(/\s+|[\-+_]/); // Split modifiers from name var keyname = words.pop(); // keyname is the last word keyname = Keymap.aliases[keyname] || keyname; // Is it an alias? words.sort(); // Sort remaining modifiers words.push(keyname); // Add the normalized name back return words.join("_"); // Concatenate them all }; Keymap.aliases = { // Map common key aliases to their "official" "escape":"esc", // key names used by DOM Level 3 and by "delete":"del", // the key code to key name map below. "return":"enter", // Both keys and values must be lowercase here. "ctrl":"control", "space":"spacebar", "ins":"insert" }; // The legacy keyCode property of the keydown event object is not standardized // But the following values seem to work for most browsers and OSes. Keymap.keyCodeToKeyName = { // Keys with words or arrows on them 8:"Backspace", 9:"Tab", 13:"Enter", 16:"Shift", 17:"Control", 18:"Alt", 19:"Pause", 20:"CapsLock", 27:"Esc", 32:"Spacebar", 33:"PageUp", 34:"PageDown", 35:"End", 36:"Home", 37:"Left", 38:"Up", 39:"Right", 40:"Down", 45:"Insert", 46:"Del", // Number keys on main keyboard (not keypad) 48:"0",49:"1",50:"2",51:"3",52:"4",53:"5",54:"6",55:"7",56:"8",57:"9", // Letter keys. Note that we don't distinguish upper and lower case 65:"A", 66:"B", 67:"C", 68:"D", 69:"E", 70:"F", 71:"G", 72:"H", 73:"I", 74:"J", 75:"K", 76:"L", 77:"M", 78:"N", 79:"O", 80:"P", 81:"Q", 82:"R", 83:"S", 84:"T", 85:"U", 86:"V", 87:"W", 88:"X", 89:"Y", 90:"Z", // Keypad numbers and punctuation keys. (Opera does not support these.) 96:"0",97:"1",98:"2",99:"3",100:"4",101:"5",102:"6",103:"7",104:"8",105:"9", 106:"Multiply", 107:"Add", 109:"Subtract", 110:"Decimal", 111:"Divide", // Function keys 112:"F1", 113:"F2", 114:"F3", 115:"F4", 116:"F5", 117:"F6", 118:"F7", 119:"F8", 120:"F9", 121:"F10", 122:"F11", 123:"F12", 124:"F13", 125:"F14", 126:"F15", 127:"F16", 128:"F17", 129:"F18", 130:"F19", 131:"F20", 132:"F21", 133:"F22", 134:"F23", 135:"F24", // Punctuation keys that don't require holding down Shift // Hyphen is nonportable: FF returns same code as Subtract 59:";", 61:"=", 186:";", 187:"=", // Firefox and Opera return 59,61 188:",", 190:".", 191:"/", 192:"`", 219:"[", 220:"\\", 221:"]", 222:"'" };

Chapter 18. Scripted HTTP

The Hypertext Transfer Protocol (HTTP) specifies how web browsers get documents from and post form contents to web servers, and how web servers respond to those requests and posts. Web browsers obviously handle a lot of HTTP. Usually HTTP is not under the control of scripts and instead occurs when the user clicks on a link, submits a form, or types a URL.

It is possible for JavaScript code to script HTTP, however. HTTP requests are initiated when a script sets the location property of a window object or calls the submit() method of a form object. In both cases, the browser loads a new page. This kind of trivial HTTP scripting can be useful in a multiframed web page but is not the topic we’ll cover here. Instead, this chapter explains how scripts can communicate with a web server without causing the web browser to reload the content of any window or frame.

The term Ajax describes an architecture for web applications that prominently features scripted HTTP.[43] The key feature of an Ajax application is that it uses scripted HTTP to initiate data exchange with a web server without causing pages to reload. The ability to avoid page reloads (which were the norm in the early days of the Web) results in responsive web applications that feel more like traditional desktop applications. A web application might use Ajax technologies to log user interaction data to the server or to improve its start-up time by displaying only a simple page at first and then downloading additional data and page components on an as-needed basis.

The term Comet refers to a related web application architecture that uses scripted HTTP.[44] In a sense, Comet is the reverse of Ajax: in Comet, it is the web server that initiates the communication, asynchronously sending messages to the client. If the web application needs to respond to these messages sent by the server, it can then use Ajax techniques to send or request data. In Ajax, the client「pulls」data from the server. With Comet, the server「pushes」data to the client. Other names for Comet include「Server Push,」「Ajax Push,」and「HTTP Streaming.」

There are a number of ways to implement Ajax and Comet, and these underlying implementations are sometimes known as transports. The <img> element, for example, has a src property. When a script sets this property to a URL, an HTTP GET request is initiated to download an image from that URL. A script can therefore pass information to a web server by encoding that information into the query-string portion of the URL of an image and setting the src property of an <img> element. The web server must actually return some image as the result of this request, but it can be invisible: a transparent 1-pixel-by-1-pixel image, for instance.[45]

An <img> element does not make a good Ajax transport, because the data exchange is one-way: the client can send data to the server, but the server’s response will always be an image that the client can’t easily extract information from. The <iframe> element is more versatile, however. To use an <iframe> as an Ajax transport, the script first encodes information for the web server into a URL and then sets the src property of the <iframe> to that URL. The server creates an HTML document containing its response and sends it back to the web browser, which displays it in the <iframe>. The <iframe> need not be visible to the user; it can be hidden with CSS, for example. A script can access the server’s response by traversing the document object of the <iframe>. Note, though, that this traversal is subject to the constraints of the same-origin policy described in The Same-Origin Policy.

Even the <script> element has a src property that can be set to initiate an HTTP GET request. Doing HTTP scripting with <script> elements is particularly attractive because they are not subject to the same-origin policy and can be used for cross-domain communication. Usually, with a <script>-based Ajax transport, the server’s response takes the form of JSON-encoded (see Serializing Objects) data that is automatically「decoded」when the script is executed by the JavaScript interpreter. Because of its use of the JSON data format, this Ajax transport is known as「JSONP.」

Although Ajax techniques can be implemented on top of an <iframe> or <script> transport, there is usually an easier way to do it. For some time, all browsers have supported an XMLHttpRequest object that defines an API for scripted HTTP. The API includes the ability to make POST requests, in addition to regular GET requests, and can return the server’s response as text or as a Document object. Despite its name, the XMLHttpRequest API is not limited to use with XML documents: it can fetch any kind of text document. Using XMLHttpRequest covers the XMLHttpRequest API and takes up most of the chapter. Most of the Ajax examples in this chapter will use the XMLHttpRequest object as their transport, but we’ll also demonstrate how to use the <script>-based transport in HTTP by <script>: JSONP because of the <script> element’s ability to circumvent same-origin restrictions.

The XML Is Optional

The X in「Ajax」stands for XML, the primary client-side API for HTTP (XMLHttpRequest) features XML in its name, and we’ll see later that one of the properties of the XMLHttpRequest object is named responseXML. It would seem that XML is an important part of scripted HTTP. But it’s not: these names are the historical legacy of the days when XML was a powerful buzzword. Ajax techniques work with XML documents, of course, but the use of XML is purely optional and has actually become relatively rare. The XMLHttpRequest specification lays out the inadequacies of the name we’re stuck with:

The name of the object is XMLHttpRequest for compatibility with the Web, though each component of this name is potentially misleading. First, the object supports any text based format, including XML. Second, it can be used to make requests over both HTTP and HTTPS (some implementations support protocols in addition to HTTP and HTTPS, but that functionality is not covered by this specification). Finally, it supports「requests」in a broad sense of the term as it pertains to HTTP; namely all activity involved with HTTP requests or responses for the defined HTTP methods.

Transport mechanisms for Comet are trickier than Ajax, but all require the client to establish (and re-establish as necessary) a connection to the server, and require the server to keep that connection open so that it can send asynchronous messages over it. A hidden <iframe> can serve as a Comet transport, for example, if the server sends each message in the form of a <script> element to be executed in the <iframe>. A more reliably cross-platform approach to implementing Comet is for the client to establish a connection to the server (using an Ajax transport) and for the server to keep this connection open until it needs to push a message. Each time the server sends a message, it closes the connection, which helps to ensure that the message is properly received by the client. After processing the message, the client then immediately establishes a new connection for future messages.

Implementing a reliable cross-platform Comet transport is hard to do, and most web app developers who use the Comet architecture rely on the transports in web framework libraries such as Dojo. At the time of this writing, browsers are beginning to implement an HTML5-related draft specification known as Server-Sent Events that defines a simple Comet API in the form of an EventSource object. Comet with Server-Sent Events covers the EventSource API and demonstrates a simple emulation of it using XMLHttpRequest.

It is possible to build higher-level communication protocols on top of Ajax and Comet. These client/server communication techniques can be used as the basis of an RPC (remote procedure call) mechanism or a publish/subscribe event system, for example. This chapter does not describe higher-level protocols like this, however, and instead focuses on the APIs that enable Ajax and Comet.

Using XMLHttpRequest

Browsers define their HTTP API on an XMLHttpRequest class. Each instance of this class represents a single request/response pair, and the properties and methods of the object allow you to specify request details and extract response data. XMLHttpRequest has been supported by web browsers for many years, and the API is in the final stages of standardization through the W3C. At the same time, the W3C is working on a draft「XMLHttpRequest Level 2」standard. This section covers the core XMLHttpRequest API and also those portions of the Level 2 draft (which I’ll call XHR2) that are currently implemented by at least two browsers.

The first thing you must do to use this HTTP API, of course, is to instantiate an XMLHttpRequest object:

var request = new XMLHttpRequest();

You can also reuse an existing XMLHttpRequest object, but note that doing so will abort any request pending through that object.

XMLHttpRequest in IE6

Microsoft introduced the XMLHttpRequest object to the world in IE5, and in IE5 and IE6 it is available only as an ActiveX object. The now-standard XMLHttpRequest() constructor is not supported before IE7, but it can be emulated like this:

// Emulate the XMLHttpRequest() constructor in IE5 and IE6 if (window.XMLHttpRequest === undefined) { window.XMLHttpRequest = function() { try { // Use the latest version of the ActiveX object if available return new ActiveXObject("Msxml2.XMLHTTP.6.0"); } catch (e1) { try { // Otherwise fall back on an older version return new ActiveXObject("Msxml2.XMLHTTP.3.0"); } catch(e2) { // Otherwise, throw an error throw new Error("XMLHttpRequest is not supported"); } } }; }

An HTTP request consists of four parts:

the HTTP request method or「verb」

the URL being requested

an optional set of request headers, which may include authentication information

an optional request body

The HTTP response sent by a server has three parts:

a numeric and textual status code that indicates the success or failure of the request

a set of response headers

the response body

The first two subsections below demonstrate how to set each of the parts of an HTTP request and how to query each of the parts of an HTTP response. Those key sections are followed by coverage of more specialized topics.

The basic request/response architecture of HTTP is pretty simple and easy to work with. In practice, however, there are all sorts of complications: clients and server exchange cookies, servers redirect browsers to other servers, some resources are cached and others are not, some clients send all their requests through proxy servers, and so on. XMLHttpRequest is not a protocol-level HTTP API but instead a browser-level API. The browser takes care of cookies, redirects, caching, and proxies and your code need worry only about requests and responses.

XMLHttpRequest and Local Files

The ability to use relative URLs in web pages usually means that we can develop and test our HTML using the local file system and then deploy it unchanged to a web server. This is generally not possible when doing Ajax programming with XMLHttpRequest, however. XMLHttpRequest is designed to work with the HTTP and HTTPS protocols. In theory, it could be made to work with other protocols, such as FTP, but parts of the API, such as the request method and the response status code, are HTTP-specific. If you load a web page from a local file, the scripts in that page will not be able to use XMLHttpRequest with relative URLs, since those URLs will be relative to a file:// URL rather than an http:// URL. And the same-origin policy will often prevent you from using absolute http:// URLs. (But see Cross-Origin HTTP Requests.) The upshot is that when working with XMLHttpRequest, you generally have to upload your files to a web server (or run a server locally) in order to test them.

Specifying the Request

After creating an XMLHttpRequest object, the next step in making an HTTP request is to call the open() method of your XMLHttpRequest object to specify the two required parts of the request, the method and the URL:

request.open("GET", // Begin a HTTP GET request "data.csv"); // For the contents of this URL

The first argument to open() specifies the HTTP method or verb. This is a case-insensitive string, but uppercase letters are typically used to match the HTTP protocol. The「GET」and「POST」methods are universally supported.「GET」is used for most「regular」requests, and it is appropriate when the URL completely specifies the requested resource, when the request has no side effects on the server, and when the server’s response is cacheable. The「POST」method is what is typically used by HTML forms. It includes additional data (the form data) in the request body and that data is often stored in a database on the server (a side effect). Repeated POSTs to the same URL may result in different responses from the server, and requests that use this method should not be cached.

In addition to「GET」and「POST」, the XMLHttpRequest specification also allows「DELETE」,「HEAD」,「OPTIONS」, and「PUT」as the first argument to open(). (The「HTTP CONNECT」,「TRACE」, and「TRACK」methods are explicitly forbidden as security risks.) Older browsers may not support all of these methods, but「HEAD」, at least, is widely supported and Example 18-13 demonstrates its use.

The second argument to open() is the URL that is the subject of the request. This is relative to the URL of the document that contains the script that is calling open(). If you specify an absolute URL, the protocol, host, and port must generally match those of the containing document: cross-origin HTTP requests normally cause an error. (But the XMLHttpRequest Level 2 specification allows cross-origin requests when the server explicitly allows it; see Cross-Origin HTTP Requests.)

The next step in the request process is to set the request headers, if any. POST requests, for example, need a「Content-Type」header to specify the MIME type of the request body:

request.setRequestHeader("Content-Type", "text/plain");

If you call setRequestHeader() multiple times for the same header, the new value does not replace the previously specified value: instead, the HTTP request will include multiple copies of the header or the header will specify multiple values.

You cannot specify the「Content-Length」,「Date」,「Referer」, or「User-Agent」headers yourself: XMLHttpRequest will add those automatically for you and will not allow you to spoof them. Similarly, XMLHttpRequest object automatically handles cookies, and connection lifetime, charset, and encoding negotiations, so you’re not allowed to pass any of these headers to setRequestHeader():

Accept-Charset Content-Transfer-Encoding TE Accept-Encoding Date Trailer Connection Expect Transfer-Encoding Content-Length Host Upgrade Cookie Keep-Alive User-Agent Cookie2 Referer Via

You can specify an「Authorization」header with your request, but you do not normally need to do so. If you are requesting a password-protected URL, pass the username and password as the fourth and fifth arguments to open(), and XMLHttpRequest will set appropriate headers for you. (We’ll learn about the optional third argument to open() below. The optional username and password arguments are described in the reference section.)

The final step in making an HTTP request with XMLHttpRequest is to specify the optional request body and send it off to the server. Do this with the send() method:

request.send(null);

GET requests never have a body, so you should pass null or omit the argument. POST requests do generally have a body, and it should match the「Content-Type」header you specified with setRequestHeader().

Order Matters

The parts of an HTTP request have a specific order: the request method and URL must come first, then the request headers, and finally the request body. XMLHttpRequest implementations generally do not initiate any networking until the send() method is called. But the XMLHttpRequest API is designed as if each method was writing to a network stream. This means that the XMLHttpRequest method must be called in an order that matches the structure of an HTTP request. setRequestHeader(), for example, must be called after you call open() and before you call send() or it will throw an exception.

Example 18-1 uses each of the XMLHttpRequest methods we’ve described so far. It POSTs a string of text to a server and ignores any response the server sends.

Example 18-1. POSTing plain text to a server

function postMessage(msg) { var request = new XMLHttpRequest(); // New request request.open("POST", "/log.php"); // POST to a server-side script // Send the message, in plain-text, as the request body request.setRequestHeader("Content-Type", // Request body will be plain text "text/plain;charset=UTF-8"); request.send(msg); // Send msg as the request body // The request is done. We ignore any response or any error. }

Note that the send() method in Example 18-1 initiates the request and then returns: it does not block while waiting for the server’s response. HTTP responses are almost always handled asynchronously, as demonstrated in the following section.

Retrieving the Response

A complete HTTP response consists of a status code, a set of response headers, and a response body. These are available through properties and methods of the XMLHttpRequest object:

The status and statusText properties return the HTTP status in numeric and textual forms. These properties hold standard HTTP values like 200 and「OK」for successful requests and 404 and「Not Found」for URLs that don’t match any resource on the server.

The response headers can be queried with getResponseHeader() and getAll Response Headers(). XMLHttpRequest handles cookies automatically: it filters cookie headers out of the set returned by getAllResponseHeaders() and returns null if you pass「Set-Cookie」or「Set-Cookie2」to getResponseHeader().

The response body is available in textual form from the responseText property or in Document form from the responseXML property. (The name of that property is historical: it actually works for XHTML documents as well as XML documents, and XHR2 says that it should work for ordinary HTML documents as well.) See Decoding the response for more on responseXML.

The XMLHttpRequest object is usually (but see Synchronous responses) used asynchronously: the send() method returns immediately after sending the request, and the response methods and properties listed above aren’t valid until the response is received. To be notified when the response is ready, you must listen for readystatechange events (or the new XHR2 progress events described in HTTP Progress Events) on the XMLHttpRequest object. But to understand this event type, you must first understand the readyState property.

readyState is an integer that specifies the status of an HTTP request, and its possible values are enumerated in Table 18-1. The symbols in the first column are constants defined on the XMLHttpRequest constructor. These constants are part of the XMLHttpRequest specification, but older browsers and IE8 do not define them, and you’ll often see code that hardcodes the value 4 instead of XMLHttpRequest.DONE.

Table 18-1. XMLHttpRequest readyState values

ConstantValueMeaning

UNSENT 0 open() has not been called yet

OPENED 1 open() has been called

HEADERS_RECEIVED 2 Headers have been received

LOADING 3 The response body is being received

DONE 4 The response is complete

In theory, the readystatechange event is triggered every time the readyState property changes. In practice, the event may not be fired when readyState changes to 0 or 1. It is often fired when send() is called, even though readyState remains at OPENED when that happens. Some browsers fire the event multiple times during the LOADING state to give progress feedback. All browsers do fire the readystatechange event when readyState has changed to the value 4 and the server’s response is complete. Because the event is also fired before the response is complete, however, event handlers should always test the readyState value.

To listen for readystatechange events, set the onreadystatechange property of the XMLHttpRequest object to your event handler function. You can also use addEvent Listener() (or attachEvent() in IE8 and before), but you generally need only one handler per request and it is easier to simply set onreadystatechange.

Example 18-2 defines a getText() function that demonstrates how to listen for readystatechange events. The event handler first ensures that the request is complete. If so, it checks the response status code to ensure that the request was successful. Then it looks at the「Content-Type」header to verify that the response was of the expected type. If all three conditions are satisfied, it passes the response body (as text) to a specified callback function.

Example 18-2. Getting an HTTP response onreadystatechange

// Issue an HTTP GET request for the contents of the specified URL. // When the response arrives successfully, verify that it is plain text // and if so, pass it to the specified callback function function getText(url, callback) { var request = new XMLHttpRequest(); // Create new request request.open("GET", url); // Specify URL to fetch request.onreadystatechange = function() { // Define event listener // If the request is compete and was successful if (request.readyState === 4 && request.status === 200) { var type = request.getResponseHeader("Content-Type"); if (type.match(/^text/)) // Make sure response is text callback(request.responseText); // Pass it to callback } }; request.send(null); // Send the request now }

Synchronous responses

By their very nature, HTTP responses are best handled asynchronously. Nevertheless, XMLHttpRequest also supports synchronous responses. If you pass false as the third argument to open(), the send() method will block until the request completes. In this case, there is no need to use an event handler: once send() returns, you can just check the status and responseText properties of the XMLHttpRequest object. Compare this synchronous code to the getText() function in Example 18-2:

// Issue a synchronous HTTP GET request for the contents of the specified URL. // Return the response text or throw an error if the request was not successful // or if the response was not text. function getTextSync(url) { var request = new XMLHttpRequest(); // Create new request request.open("GET", url, false); // Pass false for synchronous request.send(null); // Send the request now // Throw an error if the request was not 200 OK if (request.status !== 200) throw new Error(request.statusText); // Throw an error if the type was wrong var type = request.getResponseHeader("Content-Type"); if (!type.match(/^text/)) throw new Error("Expected textual response; got: " + type); return request.responseText; }

Synchronous requests are tempting, but they should be avoided. Client-side JavaScript is single-threaded and when the send() method blocks, it typically freezes the entire browser UI. If the server you are connecting to is responding slowly, your user’s browser will freeze up. See Web Workers for one context in which it is acceptable to make synchronous requests, however.

Decoding the response

In the examples above, we assume that the server has sent a textual response, with a MIME type like「text/plain」,「text/html」, or「text/css」, and we retrieve it with the responseText property of the XMLHttpRequest object.

There are other ways to handle the server’s response, however. If the server sends an XML or XHTML document as its response, you can retrieve a parsed representation of the XML document through the responseXML property. The value of this property is a Document object, and you can search and traverse it using the techniques shown in Chapter 15. (The XHR2 draft specification says that browsers should also automatically parse responses of type「text/html」and make them available as Document objects through responseXML as well, but browsers current at the time of this writing do not do that.)

If the server wants to send structured data, such as an object or array, as its response, it might transmit that data as a JSON-encoded (Serializing Objects) string. When you receive it, you would then pass the responseText property to JSON.parse(). Example 18-3 is a generalization of Example 18-2: it makes a GET request for the specified URL and passes the contents of that URL to the specified callback function when they are ready. But instead of always passing text, it passes a Document, or an object decoded with JSON.parse(), or a string.

Example 18-3. Parsing the HTTP response

// Issue an HTTP GET request for the contents of the specified URL. // When the response arrives, pass it to the callback function as a // parsed XML Document object, a JSON-parsed object, or a string. function get(url, callback) { var request = new XMLHttpRequest(); // Create new request request.open("GET", url); // Specify URL to fetch request.onreadystatechange = function() { // Define event listener // If the request is compete and was successful if (request.readyState === 4 && request.status === 200) { // Get the type of the response var type = request.getResponseHeader("Content-Type"); // Check type so we don't get HTML documents in the future if (type.indexOf("xml") !== -1 && request.responseXML) callback(request.responseXML); // Document response else if (type === "application/json") callback(JSON.parse(request.responseText)); // JSON response else callback(request.responseText); // String response } }; request.send(null); // Send the request now }

Example 18-3 checks the「Content-Type」header of the response and handles「application/json」responses specially. Another response type that you might want to「decode」specially is「application/javascript」or「text/javascript」. You can use an XMLHttpRequest to request a JavaScript script, and then use a global eval() (Global eval()) to execute that script. Using an XMLHttpRequest object is unnecessary in this case, however, since the HTTP scripting capabilities of the <script> element itself are sufficient to download and execute a script. See Example 13-4, and keep in mind that the <script> element can make cross-origin HTTP requests that are prohibited to the XMLHttpRequest API.

Web servers often respond to HTTP requests with binary data (image files, for example). The responseText property is for text only, and it cannot properly handle binary responses, even if you use the charCodeAt() method of the resulting string. XHR2 defines a way to handle binary responses, but at the time of this writing, browser vendors have not implemented it. See Downloading Blobs for further details.

Proper decoding of a server’s response assumes that the server sends a「Content-Type」header with the correct MIME type for the response. If a server sends an XML document without setting the appropriate MIME type, for example, the XMLHttpRequest object will not parse it and set the responseXML property. Or if a server includes an incorrect「charset」parameter in the content-type header, the XMLHttpRequest will decode the response using the wrong encoding and the characters in responseText may be wrong. XHR2 defines an overrideMimeType() method to address this problem and a number of browsers have already implemented it. If you know the MIME type of a resource better than the server does, pass the type of overrideMimeType() before you call send()—this will make XMLHttpRequest ignore the content-type header and use the type you specify instead. Suppose you’re downloading an XML file that you’re planning to treat as plain text. You can use setOverrideMimeType() to let the XMLHttpRequest know that it does not need to parse the file into an XML document:

// Don't process the response as an XML document request.overrideMimeType("text/plain; charset=utf-8")

Encoding the Request Body

HTTP POST requests include a request body that contains data the client is passing to the server. In Example 18-1, the request body was simply a string of text. Often, however, we want to send more complicated data along with an HTTP request. This section demonstrates a number of ways to do that.

Form-encoded requests

Consider HTML forms. When the user submits a form, the data in the form (the names and values of each of the form elements) is encoded into a string and sent along with the request. By default, HTML forms are POSTed to the server, and the encoded form data is used as the body of the request. The encoding scheme used for form data is relatively simple: perform normal URI encoding (replacing special characters with hexadecimal escape codes) on the name and value of each form element, separate the encoded name and value with an equals sign, and separate these name/value pairs with ampersands. The encoding of a simple form might look like this:

find=pizza&zipcode=02134&radius=1km

This form data encoding format has a formal MIME type:

application/x-www-form-urlencoded

You must set the「Content-Type」request header to this value when POSTing form data of this sort.

Note that this kind of encoding does not require an HTML form, and we won’t actually work directly with forms in this chapter. In Ajax applications, you are likely to have a JavaScript object that you want to send to the server. (That object may be derived from the user input in an HTML form, but that does not matter here.) The data shown above might be the form-encoded representation of this JavaScript object:

{ find: "pizza", zipcode: 02134, radius: "1km" }

Form encoding is so widely used on the Web, and so well supported in all server-side programming languages, that form-encoding your nonform data is often the easiest thing to do. Example 18-4 demonstrates how to form-encode the properties of an object.

Example 18-4. Encoding an object for an HTTP request

/** * Encode the properties of an object as if they were name/value pairs from * an HTML form, using application/x-www-form-urlencoded format */ function encodeFormData(data) { if (!data) return ""; // Always return a string var pairs = []; // To hold name=value pairs for(var name in data) { // For each name if (!data.hasOwnProperty(name)) continue; // Skip inherited if (typeof data[name] === "function") continue; // Skip methods var value = data[name].toString(); // Value as string name = encodeURIComponent(name.replace(" ", "+")); // Encode name value = encodeURIComponent(value.replace(" ", "+")); // Encode value pairs.push(name + "=" + value); // Remember name=value pair } return pairs.join('&'); // Return joined pairs separated with & }

With this encodeFormData() function defined, we can easily write utilities like the postData() function of Example 18-5. Note that, for simplicity, this postData() function (and similar functions in the examples that follow) does not process the server’s response. When the response is complete, it passes the entire XMLHttpRequest object to the specified callback function. That callback is responsible for checking the response status code and extracting the response text.

Example 18-5. Making an HTTP POST request with form-encoded data

function postData(url, data, callback) { var request = new XMLHttpRequest(); request.open("POST", url); // POST to the specified url request.onreadystatechange = function() { // Simple event handler if (request.readyState === 4 && callback) // When response is complete callback(request); // call the callback. }; request.setRequestHeader("Content-Type", // Set Content-Type "application/x-www-form-urlencoded"); request.send(encodeFormData(data)); // Send form-encoded data }

HTML forms generate POST requests by default, but they can also make GET requests. (When the purpose of the form submission is to make a read-only query, GET is more appropriate than POST.) GET requests never have a body, so the「payload」of form-encoded data has to be sent to the server as the query portion of the URL (following a question mark). The encodeFormData() utility can also be useful for this kind of GET request, and Example 18-6 demonstrates how to use it.

Example 18-6. Making a GET request with form-encoded data

function getData(url, data, callback) { var request = new XMLHttpRequest(); request.open("GET", url + // GET the specified url "?" + encodeFormData(data)); // with encoded data added request.onreadystatechange = function() { // Simple event handler if (request.readyState === 4 && callback) callback(request); }; request.send(null); // Send the request }

HTML forms use form-encoded query sections to encode data into a URL, but using XMLHttpRequest gives us the freedom to encode our data however we want. With appropriate support on the server, our pizza query data might be encoded into a more legible URL like this one:

http://restaurantfinder.example.com/02134/1km/pizza

JSON-encoded requests

The use of form encoding in the body of POST requests is a common convention, but it is not a requirement of the HTTP protocol by any means. In recent years, the JSON format has gained popularity as a web interchange format. Example 18-7 shows how you might encode a request body using JSON.stringify() (Serializing Objects). Note that this example differs from Example 18-5 only in the last two lines.

Example 18-7. Making an HTTP POST request with a JSON-encoded body

function postJSON(url, data, callback) { var request = new XMLHttpRequest(); request.open("POST", url); // POST to the specified url request.onreadystatechange = function() { // Simple event handler if (request.readyState === 4 && callback) // When response is complete callback(request); // call the callback. }; request.setRequestHeader("Content-Type", "application/json"); request.send(JSON.stringify(data)); }

XML-encoded requests

XML is sometimes also used as an encoding for data transfer. Instead of expressing our pizza query as a form-encoded or JSON-encoded version of a JavaScript object, we could represent it as an XML document. It might look like this, for example:

<query> <find zipcode="02134" radius="1km"> pizza </find> </query>

In all the examples we’ve shown so far, the argument to the XMLHttpRequest send() method has been a string or null. In fact, you can also pass an XML Document object here. Example 18-8 demonstrates how to create a simple XML Document object and use it as the body of an HTTP request.

Example 18-8. An HTTP POST request with an XML document as its body

// Encode what, where, and radius in an XML document and post them to the // specified url, invoking callback when the response is received function postQuery(url, what, where, radius, callback) { var request = new XMLHttpRequest(); request.open("POST", url); // POST to the specified url request.onreadystatechange = function() { // Simple event handler if (request.readyState === 4 && callback) callback(request); }; // Create an XML document with root element <query> var doc = document.implementation.createDocument("", "query", null); var query = doc.documentElement; // The <query> element var find = doc.createElement("find"); // Create a <find> element query.appendChild(find); // And add it to the <query> find.setAttribute("zipcode", where); // Set attributes on <find> find.setAttribute("radius", radius); find.appendChild(doc.createTextNode(what)); // And set content of <find> // Now send the XML-encoded data to the server. // Note that the Content-Type will be automatically set. request.send(doc); }

Note that Example 18-8 does not ever set the「Content-Type」header for the request. When you pass an XML document to the send() method, without previously specifying a Content-Type header, the XMLHttpRequest object automatically sets an appropriate header for you. (Similarly, if you pass a string to send() and have not specified a Content-Type, the XMLHttpRequest will add a「text/plain; charset=UTF-8」header for you. The code in Example 18-1 sets this header explicitly, but that is not actually required for plain-text request bodies.

Uploading a file

One of the features of HTML forms is that when the user selects a file through an <input type="file"> element, the form will send the content of that file in the body of the POST request it generates. HTML forms have always been able to upload files, but until recently it was not possible to do the same thing with the XMLHttpRequest API. The XHR2 API, however, allows you to upload files by passing a File object to the send() method.

There is no File() object constructor: scripts can only obtain File objects that represent files the user has selected. In browsers that support File objects, every <input type="file"> element has a files property that is an array-like object of File objects. The drag-and-drop API (Drag and Drop Events) also allows access to files that the user「drops」over an element, through the dataTransfer.files property of the drop event. We’ll see more about the File object in Blobs and The Filesystem API. For now, we can treat it as a completely opaque representation of a user-selected file, suitable for upload through send(). Example 18-9 is a an unobtrusive JavaScript function that adds an change event handler to certain file upload elements so that they automatically POST the contents of any selected file to a specified URL.

Example 18-9. File upload with an HTTP POST request

// Find all <input type="file"> elements with a data-uploadto attribute // and register an onchange handler so that any selected file is // automatically POSTED to the specified "uploadto" URL. The server's // response is ignored. whenReady(function() { // Run when the document is ready var elts = document.getElementsByTagName("input"); // All input elements for(var i = 0; i < elts.length; i++) { // Loop through them var input = elts[i]; if (input.type !== "file") continue; // Skip all but file upload elts var url = input.getAttribute("data-uploadto"); // Get upload URL if (!url) continue; // Skip any without a url input.addEventListener("change", function() { // When user selects file var file = this.files[0]; // Assume a single file selection if (!file) return; // If no file, do nothing var xhr = new XMLHttpRequest(); // Create a new request xhr.open("POST", url); // POST to the URL xhr.send(file); // Send the file as body }, false); } });

As we’ll see in Blobs, the File type is a subtype of the more general Blob type. XHR2 allows you to pass any Blob object to the send() method. The type property of the Blob will be used to set the Content-Type header for the upload, if you do not set that header explicitly yourself. If you need to upload binary data that you have generated, you can use the techniques shown in Typed Arrays and ArrayBuffers and Building Blobs to convert the data to a Blob and use it as a request body.

multipart/form-data requests

When HTML forms include file upload elements and other elements as well, the browser cannot use ordinary form encoding and must POST the form using a special content-type known as「multipart/form-data」. This encoding involves the use of long「boundary」strings to separate the body of the request into multiple parts. For textual data, it is possible to create「multipart/form-data」request bodies by hand, but it is tricky.

XHR2 defines a new FormData API that makes multipart request bodies simple. First, create a FormData object with the FormData() constructor and then call the append() method of that object as many times as necessary to add the individual「parts」(these can be strings or File or Blob objects) to the request. Finally, pass the FormData object to the send() method. The send() method will define an appropriate boundary string and set the「Content-Type」header for the request. Example 18-10 demonstrates the use of FormData, and we’ll see it again in Example 18-11.

Example 18-10. POSTing multipart/form-data request body

function postFormData(url, data, callback) { if (typeof FormData === "undefined") throw new Error("FormData is not implemented"); var request = new XMLHttpRequest(); // New HTTP request request.open("POST", url); // POST to the specified url request.onreadystatechange = function() { // A simple event handler. if (request.readyState === 4 && callback) // When response is complete callback(request); // ...call the callback. }; var formdata = new FormData(); for(var name in data) { if (!data.hasOwnProperty(name)) continue; // Skip inherited properties var value = data[name]; if (typeof value === "function") continue; // Skip methods // Each property becomes one "part" of the request. // File objects are allowed here formdata.append(name, value); // Add name/value as one part } // Send the name/value pairs in a multipart/form-data request body. Each // pair is one part of the request. Note that send automatically sets // the Content-Type header when you pass it a FormData object request.send(formdata); }

HTTP Progress Events

In the examples above, we’ve used the readystatechange event to detect the completion of an HTTP request. The XHR2 draft specification defines a more useful set of events and these have already been implemented by Firefox, Chrome, and Safari. In this new event model, the XMLHttpRequest object triggers different types of events at different phases of the request so that it is no longer necessary to check the readyState property.

In browsers that support them, these new events are triggered as follows. When the send() method is called, a single loadstart event is fired. While the server’s response is being downloaded, the XMLHttpRequest object fires progress events, typically every 50 milliseconds or so, and you can use these events to give the user feedback about the progress of the request. If a request completes very quickly, it may never fire a progress event. When a request is complete, a load event is fired.

A complete request is not necessarily a successful request, and your handler for the load event should check the status code of the XMLHttpRequest object to ensure that you received a HTTP「200 OK」response rather than a「404 Not Found」response, for example.

There are three ways that an HTTP request can fail to complete, and three corresponding events. If a request times out, the timeout event is triggered. If a request is aborted, the abort event is triggered. (Timeouts and the abort() method will be covered in Aborting Requests and Timeouts.) Finally, other network errors, such as too many redirects, can prevent the completion of a request, and the error event is triggered when this happens.

A browser will fire only one of the load, abort, timeout, or error events for any given request. The XHR2 draft says that browsers should trigger a loadend event once one of these events has occurred. At the time of this writing, however, browsers do not implement loadend.

You can call the addEventListener() method of the XMLHttpRequest object register handlers for each of these progress events. If you have only one handler for each kind of event, it is generally easier to just set the corresponding handler property, such as onprogress and onload. You can even use the existence of these event properties to test whether a browser supports progress events:

if ("onprogress" in (new XMLHttpRequest())) { // Progress events are supported }

The event object associated with these progress events has three useful properties in addition to the normal Event object properties like type and timestamp. The loaded property is the number of bytes that have been transferred so far. The total property is the total length (in bytes) of the data to be transferred, from the「Content-Length」header, or 0 if the content length is not known. Finally, the lengthComputable property is true if the content length is known and is false otherwise. Obviously, the total and loaded properties are particularly useful in progress event handlers:

request.onprogress = function(e) { if (e.lengthComputable) progress.innerHTML = Math.round(100*e.loaded/e.total) + "% Complete"; }

Upload progress events

In addition to defining these useful events for monitoring the download of an HTTP response, XHR2 also allows the events to be used to monitor the upload of an HTTP request. In browsers that have implemented this feature, the XMLHttpRequest object will have an upload property. The value of the upload property is an object that defines an addEventListener() method and defines a full set of progress event properties, such as onprogress and onload. (The upload object does not define an onreadystatechange property, however: uploads only trigger the new event types.)

You can use the upload event handlers just as you would use the regular progress event handlers. For an XMLHttpRequest object x, set x.onprogress to monitor the download progress of the response. And set x.upload.onprogress to monitor the upload progress of the request.

Example 18-11 demonstrates how to use upload progress events to present upload progress feedback to the user. This example also demonstrates how to obtain File objects from the Drag-and-Drop API and how to upload multiple files in a single XMLHttpRequest request with the FormData API. These features are still in draft form at the time of this writing and the example does not work in all browsers.

Example 18-11. Monitoring HTTP upload progress

// Find all elements of class "fileDropTarget" and register DnD event handlers // to make them respond to file drops. When files are dropped, upload them to // the URL specified in the data-uploadto attribute. whenReady(function() { var elts = document.getElementsByClassName("fileDropTarget"); for(var i = 0; i < elts.length; i++) { var target = elts[i]; var url = target.getAttribute("data-uploadto"); if (!url) continue; createFileUploadDropTarget(target, url); } function createFileUploadDropTarget(target, url) { // Keep track of whether we're currently uploading something so we can // reject drops. We could handle multiple concurrent uploads, but // that would make progress notification too tricky for this example. var uploading = false; console.log(target, url); target.ondragenter = function(e) { console.log("dragenter"); if (uploading) return; // Ignore drags if we're busy var types = e.dataTransfer.types; if (types && ((types.contains && types.contains("Files")) || (types.indexOf && types.indexOf("Files") !== -1))) { target.classList.add("wantdrop"); return false; } }; target.ondragover = function(e) { if (!uploading) return false; }; target.ondragleave = function(e) { if (!uploading) target.classList.remove("wantdrop"); }; target.ondrop = function(e) { if (uploading) return false; var files = e.dataTransfer.files; if (files && files.length) { uploading = true; var message = "Uploading files:<ul>"; for(var i = 0; i < files.length; i++) message += "<li>" + files[i].name + "</li>"; message += "</ul>"; target.innerHTML = message; target.classList.remove("wantdrop"); target.classList.add("uploading"); var xhr = new XMLHttpRequest(); xhr.open("POST", url); var body = new FormData(); for(var i = 0; i < files.length; i++) body.append(i, files[i]); xhr.upload.onprogress = function(e) { if (e.lengthComputable) { target.innerHTML = message + Math.round(e.loaded/e.total*100) + "% Complete"; } }; xhr.upload.onload = function(e) { uploading = false; target.classList.remove("uploading"); target.innerHTML = "Drop files to upload"; }; xhr.send(body); return false; } target.classList.remove("wantdrop"); } } });

Aborting Requests and Timeouts

You can cancel an HTTP request in process by calling the abort() method of the XMLHttpRequest object. The abort() method is available in all versions of XMLHttpRequest, and in XHR2, calling abort() triggers an abort event on the object. (Some browsers support abort events at the time of this writing. You can test for the presence of an「onabort」property on the XMLHttpRequest object.)

The primary reason to call abort() is to cancel or time-out requests that have taken too long to complete or when the responses become irrelevant. Suppose you’re using XMLHttpRequest to request auto-complete suggestions for a text input field. If the user types a new character into the field before the server’s suggestions can arrive, then the pending request is no longer interesting and can be aborted.

XHR2 defines a timeout property that specifies a time in milliseconds after which a request will automatically be aborted and also defines a timeout event that is supposed to be triggered (instead of the abort event) when such a timeout occurs. At the time of this writing, browsers do not implement these automatic timeouts (and their XMLHttpRequest objects do not have timeout or ontimeout properties). You can implement your own timeouts, however, with setTimeout() (Timers) and the abort() method. Example 18-12 demonstrates how to do this.

Example 18-12. Implementing timeouts

// Issue an HTTP GET request for the contents of the specified URL. // If the response arrives successfully, pass responseText to the callback. // If the response does not arrive in less than timeout ms, abort the request. // Browsers may fire "readystatechange" after abort(), and if a partial // request has been received, the status property may even be set, so // we need to set a flag so that we don't invoke the callback for a partial, // timed-out response. This problem does not arise if we use the load event. function timedGetText(url, timeout, callback) { var request = new XMLHttpRequest(); // Create new request. var timedout = false; // Whether we timed out or not. // Start a timer that will abort the request after timeout ms. var timer = setTimeout(function() { // Start a timer. If triggered, timedout = true; // set a flag and then request.abort(); // abort the request. }, timeout); // How long before we do this request.open("GET", url); // Specify URL to fetch request.onreadystatechange = function() { // Define event listener. if (request.readyState !== 4) return; // Ignore incomplete requests. if (timedout) return; // Ignore aborted requests. clearTimeout(timer); // Cancel pending timeout. if (request.status === 200) // If request was successful callback(request.responseText); // pass response to callback. }; request.send(null); // Send the request now }

Cross-Origin HTTP Requests

As part of the same-origin security policy (The Same-Origin Policy), the XMLHttpRequest object can normally issue HTTP requests only to the server from which the document that uses it was downloaded. This restriction closes security holes, but it is heavy-handed and also prevents a number of legitimate uses for cross-origin requests. You can use cross-origin URLs with <form> and <iframe> elements, and the browser will display the resulting cross-origin document. But because of the same-origin policy, the browser won’t allow the original script to inspect the contents of the cross-origin document. With XMLHttpRequest, document contents are always exposed through the responseText property, so the same-origin policy cannot allow XMLHttpRequest to make cross-origin requests. (Note that the <script> element has never really been subject to the same-origin policy: it will download and execute any script, regardless of origin. As we’ll see in HTTP by <script>: JSONP, this freedom to make cross-origin requests makes the <script> element an attractive Ajax transport alternative to XMLHttpRequest.)

XHR2 allows cross-origin requests to websites that opt-in by sending appropriate CORS (Cross-Origin Resource Sharing) headers in their HTTP responses. At the time of this writing, current versions of Firefox, Safari, and Chrome support CORS and IE8 supports it through a proprietary XDomainRequest object that is not documented here. As a web programmer, there is nothing special you need to do to make this work: if the browser supports CORS for XMLHttpRequest and if the website you are trying to make a cross-origin request to has decided to allow cross-origin requests with CORS, the same-origin policy will be relaxed and your cross-origin requests will just work.

Although there is nothing you have to do to make CORS-enabled cross-origin requests work, there are a few security details worth understanding. First, if you pass a username and password to the XMLHttpRequest open() method, they will never be sent with a cross-origin request (that would enable distributed password-cracking attempts). In addition, cross-origin requests do not normally include any other user credentials either: cookies and HTTP authentication tokens are not normally sent as part of the request and any cookies received as part of a cross-origin response are discarded. If your cross-origin request requires these kinds of credentials to succeed, you must set the withCredentials property of the XMLHttpRequest to true before you send() the request. It is uncommon to have to do this, but testing for the presence of the with Credentials property is a way to test for CORS support in your browser.

Example 18-13 is unobtrusive JavaScript code that uses XMLHttpRequest to make HTTP HEAD requests to download type, size, and date information about the resources linked to by the <a> elements in a document. The HEAD requests are made on demand, and the resulting link information is displayed in tooltips. The example assumes that information will not be available for cross-origin links, but on CORS-enabled browsers it attempts to download it anyway.

Example 18-13. Requesting link details with HEAD and CORS

/** * linkdetails.js * * This unobtrusive JavaScript module finds all <a> elements that have an href * attribute but no title attribute and adds an onmouseover event handler to * them. The event handler makes an XMLHttpRequest HEAD request to fetch * details about the linked resource, and then sets those details in the title * attribute of the link so that they will be displayed as a tooltip. */ whenReady(function() { // Is there any chance that cross-origin requests will succeed? var supportsCORS = (new XMLHttpRequest()).withCredentials !== undefined; // Loop through all links in the document var links = document.getElementsByTagName('a'); for(var i = 0; i < links.length; i++) { var link = links[i]; if (!link.href) continue; // Skip anchors that are not hyperlinks if (link.title) continue; // Skip links that already have tooltips // If this is a cross-origin link if (link.host !== location.host || link.protocol !== location.protocol) { link.title = "Off-site link"; // Assume we can't get any more info if (!supportsCORS) continue; // Quit now if no CORS support // Otherwise, we might be able to learn more about the link // So go ahead and register the event handlers so we can try. } // Register event handler to download link details on mouse over if (link.addEventListener) link.addEventListener("mouseover", mouseoverHandler, false); else link.attachEvent("onmouseover", mouseoverHandler); } function mouseoverHandler(e) { var link = e.target || e.srcElement; // The <a> element var url = link.href; // The link URL var req = new XMLHttpRequest(); // New request req.open("HEAD", url); // Ask for just the headers req.onreadystatechange = function() { // Event handler if (req.readyState !== 4) return; // Ignore incomplete requests if (req.status === 200) { // If successful var type = req.getResponseHeader("Content-Type"); // Get var size = req.getResponseHeader("Content-Length"); // link var date = req.getResponseHeader("Last-Modified"); // details // Display the details in a tooltip. link.title = "Type: " + type + " \n" + "Size: " + size + " \n" + "Date: " + date; } else { // If request failed, and the link doesn't already have an // "Off-site link" tooltip, then display the error. if (!link.title) link.title = "Couldn't fetch details: \n" + req.status + " " + req.statusText; } }; req.send(null); // Remove handler: we only want to fetch these headers once. if (link.removeEventListener) link.removeEventListener("mouseover", mouseoverHandler, false); else link.detachEvent("onmouseover", mouseoverHandler); } });

* * *

[43] Ajax is an (uncapitalized) acronym for Asynchronous JavaScript and XML. The term was coined by Jesse James Garrett and first appeared in his February 2005 essay「Ajax: A New Approach to Web Applications」.「Ajax」was a popular buzzword for many years; now it is simply a useful term for an web application architecture based on scripted HTTP requests.

